########################## 1 #################################
('public String createAndStoreCookie ( AuthenticationContext context , long expires , String ipAddr ) { String encodedCookieValue = encodeCookieValue ( context , expires , ipAddr ) ; UUID uuid = UUID . randomUUID ( ) ; COOKIE_CACHE . put ( uuid . toString ( ) , encodedCookieValue ) ; return uuid . toString ( ) ; } \n', 0.4305811308907069)

('public static Cookie createCookie ( String cookieName , @ Sensitive String cookieValue , HttpServletRequest req ) { return createCookie ( cookieName , cookieValue , - 1 , req ) ; }\n', 0.4225020510805666)

('public void createCookie ( final WebDriverUtil wdu , String name , String value ) { createCookie ( wdu , name , value , "3600" ) ; } \n', 0.4140910461108858)

('private static char [ ] makeCookieSafe ( byte [ ] bytes ) throws UnsupportedEncodingException { char [ ] chars = new String ( bytes , "ISO-8859-1" ) . toCharArray ( ) ; int BOT = 48 ; int TOP = 125 ; for ( int x = 0 ; x < chars . length ; x ++ ) { while ( chars [ x ] < BOT || chars [ x ] > TOP ) { if ( chars [ x ] < BOT ) chars [ x ] += BOT ; else if ( chars [ x ] > TOP ) chars [ x ] -= TOP ; } if ( chars [ x ] == \';\' ) { chars [ x ] = ( char ) BOT ; } } return chars ; } \n', 0.40956438993703875)

('@ Override protected Cookie createCookie ( String name , String value , Map < String , Object > properties ) { Cookie cookie = super . createCookie ( name , value , properties ) ; if ( ( properties != null ) && ! properties . isEmpty ( ) ) { Boolean httpOnly = ( Boolean ) properties . get ( COOKIE_PROPERTY_HTTP_ONLY ) ; if ( httpOnly != null ) { cookie . setHttpOnly ( httpOnly ) ; } } return cookie ; } \n', 0.4035154211879824)

("private static int createCookie ( final String name , final String value , int maxCookies , int cookieCount , final Map < String , String > cookies , final Map < String , String > additional ) { if ( ! name . isEmpty ( ) && name . charAt ( 0 ) == '$' ) { if ( additional . containsKey ( name ) ) { return cookieCount ; } additional . put ( name , value ) ; return cookieCount ; } else { if ( cookieCount == maxCookies ) { throw UndertowMessages . MESSAGES . tooManyCookies ( maxCookies ) ; } if ( cookies . containsKey ( name ) ) { return cookieCount ; } cookies . put ( name , value ) ; return ++ cookieCount ; } } \n", 0.4028103113546183)

('private static String createCookieHeader ( URLConnection cnx ) { String host = cnx . getURL ( ) . getHost ( ) ; StringBuilder cookiesHeader = new StringBuilder ( ) ; for ( Map . Entry < String , Map < String , String >> domainCookies : cookies . entrySet ( ) ) { if ( host . endsWith ( domainCookies . getKey ( ) ) ) { for ( Map . Entry < String , String > cookie : domainCookies . getValue ( ) . entrySet ( ) ) { cookiesHeader . append ( cookie . getKey ( ) ) ; cookiesHeader . append ( "=" ) ; cookiesHeader . append ( cookie . getValue ( ) ) ; cookiesHeader . append ( ";" ) ; } } } if ( cookiesHeader . length ( ) > 0 ) { cookiesHeader . deleteCharAt ( cookiesHeader . length ( ) - 1 ) ; } return cookiesHeader . toString ( ) ; } \n', 0.3979840222255352)

('private Map < String , List < String >> createCookieMap ( HttpServletRequest req ) { Map < String , List < String >> lookup = new HashMap < String , List < String >> ( ) ; for ( Cookie cookie : req . getCookies ( ) ) { String name = cookie . getName ( ) ; String value = cookie . getValue ( ) ; List < String > existing = lookup . get ( name ) ; if ( existing == null ) { existing = new ArrayList < String > ( ) ; lookup . put ( name , existing ) ; } existing . add ( value ) ; } return lookup ; } \n', 0.3977624309053096)

('@ SuppressWarnings ( "unused" ) private PortalCookieImpl ( ) { this . internalPortalCookieId = - 1 ; this . entityVersion = - 1 ; this . created = new Date ( ) ; this . expires = null ; this . value = null ; this . portletCookies = new HashSet < IPortletCookie > ( ) ; } \n', 0.3972550197315188)

('protected org . apache . http . client . CookieStore createProxyClientCookieStore ( final Page . Request pageRequest ) throws WWWEEEPortal . Exception { org . apache . http . client . CookieStore proxyClientCookieStore = PROXY_CLIENT_COOKIE_STORE_HOOK . value ( plugins , null , pageRequest ) ; if ( proxyClientCookieStore == null ) { proxyClientCookieStore = new BasicCookieStore ( ) ; } proxyClientCookieStore = PROXY_CLIENT_COOKIE_STORE_HOOK . requireFilteredResult ( PROXY_CLIENT_COOKIE_STORE_HOOK . filter ( plugins , null , pageRequest , proxyClientCookieStore ) ) ; return proxyClientCookieStore ; } \n', 0.3892450381155468)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 2 #################################
('void readPropertiesFile ( ) throws PersistitException { readPropertiesFile ( getProperty ( CONFIG_FILE_PROPERTY_NAME , DEFAULT_CONFIG_FILE ) ) ; } \n', 0.4728902416095277)

('public void readBuildPropertiesFile ( final Properties buildMetaDataProperties ) throws MojoExecutionException { InputStream inStream = null ; try { inStream = new BufferedInputStream ( new FileInputStream ( propertiesOutputFile ) ) ; buildMetaDataProperties . load ( inStream ) ; } catch ( final IOException e ) { throw new MojoExecutionException ( "Cannot-read-provided-properties-file:-" + propertiesOutputFile . getAbsolutePath ( ) , e ) ; } finally { IOUtil . close ( inStream ) ; } } \n', 0.4700649897251628)

('public static Properties readPropertiesFile ( String propertiesFileName ) throws Exception { Properties props = new Properties ( ) ; FileInputStream in = new FileInputStream ( propertiesFileName ) ; props . load ( in ) ; in . close ( ) ; return props ; } \n', 0.46735082551866003)

('public static Properties readPropertiesFromFile ( File file ) throws IOException { Properties cfg = new Properties ( ) ; FileInputStream in = new FileInputStream ( file ) ; try { cfg . load ( in ) ; } finally { in . close ( ) ; } return cfg ; } \n', 0.4672524262298187)

('public static void readPropertiesFromFile ( String fileName ) { if ( fileName == null ) { fileName = CONFIG_FILE_LOCATION ; } constructDefaultProperties ( ) ; File configFile = new File ( fileName ) ; if ( configFile . exists ( ) && configFile . canRead ( ) ) { try { InputStream inputStream = new FileInputStream ( configFile ) ; if ( fileName . substring ( fileName . length ( ) - 4 ) . equalsIgnoreCase ( ".xml" ) ) { m_properties . loadFromXML ( inputStream ) ; } else { m_properties . load ( inputStream ) ; } } catch ( Exception e ) { System . err . println ( "Cannot-load-Ladder-properties-from-file:-" + fileName ) ; e . printStackTrace ( ) ; } } else { System . err . println ( "Cannot-read-file:-" + fileName ) ; } } \n', 0.4670143213104635)

('public static String readPropertiesFile ( String filePath ) { logger . info ( "readPropertiesFile---filePath:-" + filePath ) ; Properties properties = new Properties ( ) ; try { FileInputStream inStream = new FileInputStream ( filePath ) ; properties . load ( inStream ) ; String result = properties . getProperty ( "folderPath" ) ; logger . info ( "readPropertiesFile---result:-" + result ) ; return result ; } catch ( Exception e ) { logger . warn ( "readPropertiesFile---" + e ) ; return null ; } } \n', 0.4658946316036422)

('public Properties readPropertiesFromFile ( InputStream inputStream ) throws IOException { Properties pendulumProperties = new Properties ( ) ; pendulumProperties . load ( inputStream ) ; logger . trace ( "Properties-loaded..." ) ; return pendulumProperties ; } \n', 0.46525082407992885)

('private void readPropertiesFile ( ) { Properties properties = new Properties ( ) ; try { FileInputStream in = new FileInputStream ( "pamanager.properties" ) ; properties . load ( new BufferedInputStream ( in ) ) ; String property ; property = properties . getProperty ( "AgentClassNames" ) ; StringTokenizer tok = new StringTokenizer ( property , ";" ) ; String displayName ; while ( tok . hasMoreTokens ( ) ) { String agentClassName = tok . nextToken ( ) ; CIAgent agent = null ; try { Class klas = Class . forName ( agentClassName ) ; agent = ( CIAgent ) klas . newInstance ( ) ; displayName = agent . getDisplayName ( ) ; System . out . println ( "Adding-agent-class-...-" + displayName ) ; addAgentMenuItem ( displayName ) ; agentClasses . put ( displayName , agentClassName ) ; } catch ( Exception exc ) { System . out . println ( "Error-can\'t-instantiate-agent:-" + agentClassName + "-" + exc . toString ( ) ) ; } } } catch ( Exception e ) { System . out . println ( "Error:-cannot-find-or-load-PAManager-properties-file" ) ; } } \n', 0.46458496940699434)

('public static Properties readPropertiesFromFile ( String path_to_properties ) throws IOException { Properties prop = new Properties ( ) ; prop . load ( new FileInputStream ( path_to_properties ) ) ; return prop ; } \n', 0.4629999556363128)

('public void readFileProperties ( File propFile ) throws IOException { InputStream is = new FileInputStream ( propFile ) ; prop . load ( is ) ; } \n', 0.46279071056391474)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 3 #################################
('protected File getExecutableFromPath ( String name ) throws IOException { if ( SystemUtils . IS_OS_WINDOWS ) { name = name + ".exe" ; } String systemPath = System . getenv ( "PATH" ) ; if ( systemPath == null ) { systemPath = System . getenv ( "path" ) ; } if ( systemPath == null ) { throw new IOException ( "Path-is-not-set,-cannot-locate-" + name ) ; } String [ ] paths = systemPath . split ( File . pathSeparator ) ; for ( String pathDir : paths ) { File file = new File ( pathDir , name ) ; if ( file . exists ( ) && file . isFile ( ) && file . canExecute ( ) ) { return file ; } } throw new IOException ( "Could-not-locate-executable-(or-could-locate,-but-does-not-have-execution-rights):-" + name ) ; } \n', 0.40266258349057465)

('private String getFullExecutablePath ( ) { StringBuffer pathBuf = new StringBuffer ( ) ; String optionalExecutablePath = getServerProps ( ) . getProperty ( EXECUTABLE_PATH_KEY ) ; if ( optionalExecutablePath == null ) { String basedir = getServerProps ( ) . getProperty ( BASEDIR_KEY ) ; pathBuf . append ( basedir ) ; if ( ! basedir . endsWith ( File . separator ) ) { pathBuf . append ( File . separatorChar ) ; } if ( runningOnWindows ( ) ) { pathBuf . append ( "bin" ) ; } else { pathBuf . append ( "libexec" ) ; } pathBuf . append ( File . separatorChar ) ; } else { pathBuf . append ( optionalExecutablePath ) ; if ( ! optionalExecutablePath . endsWith ( File . separator ) ) { pathBuf . append ( File . separatorChar ) ; } } String executableName = getServerProps ( ) . getProperty ( EXECUTABLE_NAME_KEY , "mysqld" ) ; pathBuf . append ( executableName ) ; return pathBuf . toString ( ) ; } \n', 0.3935444546000719)

('private String getFullExecutablePath ( ) { StringBuilder pathBuf = new StringBuilder ( ) ; String optionalExecutablePath = getServerProps ( ) . getProperty ( EXECUTABLE_PATH_KEY ) ; if ( optionalExecutablePath == null ) { String basedir = getServerProps ( ) . getProperty ( BASEDIR_KEY ) ; pathBuf . append ( basedir ) ; if ( ! basedir . endsWith ( File . separator ) ) { pathBuf . append ( File . separatorChar ) ; } if ( runningOnWindows ( ) ) { pathBuf . append ( "bin" ) ; } else { pathBuf . append ( "libexec" ) ; } pathBuf . append ( File . separatorChar ) ; } else { pathBuf . append ( optionalExecutablePath ) ; if ( ! optionalExecutablePath . endsWith ( File . separator ) ) { pathBuf . append ( File . separatorChar ) ; } } String executableName = getServerProps ( ) . getProperty ( EXECUTABLE_NAME_KEY , "mysqld" ) ; pathBuf . append ( executableName ) ; return pathBuf . toString ( ) ; } \n', 0.3877398251437092)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 4 #################################
('private void generatAllPermutation ( Startup source , List < Startup > newlist , List < Startup > startupList ) { if ( startupList . size ( ) == 0 ) { newlist . add ( 0 , source ) ; graph . add ( newlist ) ; return ; } for ( int i = 0 ; i < startupList . size ( ) ; i ++ ) { List < Startup > tempList2 = new ArrayList < Startup > ( newlist ) ; tempList2 . add ( startupList . get ( i ) ) ; List < Startup > tempList = new ArrayList < Startup > ( startupList ) ; tempList . remove ( i ) ; generatAllPermutation ( source , tempList2 , tempList ) ; } } \n', 0.410642952921933)

('public List < T > nextPermutationAsList ( List < T > destination ) { generateNextPermutationIndices ( ) ; destination . clear ( ) ; for ( int i : permutationIndices ) { destination . add ( elements [ i ] ) ; } return destination ; } \n', 0.3816536137920808)

('public static List < Integer > randPermutation ( final int size ) { positiveCheck ( size ) ; final List < Integer > permutation = new ArrayList < > ( ) ; for ( int i = 1 ; i < size + 1 ; ++ i ) permutation . add ( i ) ; Collections . shuffle ( permutation ) ; return permutation ; } \n', 0.37461130247001817)

('public List < String > allPermutationsI ( String s ) { LinkedList < String > res = new LinkedList < String > ( ) ; if ( s == null || s . length ( ) == 0 ) return res ; HashSet < String > set = new HashSet < String > ( ) ; res . add ( "" ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int size = res . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { String x = res . poll ( ) ; for ( int k = 0 ; k <= x . length ( ) ; k ++ ) { String nstr = x . substring ( 0 , k ) + s . charAt ( i ) + x . substring ( k ) ; if ( ! set . contains ( nstr ) ) { set . add ( nstr ) ; res . add ( nstr ) ; } } } } return res ; } \n', 0.37202669574220754)

('private void checkPermutation ( Integer [ ] permutation ) throws PermutationException { int n = permutation . length ; ArrayList < Integer > check = new ArrayList < Integer > ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( check . contains ( permutation [ i ] ) ) ) check . add ( permutation [ i ] ) ; } if ( check . size ( ) != n ) throw new PermutationException ( "Permutation-does-not-make-sense!" ) ; Integer [ ] sorted = new Integer [ n ] ; check . toArray ( sorted ) ; Arrays . sort ( sorted ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( sorted [ i ] != ( i + 1 ) ) throw new PermutationException ( "Permutation-does-not-make-sense!" ) ; } } \n', 0.37120477735143154)

('private static void permute ( List < List < Integer >> result , List < Integer > temp , List < Integer > remaining ) { if ( remaining . isEmpty ( ) ) { result . add ( temp ) ; return ; } Set < Integer > dedup = new HashSet < Integer > ( ) ; Iterator < Integer > iter = remaining . iterator ( ) ; while ( iter . hasNext ( ) ) { Integer i = iter . next ( ) ; if ( dedup . contains ( i ) ) { continue ; } dedup . add ( i ) ; List < Integer > t = new ArrayList < Integer > ( temp ) ; List < Integer > r = new ArrayList < Integer > ( remaining ) ; t . add ( i ) ; r . remove ( i ) ; permute ( result , t , r ) ; } } \n', 0.3636869289715382)

('private void nextTokensPermutation ( ) { Matrix . Column . Row [ ] rowsPermutation ; rowsPermutation = ( Matrix . Column . Row [ ] ) permutations . next ( ) ; List currentPermutationRows = new ArrayList ( ) ; List currentPermuationTokens = new ArrayList ( ) ; for ( int i = 0 ; i < rowsPermutation . length ; i ++ ) { Matrix . Column . Row row = rowsPermutation [ i ] ; for ( Iterator iterator = row . getTokens ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { currentPermuationTokens . add ( iterator . next ( ) ) ; currentPermutationRows . add ( row ) ; } } this . currentPermuationTokens = currentPermuationTokens ; this . currentPermutationRows = currentPermutationRows ; currentPermutationTokensStartOffset = 0 ; currentShingleLength = minimumShingleSize - 1 ; } \n', 0.35785553963653316)

('public void generateAllPermutationIteratively ( Startup source , List < Startup > list ) { int i = 0 ; int N = list . size ( ) ; List < Startup > newList = new ArrayList < Startup > ( ) ; newList . add ( source ) ; newList . addAll ( list ) ; graph . add ( newList ) ; int p [ ] = new int [ N ] ; for ( i = 0 ; i < N ; i ++ ) { p [ i ] = 0 ; } i = 1 ; while ( i < N ) { if ( p [ i ] < i ) { int j = i % 2 * p [ i ] ; Startup tmp = list . get ( j ) ; list . set ( j , list . get ( i ) ) ; list . set ( i , tmp ) ; newList = new ArrayList < Startup > ( ) ; newList . add ( source ) ; newList . addAll ( list ) ; graph . add ( newList ) ; p [ i ] ++ ; i = 1 ; } else { p [ i ] = 0 ; i ++ ; } } } \n', 0.35615898405931584)

('final ArrayList < PermutationArtifact > getPermutationArtifacts ( final ArtifactSet artifacts ) { final ArrayList < PermutationArtifact > results = new ArrayList < PermutationArtifact > ( ) ; for ( final PermutationArtifact permutationArtifact : artifacts . find ( PermutationArtifact . class ) ) { results . add ( permutationArtifact ) ; } return results ; } \n', 0.35573277491089894)

('public static < C extends RingElem < C >> List < GenPolynomial < GenPolynomial < C >>> permutationOnCoefficients ( List < Integer > P , GenPolynomialRing < GenPolynomial < C >> R , List < GenPolynomial < GenPolynomial < C >>> L ) { if ( L == null || L . size ( ) == 0 ) { return L ; } List < GenPolynomial < GenPolynomial < C >>> K = new ArrayList < GenPolynomial < GenPolynomial < C >>> ( L . size ( ) ) ; for ( GenPolynomial < GenPolynomial < C >> a : L ) { GenPolynomial < GenPolynomial < C >> b = permutationOnCoefficients ( P , R , a ) ; K . add ( b ) ; } return K ; } \n', 0.3532799461587658)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 5 #################################
('@ SuppressWarnings ( "deprecation" ) @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( 29 ) ; format ( ( getYear ( ) + 1900 ) , 4 , sb ) ; sb . append ( \'-\' ) ; format ( ( getMonth ( ) + 1 ) , 2 , sb ) ; sb . append ( \'-\' ) ; format ( getDate ( ) , 2 , sb ) ; sb . append ( \'-\' ) ; format ( getHours ( ) , 2 , sb ) ; sb . append ( \':\' ) ; format ( getMinutes ( ) , 2 , sb ) ; sb . append ( \':\' ) ; format ( getSeconds ( ) , 2 , sb ) ; sb . append ( \'.\' ) ; if ( nanos == 0 ) { sb . append ( \'0\' ) ; } else { format ( nanos , 9 , sb ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == \'0\' ) { sb . setLength ( sb . length ( ) - 1 ) ; } } return sb . toString ( ) ; } \n', 0.37470044938370306)

('private void checkDateToString ( ) { int COUNT = COUNT_SLOW ; Date dt = new Date ( ) ; for ( int i = 0 ; i < AVERAGE ; i ++ ) { start ( "Date" , "toString" ) ; for ( int j = 0 ; j < COUNT ; j ++ ) { SimpleDateFormat sdf = new SimpleDateFormat ( "dd-MMM-yyyy" ) ; String str = sdf . format ( dt ) ; if ( str == null ) { System . out . println ( "Anti-optimise" ) ; } } end ( COUNT ) ; } } \n', 0.3637038677245125)

('@ Override public String getFormattedDateString ( long timeMillis ) { DateTime dt = new DateTime ( timeMillis ) ; if ( dt . monthOfYear ( ) . get ( ) == 12 && dt . weekOfWeekyear ( ) . get ( ) < 3 ) { return dt . getYearOfCentury ( ) + "53" ; } return Integer . toString ( dt . getYearOfCentury ( ) ) + String . format ( "%02d" , dt . weekOfWeekyear ( ) . get ( ) ) ; } \n', 0.36337303762875633)

('@ Deprecated public static String ISO8601DateToString ( java . util . Date dt ) { String rv = null ; if ( dt != null ) { rv = DateParser . getIsoDate ( dt ) ; } return rv ; } \n', 0.3632412265227978)

('public static String convertDateToStringInRFC3339 ( Date date ) { DateTime dt = new DateTime ( date . getTime ( ) , 480 ) ; String wholeFormat = dt . toString ( ) ; String result = wholeFormat . substring ( 0 , wholeFormat . indexOf ( "." ) ) + wholeFormat . substring ( wholeFormat . indexOf ( "." ) + 4 ) ; return result ; } \n', 0.359281149425399)

('public static String dateToString ( Date date ) { String dateString = dateFormatter . format ( new Date ( ) ) ; return dateString . substring ( 0 , 22 ) + ":" + dateString . substring ( 22 ) ; } \n', 0.35915568198628)

('public static String [ ] dateArrayTOStringArray ( Date [ ] dates ) { if ( dates == null ) { return null ; } SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd-HH:mm:ss" ) ; String [ ] dates_s = new String [ dates . length ] ; for ( int i = 0 ; i < dates . length ; i ++ ) { dates_s [ i ] = format . format ( dates [ i ] ) ; } return dates_s ; } \n', 0.3575821453246161)

('private static int compareDateString ( final Object o1 , final Object o2 ) { final String value1 = DatePropertyParser . format ( ( Date ) o1 , DateProperty . DEFAULT_FORMAT ) ; final String value2 = ( String ) o2 ; return value1 . compareTo ( value2 ) ; } \n', 0.35643396289583446)

('public String formatSetOfDatesToString ( Set < Date > dates ) { StringBuffer buff = new StringBuffer ( ) ; buff . append ( "[" ) ; for ( Date d : dates ) { String dateString = formatDateToString ( d ) + ",-" ; buff . append ( dateString ) ; } buff . delete ( buff . length ( ) - 2 , buff . length ( ) ) ; buff . append ( "]" ) ; return buff . toString ( ) ; } \n', 0.35619195768483575)

('protected String dateToString ( Date d ) { return "\'" + d . toString ( ) + "\'" ; } \n', 0.35578955102242393)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 6 #################################
('public InputDialogWithCheckbox ( String message , @ Nls ( capitalization = Nls . Capitalization . Title ) String title , String checkboxText , boolean checked , boolean checkboxEnabled , @ Nullable Icon icon , @ Nullable String initialValue , @ Nullable InputValidator validator ) { super ( message , title , icon , initialValue , validator ) ; myCheckBox . setText ( checkboxText ) ; myCheckBox . setSelected ( checked ) ; myCheckBox . setEnabled ( checkboxEnabled ) ; } \n', 0.3901640840621118)

('public static JCheckBox checkbox ( String text , final PropertyChangeBean bean , final String property ) { final JCheckBox checkbox = new JCheckBox ( text ) ; bean . addPropertyChangeListener ( property , new PropertyChangeListener ( ) { @ Override public void propertyChange ( PropertyChangeEvent evt ) { checkbox . setSelected ( ( boolean ) evt . getNewValue ( ) ) ; } } ) ; checkbox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { ReflectionUtils . setValue ( bean , property , checkbox . isSelected ( ) ) ; } } ) ; return checkbox ; } \n', 0.3811776042016062)

('private Button createCheckButton ( Composite parent , int fillStrategy , int horizontalSpan , String text , String property ) { final Button button = new Button ( parent , SWT . CHECK ) ; GridData groupGridData = new GridData ( fillStrategy ) ; groupGridData . horizontalSpan = horizontalSpan ; button . setLayoutData ( groupGridData ) ; button . setText ( text ) ; this . synchHelper . synchCheckbox ( button , property , null ) ; return button ; } \n', 0.3702436781980704)

('private void levelAbsoluteCheckboxActionPerformed ( java . awt . event . ActionEvent evt ) { updateLevelToolParams ( ) ; levelAbsoluteHeightField . setEnabled ( levelAbsoluteCheckbox . isEnabled ( ) ) ; } \n', 0.3701771759279804)

('private Button createCheckButton ( Composite parent , String text , String property ) { final Button button = new Button ( parent , SWT . CHECK ) ; GridData groupGridData = new GridData ( GridData . FILL_HORIZONTAL ) ; groupGridData . horizontalSpan = 3 ; button . setLayoutData ( groupGridData ) ; button . setText ( text ) ; button . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent e ) { boolean isChecked = button . getSelection ( ) ; if ( tableNameText != null ) { tableNameText . setEnabled ( ! isChecked ) ; } } } ) ; synchHelper . synchCheckbox ( button , property , null ) ; return button ; } \n', 0.36840381854572657)

('public void registerControlCheckbox ( final JCheckBox controlCheckBox ) throws Exception { if ( registeredAlready ) { throw new IllegalStateException ( "Error-when-registering-" + controlCheckBox + "-for-" + this + ".-Already-registered." ) ; } this . addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { controlCheckBox . setSelected ( false ) ; } } ) ; this . controlCheckBox = controlCheckBox ; controlCheckBox . addActionListener ( this ) ; } \n', 0.3676160133525304)

('private Button createTableNameCheckButton ( Composite parent , String text , String property ) { final Button button = new Button ( parent , SWT . CHECK ) ; GridData groupGridData = new GridData ( GridData . FILL_HORIZONTAL ) ; groupGridData . horizontalSpan = 3 ; button . setLayoutData ( groupGridData ) ; button . setText ( text ) ; button . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent e ) { boolean isChecked = button . getSelection ( ) ; if ( tableNameText != null ) { tableNameText . setEnabled ( ! isChecked ) ; } } } ) ; synchHelper . synchCheckbox ( button , property , null ) ; return button ; } \n', 0.3673758646090689)

('public static JCheckBoxMenuItem makeCheckboxMenuItem ( String label , final Object object , final String property , boolean value , final Object arg ) { final JCheckBoxMenuItem cbx = new JCheckBoxMenuItem ( label , value ) ; ItemListener listener = new ItemListener ( ) { public void itemStateChanged ( ItemEvent event ) { try { String methodName = "set" + property . substring ( 0 , 1 ) . toUpperCase ( ) + property . substring ( 1 ) ; Method theMethod = findMethod ( object . getClass ( ) , methodName , ( ( arg == null ) ? new Class [ ] { Boolean . TYPE } : new Class [ ] { Boolean . TYPE , arg . getClass ( ) } ) ) ; if ( theMethod == null ) { System . err . println ( "Unknown-method:" + object . getClass ( ) + "." + methodName ) ; } else { theMethod . invoke ( object , ( ( arg == null ) ? new Object [ ] { new Boolean ( cbx . isSelected ( ) ) } : new Object [ ] { new Boolean ( cbx . isSelected ( ) ) , arg } ) ) ; } } catch ( Exception exc ) { System . err . println ( "Error-in-makeCheckbox:" + exc ) ; exc . printStackTrace ( ) ; } } } ; cbx . addItemListener ( listener ) ; return cbx ; } \n', 0.3624481996970937)

('public Checkbox addCheckbox ( String itemId , String name , CheckboxValue initialValue ) { Checkbox checkbox = new Checkbox ( lcdProc , this , itemId , name , initialValue ) ; menuItems . add ( checkbox ) ; return checkbox ; } \n', 0.3612132443917369)

('protected static Button createCheckbox ( final Composite parent , final int style , final String label , final String tooltip , final PropertyChangeListener listener ) { Button checkboxButton = new Button ( parent , style ) ; checkboxButton . setText ( label ) ; if ( tooltip != null ) { checkboxButton . setToolTipText ( tooltip ) ; } checkboxButton . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { listener . propertyChange ( null ) ; } } ) ; return checkboxButton ; } \n', 0.3610592176785323)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 7 #################################
('public static < T extends Comparable < ? super T > > int [ ] sort ( T [ ] arr ) { int [ ] order = new int [ arr . length ] ; for ( int i = 0 ; i < order . length ; i ++ ) { order [ i ] = i ; } sort ( arr , order ) ; return order ; }\n', 0.4509236000661915)

('public static int [ ] sortOrder ( double [ ] values ) { SortOrder [ ] array = new SortOrder [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { array [ i ] = new SortOrder < Double > ( values [ i ] , i ) ; } Collections . shuffle ( Arrays . asList ( array ) , getRandomGenerator ( ) ) ; Arrays . sort ( array ) ; int [ ] order = new int [ values . length ] ; for ( int i = 0 ; i < order . length ; i ++ ) { order [ i ] = array [ i ] . getIndex ( ) ; } return order ; } \n', 0.4355141284507751)

('public static int [ ] sort ( double [ ] arr ) { int [ ] order = new int [ arr . length ] ; for ( int i = 0 ; i < order . length ; i ++ ) { order [ i ] = i ; } sort ( arr , order ) ; return order ; }\n', 0.43289642033415104)

('public static int [ ] sortOrder ( int [ ] values ) { SortOrder [ ] array = new SortOrder [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { array [ i ] = new SortOrder < Integer > ( values [ i ] , i ) ; } Collections . shuffle ( Arrays . asList ( array ) , getRandomGenerator ( ) ) ; Arrays . sort ( array ) ; int [ ] order = new int [ values . length ] ; for ( int i = 0 ; i < order . length ; i ++ ) { order [ i ] = array [ i ] . getIndex ( ) ; } return order ; } \n', 0.42600939803346727)

('public String getSortOrder ( String alias ) { for ( int i = 0 ; i < sorts . length ; i ++ ) { Sort sort = sorts [ i ] ; if ( sort . getAlias ( ) . equals ( alias ) ) { return sort . getSortOrder ( ) ; } } return "" ; } \n', 0.41544238103833553)

('public void sort ( Object [ ] array , boolean reverse ) { if ( array instanceof Comparable [ ] ) { if ( reverse ) { Arrays . sort ( array , Collections . reverseOrder ( ) ) ; } else { Arrays . sort ( array ) ; } } else { if ( reverse ) { Arrays . sort ( array , TOSTRING_COMPARATOR_DESC ) ; } else { Arrays . sort ( array , TOSTRING_COMPARATOR_ASC ) ; } } } \n', 0.41135968299619513)

('protected Integer [ ] getSortOrder ( ) { Integer [ ] sortOrder = new Integer [ varimp . length ] ; for ( int i = 0 ; i < sortOrder . length ; i ++ ) sortOrder [ i ] = i ; Arrays . sort ( sortOrder , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { float f = varimp [ o1 ] - varimp [ o2 ] ; return f < 0 ? 1 : ( f > 0 ? - 1 : 0 ) ; } } ) ; return sortOrder ; } \n', 0.40813346489696245)

('public static int [ ] sortOrder ( double [ ] values , boolean decreasing ) { List < ComparablePair < Double , Integer >> vals = new ArrayList < ComparablePair < Double , Integer >> ( ) ; for ( int i = 0 ; i < values . length ; i ++ ) { vals . add ( new ComparablePair < Double , Integer > ( values [ i ] , i ) ) ; } if ( decreasing ) { Collections . sort ( vals , Collections . reverseOrder ( ) ) ; } else { Collections . sort ( vals ) ; } int [ ] ranks = new int [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { ranks [ i ] = vals . get ( i ) . two + 1 ; } return ranks ; } \n', 0.40667122233441066)

('private List < Map . Entry < String , Long >> sortByOrder ( Map < String , Long > referenceTestWithTestcaseCountMap , final boolean asc ) { List < Map . Entry < String , Long >> sortedEntriesList = new ArrayList < Map . Entry < String , Long >> ( referenceTestWithTestcaseCountMap . entrySet ( ) ) ; Collections . sort ( sortedEntriesList , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { Map . Entry e1 = ( Map . Entry ) o1 ; Map . Entry e2 = ( Map . Entry ) o2 ; if ( asc ) { return ( ( Comparable ) e1 . getValue ( ) ) . compareTo ( e2 . getValue ( ) ) ; } else { return - ( ( Comparable ) e1 . getValue ( ) ) . compareTo ( e2 . getValue ( ) ) ; } } } ) ; return sortedEntriesList ; } \n', 0.40153166985923516)

('public SortOrder [ ] getSortOrderCycle ( ) { return Arrays . copyOf ( sortOrderCycle , sortOrderCycle . length ) ; } \n', 0.3991838815300108)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 8 #################################
('public static String formatDate ( Date date , String format ) { if ( date == null ) return "" ; else { DateFormatter dateFormatter = new DateFormatter ( ) ; dateFormatter . setFormat ( format ) ; dateFormatter . setDate ( date ) ; return dateFormatter . getFormattedDate ( ) ; } } \n', 0.4164182879557735)

('private String formatDate ( long date ) { DateFormat dateFormat = new SimpleDateFormat ( DATE_FORMATS [ 0 ] , Locale . US ) ; dateFormat . setTimeZone ( GMT ) ; return dateFormat . format ( new Date ( date ) ) ; } \n', 0.4141397734516934)

('public static String formatDate ( String dateFormat , String date , String toFormat , Locale fromLocale , Locale toLocale ) { String formatted = "" ; DateFormat formatter = fromLocale == null ? new SimpleDateFormat ( dateFormat ) : new SimpleDateFormat ( dateFormat , Locale . getDefault ( ) ) ; try { Date dateStr = formatter . parse ( date ) ; formatted = formatter . format ( dateStr ) ; Date formatDate = formatter . parse ( formatted ) ; formatter = toLocale == null ? new SimpleDateFormat ( toFormat , Locale . getDefault ( ) ) : new SimpleDateFormat ( toFormat , toLocale ) ; formatted = formatter . format ( formatDate ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return formatted ; } \n', 0.41215517468244756)

('public static String formatDateRfc822 ( Date date ) { if ( date != null ) { SimpleDateFormat dateFormater = new SimpleDateFormat ( "EEE,-dd-MMM-yyyy-HH:mm:ss-\'GMT\'" , Locale . US ) ; dateFormater . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; return dateFormater . format ( date ) ; } return null ; } \n', 0.4116746841045593)

('public static String formatDate ( Context context , String string ) { if ( string == null ) { return null ; } string = string . trim ( ) ; if ( string . length ( ) == 0 ) { return string ; } ParsePosition parsePosition = new ParsePosition ( 0 ) ; Date date ; synchronized ( NO_YEAR_DATE_FORMAT ) { date = NO_YEAR_DATE_FORMAT . parse ( string , parsePosition ) ; } if ( parsePosition . getIndex ( ) == string . length ( ) ) { java . text . DateFormat outFormat = isMonthBeforeDate ( context ) ? FORMAT_WITHOUT_YEAR_MONTH_FIRST : FORMAT_WITHOUT_YEAR_DATE_FIRST ; synchronized ( outFormat ) { return outFormat . format ( date ) ; } } for ( int i = 0 ; i < DATE_FORMATS . length ; i ++ ) { SimpleDateFormat f = DATE_FORMATS [ i ] ; synchronized ( f ) { parsePosition . setIndex ( 0 ) ; date = f . parse ( string , parsePosition ) ; if ( parsePosition . getIndex ( ) == string . length ( ) ) { java . text . DateFormat outFormat = DateFormat . getDateFormat ( context ) ; outFormat . setTimeZone ( UTC_TIMEZONE ) ; return outFormat . format ( date ) ; } } } return string ; } \n', 0.40677073095125305)

('public static String formatDate ( Date date ) { return ( ( DateFormat ) DateFormats . formats [ 0 ] . clone ( ) ) . format ( date ) ; } \n', 0.4067350986598065)

('public String formatDate ( long millis ) { if ( dateFormater == null ) { dateFormater = new SimpleDateFormat ( "yyyy-MM-dd\'T\'HH:mm:ss\'Z\'" , Locale . US ) ; dateFormater . setTimeZone ( TimeZone . getTimeZone ( "UTC" ) ) ; } return dateFormater . format ( millis ) ; } \n', 0.40604417110254865)

('public static String formatDate ( final Date date , String pattern ) { SimpleDateFormat formater = new SimpleDateFormat ( pattern ) ; return formater . format ( date ) ; } \n', 0.4033030078497797)

('public static String formatDate ( Date date ) { SimpleDateFormat formater = new SimpleDateFormat ( CURRENT_DATE_FORMAT ) ; return formater . format ( date ) ; } \n', 0.4024464448173541)

('public static String formatDate ( Date d , String format ) { if ( d == null ) return "" ; SimpleDateFormat formater = new SimpleDateFormat ( format ) ; formater . setLenient ( false ) ; return formater . format ( d ) ; } \n', 0.4019399926482925)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 9 #################################
('public String getCurrentDate ( ) { return this . getCurrentDate ( SHORT_FORMAT ) ; } \n', 0.37570775791795535)

('public static String getCurrentDate ( int nDelta ) throws RemoteException { java . util . Date currentDate = new java . util . Date ( ) ; currentDate . setDate ( currentDate . getDate ( ) + nDelta ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( "MM/dd/yy" ) ; String dateString = dateFormat . format ( currentDate ) ; return dateString ; } \n', 0.3712414400539603)

('public String getCurrentDate ( ) throws TaskFailedException { return new SimpleDateFormat ( "dd/MM/yyyy" ) . format ( new Date ( ) ) ; } \n', 0.3683584257158175)

('public final static String getCurrentDate ( ) { return DateTime . getCurrentDateTimeWithFormat ( "MMM-dd,-yyyy" ) ; } \n', 0.368079131797291)

('public String getCurrentDueDate ( ) { return new SimpleDateFormat ( DATE_FORMAT ) . format ( currentTodo . getDueDate ( ) ) ; } \n', 0.3675091174817768)

('@ Override public LocalDateTime getCurrentDateTime ( ) { LocalDateTime currentTime = LocalDateTime . now ( ) ; LOGGER . debug ( "Returning-current-datetime:-{}" , currentTime ) ; return currentTime ; } \n', 0.3662182816286441)

('public static Date getCurrentDate ( ) throws Exception { return new GregorianCalendar ( enLocale ) . getTime ( ) ; } \n', 0.3661878203261305)

('public static java . util . Date getCurrentDate ( ) { java . util . Date currentDate = new java . util . Date ( ) ; return currentDate ; } \n', 0.36598253111781465)

('private String getCurrentDateAndTime ( ) { String currentDateAndTime = DATE_FORMATTER . format ( new Date ( ) ) ; return currentDateAndTime ; } \n', 0.36511240573844533)

('public static String getCurrentDate ( String dateFormat ) { Date d = new Date ( ) ; String currentDate = new SimpleDateFormat ( dateFormat ) . format ( d . getTime ( ) ) ; return currentDate ; } \n', 0.3648474477297632)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 10 #################################
('public int randomlyChoosePlaces ( ArrayList < Place > placesArray , int maxResults ) { int tailOffset = 0 ; int arraySize = placesArray . size ( ) ; Random rand = new Random ( ) ; for ( int i = 0 ; i < maxResults ; i ++ ) { int ranNumber = rand . nextInt ( arraySize - tailOffset ) ; Place temp = placesArray . get ( ranNumber ) ; placesArray . set ( ranNumber , placesArray . get ( tailOffset ) ) ; placesArray . set ( tailOffset , temp ) ; tailOffset += 1 ; } return arraySize - tailOffset ; } \n', 0.4239700392748241)

('private static ContentItem [ ] pickRandomDocs ( ContentItem [ ] newsItems , double percentOfDocs ) { if ( percentOfDocs < 0.0 || percentOfDocs > 1.0 ) { throw new IllegalArgumentException ( "Value-for-\'percentOfDocs\'-argument-should-be-" + "between-0-and-1." ) ; } Random rand = new Random ( ) ; int sampleSize = ( int ) Math . round ( percentOfDocs * newsItems . length ) ; Map < Integer , Item > pickedItems = new HashMap < Integer , Item > ( ) ; while ( pickedItems . size ( ) < sampleSize ) { int itemId = rand . nextInt ( newsItems . length ) ; Item item = newsItems [ itemId ] ; if ( ! pickedItems . containsKey ( item . getId ( ) ) ) { pickedItems . put ( item . getId ( ) , item ) ; } } return pickedItems . values ( ) . toArray ( new ContentItem [ pickedItems . size ( ) ] ) ; } \n', 0.41178510249070177)

('File pickRandomWritableDir ( File excludedDir ) throws NoWritableLedgerDirException { List < File > writableDirs = getWritableLedgerDirs ( ) ; final int start = rand . nextInt ( writableDirs . size ( ) ) ; int idx = start ; File candidate = writableDirs . get ( idx ) ; while ( null != excludedDir && excludedDir . equals ( candidate ) ) { idx = ( idx + 1 ) % writableDirs . size ( ) ; if ( idx == start ) { throw new NoWritableLedgerDirException ( "No-writable-directories-found-from-" + "-available-writable-dirs-(" + writableDirs + ")-:-exclude-dir-" + excludedDir ) ; } candidate = writableDirs . get ( idx ) ; } return candidate ; } \n', 0.40499171167040976)

('public void sayPickItUp ( String name ) { Random rand = new Random ( ) ; int i = Math . abs ( rand . nextInt ( ) % playerPickItUpPrompt . length ) ; speak ( playerPickItUpPrompt [ i ] . replace ( "%s" , name ) ) ; } \n', 0.39858776606906665)

('private static MusicItem [ ] pickRandomSongs ( MusicItem [ ] songs , double percentOfAllSongs ) { if ( percentOfAllSongs < 0.0 || percentOfAllSongs > 1.0 ) { throw new IllegalArgumentException ( "Value-for-\'percentOfAllSongs\'-argument-should-be-between-0-and-1." ) ; } Random rand = new Random ( ) ; int sampleSize = ( int ) Math . round ( percentOfAllSongs * songs . length ) ; Map < Integer , MusicItem > pickedItems = new HashMap < Integer , MusicItem > ( ) ; while ( pickedItems . size ( ) < sampleSize ) { int songId = rand . nextInt ( songs . length ) ; MusicItem song = songs [ songId ] ; if ( ! pickedItems . containsKey ( song . getId ( ) ) ) { pickedItems . put ( song . getId ( ) , song ) ; } } return pickedItems . values ( ) . toArray ( new MusicItem [ pickedItems . size ( ) ] ) ; } \n', 0.39796246170242094)

('public static int pickOneRandomly ( int first , int second ) { boolean pickFirst = random . nextBoolean ( ) ; if ( pickFirst ) { return first ; } else { return second ; } } \n', 0.393935880565887)

('@ Override public Piece pickNextPiece ( ) { boolean random = ( adversary . getValue ( ) < gen . nextInt ( adversary . getMaximum ( ) ) ) ; if ( random ) { return super . pickNextPiece ( ) ; } else { double max = - 1 ; Piece worst = new Piece ( "" ) ; for ( Piece p : pieces ) { Brain . Move m = brain . bestMove ( board , p , HEIGHT , null ) ; double value = ( m != null ) ? m . score : Integer . MAX_VALUE ; if ( value > max ) { max = value ; worst = p ; } } return worst ; } } \n', 0.3938289779554956)

('public static List < City > pickCities ( int numberOfDestinations ) { List < City > all = read . getCities ( ) ; List < City > chosen = new ArrayList < City > ( ) ; chosen . add ( all . get ( 0 ) ) ; List < Integer > numbers = new ArrayList < Integer > ( ) ; while ( numbers . size ( ) < numberOfDestinations ) { int index = random . nextInt ( all . size ( ) ) ; if ( ! numbers . contains ( index ) && index != 0 ) { numbers . add ( index ) ; chosen . add ( all . get ( index ) ) ; } } return chosen ; } \n', 0.39280226897920734)

('private < T > T pickRandomlyFromList ( final List < T > list ) { return list . get ( random . nextInt ( list . size ( ) ) ) ; } \n', 0.3927845453226804)

('public Card selectCard ( int remainingCards ) { Random pick = new Random ( ) ; Integer number = pick . nextInt ( remainingCards ) ; Card pickedCard = currentDeck . get ( number ) ; currentDeck . remove ( pickedCard ) ; return pickedCard ; } \n', 0.39207992121765056)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 11 #################################
('@ Override void deserialize ( final Map < String , Object > source ) { super . deserialize ( source ) ; if ( source . containsKey ( JsonSchema . KEY_DATE_PATTERN ) ) { this . datePattern = ( String ) source . get ( JsonSchema . KEY_DATE_PATTERN ) ; } } \n', 0.4187842304303746)

('@ Override public Entry deserialize ( @ Nullable byte [ ] bytes ) { if ( bytes == null ) { return null ; } return GSON . get ( ) . fromJson ( new String ( bytes ) , Entry . class ) ; } \n', 0.4106041816504033)

('@ SuppressWarnings ( "unchecked" ) @ Override public TS deserialize ( final byte [ ] data ) throws SerializationException { ArrayList < TS > info = null ; if ( data != null ) { final String jsonData = new String ( data ) ; try { info = objectMapper . readValue ( jsonData , ArrayList . class ) ; } catch ( final Exception e ) { throw new SerializationException ( "Error-occured-while-deserializing-data-" + jsonData , e ) ; } } return ( info != null && info . size ( ) > 0 ) ? info . get ( 0 ) : null ; } \n', 0.40244103573914625)

('@ Override public Object deserialize ( byte [ ] b ) { try { return Utils . from_json ( new String ( b , "UTF-8" ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } \n', 0.4002365232842615)

('@ Override public List < Object > deserialize ( byte [ ] bytes ) { final String chars ; try { chars = new String ( bytes , encoding ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( e ) ; } final Object json ; try { json = JSONValue . parseWithException ( chars ) ; } catch ( ParseException e ) { throw new IllegalArgumentException ( e ) ; } return Collections . singletonList ( json ) ; } \n', 0.39898744797386027)

('public Character deserialize ( ObjectReader reader , Context ctx ) { String str = reader . valueAsString ( ) ; if ( str . length ( ) > 1 ) throw new JsonBindingException ( "Could-not-convert-a-string-with-length-greater-than-1-to-a-single-char." ) ; return str . charAt ( 0 ) ; } \n', 0.39716763581588516)

('public static < T > T deserialize ( byte [ ] input , Class < T > classType ) throws JsonParseException , JsonMappingException , IOException { return mapper . readValue ( input , classType ) ; }\n', 0.3966552197758171)

('private MarshalledValue deserializeObj ( String key ) throws Exception { if ( externalizer == null ) throw new IllegalStateException ( "Cannot-deserialize-object:-undefined-marshaller" ) ; byte [ ] data = Base64 . decode ( key ) ; ObjectInputStream ois = new ObjectInputStream ( new ByteArrayInputStream ( data ) ) ; MarshalledValue mv = externalizer . readObject ( ois ) ; ois . close ( ) ; return mv ; } \n', 0.39420136945776546)

('public T deserialize ( byte [ ] array ) throws Exception { String str = new String ( array , _charset . toString ( ) ) ; return _marshaller . unmarshall ( ( Json . Object ) Json . read ( new StringReader ( str ) ) ) ; } \n', 0.39277812821663327)

('@ Override public byte [ ] deserialize ( JsonElement json , Type typeOfT , JsonDeserializationContext context ) throws JsonParseException { if ( typeOfT . equals ( byte [ ] . class ) ) throw new JsonParseException ( "Not-a-byte[]:-" + typeOfT ) ; String input = json . getAsString ( ) ; baos . reset ( ) ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { char chr = input . charAt ( i ) ; if ( chr != \'%\' ) { baos . write ( chr ) ; } else { baos . write ( ( hexValue ( input . charAt ( ++ i ) ) << 4 ) | hexValue ( input . charAt ( ++ i ) ) ) ; } } return baos . toByteArray ( ) ; } \n', 0.39091846034350836)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 12 #################################
('public static void copyToClipboard ( final String string ) { Preconditions . checkNotNull ( string , "Error:-String-argument-can-not-be-null" ) ; final Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipboard . setContents ( new StringSelection ( string ) , new ClipboardOwner ( ) { @ Override public void lostOwnership ( final Clipboard clipboard , final Transferable contents ) { } } ) ; } \n', 0.4804960994490237)

('public static void copyToClipboard ( final String text ) { final StringSelection selection = new StringSelection ( text == null ? "" : text ) ; final Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; if ( clipboard != null ) { clipboard . setContents ( selection , selection ) ; } else { BeamLogManager . getSystemLogger ( ) . severe ( "failed-to-obtain-clipboard-instance" ) ; } } \n', 0.47947588439425187)

('public static void copyToClipboard ( final String text ) { StringSelection selection = new StringSelection ( text == null ? "" : text ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; if ( clipboard != null ) { clipboard . setContents ( selection , selection ) ; } else { BeamLogManager . getSystemLogger ( ) . severe ( "failed-to-obtain-clipboard-instance" ) ; } } \n', 0.47947588439425187)

('public static void copyToClipboard ( String s ) { Display display = Display . findDisplay ( Thread . currentThread ( ) ) ; Clipboard clipboard = new Clipboard ( display ) ; TextTransfer textTransfer = TextTransfer . getInstance ( ) ; clipboard . setContents ( new Object [ ] { s } , new Transfer [ ] { textTransfer } ) ; clipboard . dispose ( ) ; } \n', 0.4792785853476912)

('public static void copyToClipboard ( String str ) { Toolkit kit = Toolkit . getDefaultToolkit ( ) ; Clipboard clipboard = kit . getSystemClipboard ( ) ; StringSelection ss = new StringSelection ( str ) ; clipboard . setContents ( ss , ss ) ; } \n', 0.4761093645389748)

('static void copyToClipboard ( String textToCopy ) { StringSelection stringSelection = new StringSelection ( textToCopy ) ; Clipboard clpbrd = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clpbrd . setContents ( stringSelection , null ) ; } \n', 0.4730787630694193)

('public void copyToClipboard ( String sText ) { Clipboard objClipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; StringSelection objStringSelection = new StringSelection ( sText ) ; objClipboard . setContents ( objStringSelection , this ) ; } \n', 0.4723259640021406)

('public static void copyToClipboard ( String string ) { StringSelection stringSelection = new StringSelection ( string ) ; Clipboard clpbrd = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clpbrd . setContents ( stringSelection , null ) ; } \n', 0.4720089838555941)

('public static void copyToClipboard ( String s ) { StringSelection stringSelection = new StringSelection ( s ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipboard . setContents ( stringSelection , null ) ; } \n', 0.4712765746497808)

('protected void copyToClipboard ( ) { if ( _clipboard != null ) { _clipboard . dispose ( ) ; } String stackTrace = stackTraceToString ( _status . getException ( ) ) ; _clipboard = new Clipboard ( _list . getDisplay ( ) ) ; _clipboard . setContents ( new Object [ ] { stackTrace } , new Transfer [ ] { TextTransfer . getInstance ( ) } ) ; } \n', 0.469547078319246)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 13 #################################
('public static RealMatrix divideMatrixByNumber ( RealMatrix matrix , double divisionNumber ) { for ( int i = 0 ; i < matrix . getRowDimension ( ) ; i ++ ) { for ( int j = 0 ; j < matrix . getColumnDimension ( ) ; j ++ ) { matrix . multiplyEntry ( i , j , 1 / divisionNumber ) ; } } return matrix ; } \n', 0.3762124377248103)

('public static < T extends FieldElement < T >> FieldMatrix < T > asFieldMatrix ( Array < T > array ) { Check . argument ( array . isMatrix ( ) , CAN_ONLY_VIEW_2D_ARRAYS ) ; return new AbstractFieldMatrix < T > ( ) { @ Override public FieldMatrix < T > createMatrix ( int rowDimension , int columnDimension ) throws NotStrictlyPositiveException { return asFieldMatrix ( array . newEmptyArray ( rowDimension , columnDimension ) ) ; } @ Override public FieldMatrix < T > copy ( ) { return asFieldMatrix ( array . copy ( ) ) ; } @ Override public T getEntry ( int row , int column ) throws OutOfRangeException { return array . get ( row , column ) ; } @ Override public void setEntry ( int row , int column , T value ) throws OutOfRangeException { array . set ( row , column , value ) ; } @ Override public void addToEntry ( int row , int column , T increment ) throws OutOfRangeException { array . set ( row , column , array . get ( row , column ) . add ( increment ) ) ; } @ Override public void multiplyEntry ( int row , int column , T factor ) throws OutOfRangeException { array . set ( row , column , array . get ( row , column ) . multiply ( factor ) ) ; } @ Override public int getRowDimension ( ) { return array . rows ( ) ; } @ Override public int getColumnDimension ( ) { return array . columns ( ) ; } } ; } \n', 0.3660563073558313)

('public static RealMatrix toRotationMatrix ( List < Double > angles ) { double dimDouble = ( 1.0 + sqrt ( 1.0 + 8.0 * angles . size ( ) ) ) / 2.0 ; int dim = ( int ) Math . floor ( dimDouble ) ; RealMatrix left , right ; left = MatrixTools . identity ( dim ) ; right = new Array2DRowRealMatrix ( dim , dim ) ; int k = 0 ; for ( int j = dim - 2 ; j >= 0 ; j -- ) for ( int i = j + 1 ; i < dim ; i ++ ) { right = elementary ( dim , i , j , angles . get ( k ) ) ; left = left . multiply ( right ) ; k ++ ; } return left ; } \n', 0.3630953094491747)

('public static int [ ] [ ] matrixMultiplyRecursive ( int [ ] [ ] a , int [ ] [ ] b ) { if ( a == null || b == null ) { return null ; } final int n = a . length ; final int k = a [ 0 ] . length ; if ( k != b . length ) { throw new IllegalArgumentException ( String . format ( "Can-not-multiply-%d-x-%d-with-%d-x-%d" , n , a [ 0 ] . length , b . length , b [ 0 ] . length ) ) ; } final Pair < Integer , Integer > rangeXa = new Pair < Integer , Integer > ( 0 , a . length ) ; final Pair < Integer , Integer > rangeYa = new Pair < Integer , Integer > ( 0 , a [ 0 ] . length ) ; final Pair < Integer , Integer > rangeXb = new Pair < Integer , Integer > ( 0 , b . length ) ; final Pair < Integer , Integer > rangeYb = new Pair < Integer , Integer > ( 0 , b [ 0 ] . length ) ; return matrixMultiplyRec ( a , rangeXa , rangeYa , b , rangeXb , rangeYb , "|" ) ; } \n', 0.3506929479451903)

('public final static RealMatrix IAU2006MatrixEpoch12Epoch2 ( float epoch1 , float epoch2 ) { RealMatrix result ; if ( epoch1 == epoch2 ) { result = MatrixUtils . createRealIdentityMatrix ( 3 ) ; } else if ( epoch1 == 2000.0 ) { double [ ] precessionAngles = IAU2006PrecAngles ( epoch2 ) ; result = precessionMatrix ( precessionAngles [ 0 ] , precessionAngles [ 1 ] , precessionAngles [ 2 ] ) ; } else { double [ ] precessionAngles = IAU2006PrecAngles ( epoch1 ) ; RealMatrix m1 = precessionMatrix ( precessionAngles [ 0 ] , precessionAngles [ 1 ] , precessionAngles [ 2 ] ) ; m1 = m1 . transpose ( ) ; precessionAngles = IAU2006PrecAngles ( epoch2 ) ; RealMatrix m2 = precessionMatrix ( precessionAngles [ 0 ] , precessionAngles [ 1 ] , precessionAngles [ 2 ] ) ; result = m1 . multiply ( m2 ) ; } return result ; } \n', 0.3448453979235203)

('public ComplexMatrix getLocalPropagationMatrix ( int index , double energy ) { MatterInterval inl = intervals . get ( index ) ; MatterInterval next = intervals . get ( index + 1 ) ; Complex k_ratio ; k_ratio = Complex . sqrt ( ( energy - next . getY ( ) ) / ( energy - inl . getY ( ) ) * inl . getMass ( ) / next . getMass ( ) ) ; Complex kcp = k_ratio . add ( 1 ) ; Complex kcm = k_ratio . reverseSign ( ) . add ( 1 ) ; Complex kd = inl . getWaveNumber ( energy ) . times ( inl . getWidth ( ) ) ; if ( VERBOSE ) { System . out . println ( "k_ratio-=-" + k_ratio ) ; System . out . println ( "kcp-=-" + kcp ) ; System . out . println ( "kcm-=-" + kcm ) ; System . out . println ( "kd-=-" + kd ) ; } Complex i = new Complex ( 0 , 1 ) ; Complex ni = i . reverseSign ( ) ; try { return new ComplexMatrix ( new Complex [ ] [ ] { { kcp . times ( Complex . exp ( ni . times ( kd ) ) ) , kcm . times ( Complex . exp ( ni . times ( kd ) ) ) } , { kcm . times ( Complex . exp ( i . times ( kd ) ) ) , kcp . times ( Complex . exp ( i . times ( kd ) ) ) } } ) . multiplyEach ( 0.5 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } } \n', 0.34389625350251407)

('public Vector multiplyMatrixWithVector ( Vector v ) { float x = v . getX ( ) ; float y = v . getY ( ) ; float z = v . getZ ( ) ; float h = v . getH ( ) ; float newx , newy , newz , newh ; newx = x * matrix [ 0 ] [ 0 ] + y * matrix [ 0 ] [ 1 ] + z * matrix [ 0 ] [ 2 ] + h * matrix [ 0 ] [ 3 ] ; newy = x * matrix [ 1 ] [ 0 ] + y * matrix [ 1 ] [ 1 ] + z * matrix [ 1 ] [ 2 ] + h * matrix [ 1 ] [ 3 ] ; newz = x * matrix [ 2 ] [ 0 ] + y * matrix [ 2 ] [ 1 ] + z * matrix [ 2 ] [ 2 ] + h * matrix [ 2 ] [ 3 ] ; newh = x * matrix [ 3 ] [ 0 ] + y * matrix [ 3 ] [ 1 ] + z * matrix [ 3 ] [ 2 ] + h * matrix [ 3 ] [ 3 ] ; Vector out = new Vector ( newx , newy , newz ) ; out . setH ( newh ) ; return out ; } \n', 0.3423522466994694)

('public static byte [ ] [ ] generateConstraintMatrix ( int K , int T ) { int Ki = SystematicIndices . getKIndex ( K ) ; int S = SystematicIndices . S ( Ki ) ; int H = SystematicIndices . H ( Ki ) ; int W = SystematicIndices . W ( Ki ) ; int L = K + S + H ; int P = L - W ; int U = P - H ; int B = W - S ; byte [ ] [ ] constraint_matrix = new byte [ L ] [ L ] ; initializeG_LPDC2 ( constraint_matrix , S , P , W ) ; initializeG_LPDC1 ( constraint_matrix , B , S ) ; initializeIs ( constraint_matrix , S , B ) ; initializeIh ( constraint_matrix , W , U , H , S ) ; byte [ ] [ ] MT = generateMT ( H , K , S ) ; byte [ ] [ ] GAMMA = generateGAMMA ( K , S ) ; byte [ ] [ ] G_HDPC = Utilities . multiplyMatrices ( MT , GAMMA ) ; for ( int row = S ; row < S + H ; row ++ ) for ( int col = 0 ; col < W + U ; col ++ ) constraint_matrix [ row ] [ col ] = G_HDPC [ row - S ] [ col ] ; initializeG_ENC ( constraint_matrix , S , H , L , K ) ; return constraint_matrix ; } \n', 0.34131142957862726)

('public RealMatrix getCorrelationMatrix ( ) { final RealMatrix corMatrix = new Array2DRowRealMatrix ( covMatrix . getData ( ) , true ) ; double [ ] histVol = getHistVol ( ) ; for ( int i = 0 ; i < corMatrix . getRowDimension ( ) ; i ++ ) for ( int j = 0 ; j < corMatrix . getColumnDimension ( ) ; j ++ ) corMatrix . multiplyEntry ( i , j , histVol [ i ] * histVol [ j ] ) ; return corMatrix ; } \n', 0.33917536993544917)

('public GenMatrix < C > linearCombination ( C t , GenMatrix < C > b ) { ArrayList < ArrayList < C >> om = b . matrix ; ArrayList < ArrayList < C >> m = new ArrayList < ArrayList < C >> ( ring . rows ) ; int i = 0 ; for ( ArrayList < C > val : matrix ) { ArrayList < C > ov = om . get ( i ++ ) ; ArrayList < C > v = new ArrayList < C > ( ring . cols ) ; int j = 0 ; for ( C c : val ) { C c2 = t . multiply ( ov . get ( j ++ ) ) ; C e = c . sum ( c2 ) ; v . add ( e ) ; } m . add ( v ) ; } return new GenMatrix < C > ( ring , m ) ; } \n', 0.3372131964490779)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 14 #################################
('private LinkedList < String > sortStringSet ( Set < String > input ) { LinkedList < String > sortedItems = new LinkedList < String > ( ) ; for ( String e : input ) sortedItems . add ( e ) ; Collections . sort ( sortedItems ) ; return sortedItems ; } \n', 0.4610935977618856)

('public static ArrayList < String > SortStringList ( ArrayList < String > list ) { ArrayList < NumericString > numericStringList = new ArrayList < NumericString > ( ) ; for ( String item : list ) numericStringList . add ( new NumericString ( item ) ) ; Collections . sort ( numericStringList ) ; ArrayList < String > sortedList = new ArrayList < String > ( ) ; for ( NumericString item : numericStringList ) sortedList . add ( item . toString ( ) ) ; return sortedList ; } \n', 0.44667101017015226)

('public static boolean verifyStringListSortByAlphabetically ( List < String > oriList ) { List < String > afterSorting = new ArrayList < String > ( ) ; boolean result = true ; afterSorting . addAll ( oriList ) ; Collections . sort ( afterSorting ) ; if ( ! oriList . equals ( afterSorting ) ) { result = false ; AutomationLogger . getInstance ( ) . error ( "The-string-list-does-NOT-sort-by-alphabetically-ascending!" ) ; } else { AutomationLogger . getInstance ( ) . info ( "The-string-list-sorts-by-alphabetically-ascending-correctly!" ) ; } return result ; } \n', 0.4416763500675002)

('private void sortStringList ( List < String > strings ) { Collections . sort ( strings , String . CASE_INSENSITIVE_ORDER ) ; } \n', 0.44136169867191)

('static Vector sortStrings ( Vector originalList ) { Vector sortedList = new Vector ( originalList . size ( ) ) ; Enumeration e = originalList . elements ( ) ; while ( e . hasMoreElements ( ) ) { String oldEntry = ( String ) e . nextElement ( ) ; boolean done = false ; int insertionPosition = sortedList . size ( ) ; Enumeration sorted = sortedList . elements ( ) ; for ( int i = 0 ; ! done && sorted . hasMoreElements ( ) ; ++ i ) { String sortedEntry = ( String ) sorted . nextElement ( ) ; if ( ( oldEntry . compareTo ( sortedEntry ) ) < 0 ) { insertionPosition = i ; done = true ; } } sortedList . insertElementAt ( oldEntry , insertionPosition ) ; } return sortedList ; } \n', 0.4413366106858135)

('public List < String > sortStringList ( List < String > stringList ) { Collections . sort ( stringList , new Comparator < String > ( ) { @ Override public int compare ( String a , String b ) { return b . compareTo ( a ) ; } } ) ; return stringList ; } \n', 0.43820394834708415)

('private String sortCommaSeparatedList ( String selectedText , boolean shiftUp ) { String [ ] items = selectedText . split ( ",(|s)*" ) ; if ( ShifterPreferences . getSortingMode ( ) . equals ( ShifterPreferences . SORTING_MODE_CASE_INSENSITIVE ) ) { Arrays . sort ( items , String . CASE_INSENSITIVE_ORDER ) ; } else { Arrays . sort ( items ) ; } if ( ! shiftUp ) Collections . reverse ( Arrays . asList ( items ) ) ; return UtilsArray . implode ( items , ",-" ) ; } \n', 0.43445679460900566)

('private void checkStringSortCorrect ( List < RowMetaAndData > list , boolean caseSensitive , boolean asc ) throws KettleValueException { List < String > actual = new ArrayList < String > ( ) ; List < String > expected = new ArrayList < String > ( ) ; String caseSen = caseSensitive ? "case-sensitive" : "case-unsensitive" ; for ( RowMetaAndData row : list ) { String value = row . getString ( STR , null ) ; if ( ! caseSensitive ) { expected . add ( value . toLowerCase ( ) ) ; actual . add ( value . toLowerCase ( ) ) ; } else { expected . add ( value ) ; actual . add ( value ) ; } } if ( asc ) { Collections . sort ( expected ) ; } else { Collections . sort ( expected ) ; Collections . reverse ( expected ) ; } Assert . assertEquals ( "Data-is-sorted:-" + caseSen , expected , actual ) ; } \n', 0.43284447819230065)

('public static void sortStrings ( List < String > l , boolean ascending , boolean ignoreCase ) { String s [ ] = new String [ l . size ( ) ] ; l . toArray ( s ) ; Sort . objects ( s , null , null , 0 , l . size ( ) , ignoreCase ? StringCompareIgnoreCase . self : StringCompare . self , ascending ? Sort . SortAscending : Sort . SortDescending ) ; l . clear ( ) ; l . addAll ( Arrays . asList ( s ) ) ; } \n', 0.43210740549053994)

('public static void sortStrings ( Vector values , int left , int right , Swapper swapper ) { int oleft = left ; int oright = right ; String mid = ( String ) values . elementAt ( ( left + right ) / 2 ) ; do { while ( ( ( String ) ( values . elementAt ( left ) ) ) . compareTo ( mid ) < 0 ) left ++ ; while ( mid . compareTo ( ( String ) ( values . elementAt ( right ) ) ) < 0 ) right -- ; if ( left <= right ) { swapper . swap ( values , left , right ) ; left ++ ; right -- ; } } while ( left <= right ) ; if ( oleft < right ) sortStrings ( values , oleft , right , swapper ) ; if ( left < oright ) sortStrings ( values , left , oright , swapper ) ; } \n', 0.43210132381437816)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 15 #################################
("public static String convertDecimalStringToHexString ( String in ) { int integer = Integer . parseInt ( in ) ; String hexString = Integer . toHexString ( integer ) ; if ( hexString . length ( ) == 1 ) { hexString = '0' + hexString ; } return hexString ; } \n", 0.4253949201254642)

('public static String longHexStringToBinary ( String hex ) { StringBuffer output = new StringBuffer ( ) ; for ( int i = 0 ; i < hex . length ( ) ; i ++ ) { String h = hex . substring ( i , i + 1 ) ; output . append ( hexToBinary ( h , 4 ) ) ; } return output . toString ( ) ; } \n', 0.41971102892724366)

("public static String convertDecimalStringToHexString ( String in ) { int integer = Integer . parseInt ( in ) ; String hexString = Integer . toHexString ( integer ) ; if ( hexString . length ( ) == 1 ) { hexString = '0' + hexString ; } return hexString ; } \n", 0.4070734778112304)

('public static String convertRGBDecToHex ( String decimal ) { String returnValue = null ; Formatter formatter = null ; formatter = new Formatter ( ) ; returnValue = "#" + formatter . format ( "%02x%02x%02x" , Integer . parseInt ( decimal . substring ( 0 , 3 ) ) , Integer . parseInt ( decimal . substring ( 3 , 6 ) ) , Integer . parseInt ( decimal . substring ( 6 , 9 ) ) ) . toString ( ) ; return returnValue ; } \n', 0.4037221218518432)

("public static long hexStringToLong ( String s ) throws NumberFormatException { if ( s == null || s . length ( ) < 2 ) { throw new NumberFormatException ( s ) ; } char firstChar = s . charAt ( 0 ) ; if ( firstChar >= '0' && firstChar <= '7' ) { return Long . parseLong ( s , 16 ) ; } else { java . math . BigInteger big = new java . math . BigInteger ( s , 16 ) ; return big . longValue ( ) ; } } \n", 0.39713434465990016)

("public String decimalToHex ( String color ) { try { String hex = Integer . toHexString ( Integer . parseInt ( color ) ) ; char [ ] padding = new char [ Math . max ( 0 , 6 - hex . length ( ) ) ] ; for ( int i = 0 ; i < padding . length ; i ++ ) { padding [ i ] = '0' ; } hex = String . valueOf ( padding ) + hex ; return '#' + hex . substring ( 4 ) + hex . substring ( 2 , 4 ) + hex . substring ( 0 , 2 ) ; } catch ( NumberFormatException e ) { return null ; } } \n", 0.3953049110818402)

("public static String longBinaryStringToHex ( String input ) { StringBuffer output = new StringBuffer ( ) ; for ( int i = 0 ; i < input . length ( ) ; i += 4 ) { String nibble = input . substring ( i , i + 4 ) ; int n = 0 ; if ( nibble . charAt ( 3 ) == '1' ) n += 1 ; if ( nibble . charAt ( 2 ) == '1' ) n += 2 ; if ( nibble . charAt ( 1 ) == '1' ) n += 4 ; if ( nibble . charAt ( 0 ) == '1' ) n += 8 ; output . append ( Integer . toHexString ( n ) ) ; } return output . toString ( ) ; } \n", 0.39355487318455507)

('public static String doubleToHexString ( double val ) { long reversed = Long . reverseBytes ( Double . doubleToLongBits ( val ) ) ; String res = Long . toHexString ( reversed ) ; res = "0000000000000000" . substring ( res . length ( ) ) + res ; return res ; } \n', 0.39177754522931646)

('public static long hexStringToLong ( String s ) throws NumberFormatException { boolean isNeg ; String toUse = s ; if ( s . startsWith ( Utility . hexStart ) ) toUse = s . substring ( Utility . hexStart . length ( ) ) ; String lastString = toUse . substring ( toUse . length ( ) - 1 ) ; if ( toUse . substring ( 0 , 1 ) . equals ( "-" ) ) { toUse = "-0" + toUse . substring ( 1 , toUse . length ( ) - 1 ) ; isNeg = true ; } else { toUse = "0" + toUse . substring ( 0 , toUse . length ( ) - 1 ) ; isNeg = false ; } Long i = Long . valueOf ( toUse , 16 ) ; long val = i . longValue ( ) ; val = val << 4 ; if ( isNeg ) { val -= Long . valueOf ( lastString , 16 ) . longValue ( ) ; } else { val += Long . valueOf ( lastString , 16 ) . longValue ( ) ; } return val ; } \n', 0.39075071833812264)

('public static String toHexString ( double d ) { if ( isNaN ( d ) ) return "NaN" ; if ( isInfinite ( d ) ) return d < 0 ? "-Infinity" : "Infinity" ; long bits = doubleToLongBits ( d ) ; CPStringBuilder result = new CPStringBuilder ( ) ; if ( bits < 0 ) result . append ( \'-\' ) ; result . append ( "0x" ) ; final int mantissaBits = 52 ; final int exponentBits = 11 ; long mantMask = ( 1L << mantissaBits ) - 1 ; long mantissa = bits & mantMask ; long expMask = ( 1L << exponentBits ) - 1 ; long exponent = ( bits >>> mantissaBits ) & expMask ; result . append ( exponent == 0 ? \'0\' : \'1\' ) ; result . append ( \'.\' ) ; result . append ( Long . toHexString ( mantissa ) ) ; if ( exponent == 0 && mantissa != 0 ) { int offset = 4 + ( ( bits < 0 ) ? 1 : 0 ) ; int desiredLength = offset + ( mantissaBits + 3 ) / 4 ; while ( result . length ( ) < desiredLength ) result . insert ( offset , \'0\' ) ; } result . append ( \'p\' ) ; if ( exponent == 0 && mantissa == 0 ) { } else { boolean denormal = exponent == 0 ; exponent -= ( 1 << ( exponentBits - 1 ) ) - 1 ; if ( denormal ) ++ exponent ; } result . append ( Long . toString ( exponent ) ) ; return result . toString ( ) ; } \n', 0.3904328016366099)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 16 #################################
('private static void convertDateString ( String str ) { try { Date date = Utils . dateFromString ( str ) ; display ( "Date-to-millis:-" + date . getTime ( ) ) ; } catch ( Exception e ) { } } \n', 0.4262708033791331)

('public static String convertLongToDateString ( long toConvert ) { Date d = new Date ( toConvert ) ; return d . toString ( ) ; } \n', 0.41886483422176785)

('public static String convertToDate ( String dateTime , String formatForDisplay ) { String [ ] parseDateTime = dateTime . split ( "T" ) ; String finalDateTime = parseDateTime [ 0 ] + "-" + parseDateTime [ 1 ] . replace ( "Z" , "" ) ; SimpleDateFormat convertStringToDate = new SimpleDateFormat ( "yyyy-MM-dd-HH:mm:ss" ) ; SimpleDateFormat forDisplaying = new SimpleDateFormat ( formatForDisplay ) ; try { Date theDate = convertStringToDate . parse ( finalDateTime ) ; String result = forDisplaying . format ( theDate ) ; return result ; } catch ( ParseException e ) { e . printStackTrace ( ) ; return null ; } } \n', 0.41499555737945193)

('public static String convertDateToString ( Date date , String format ) { if ( date == null || format == null ) { throw new IllegalArgumentException ( "Date-and-Format-values-should-not-be-null." ) ; } try { SimpleDateFormat dateFormat = new SimpleDateFormat ( format ) ; String strDate = dateFormat . format ( date ) ; logger . info ( "Date-:-" + date + "-converted-into-string-value-:" + strDate ) ; return strDate ; } catch ( Exception e ) { throw new PageException ( "converting-Date-to-String-is-having-problem-:-" + e . getMessage ( ) ) ; } } \n', 0.41451826965417654)

('protected Date convertStringToDate ( String s ) { try { return dateFormat . parse ( s ) ; } catch ( ParseException e ) { throw new DataImportHandlerException ( SEVERE , "Value-for-" + LAST_INDEX_KEY + "-is-invalid-for-date-format-" + dateFormat . toLocalizedPattern ( ) + "-:-" + s ) ; } } \n', 0.4143634507708913)

('protected Date convertStringToDate ( String value ) throws ParsingException { try { return format . parse ( value ) ; } catch ( ParseException e ) { throw new ParsingException ( "Value-<" + value + ">-could-not-be-parsed-to-date-using-format-<" + format + ">." ) ; } } \n', 0.41383154068754224)

('public static Date convertStringToDate ( String dateString , String format ) throws ParseException { if ( dateString == null || dateString . isEmpty ( ) ) { throw new IllegalArgumentException ( "Date-String-Missing!" ) ; } if ( format == null || format . isEmpty ( ) ) { throw new IllegalArgumentException ( "Date-Format-String-Missing!" ) ; } SimpleDateFormat dateFormat = new SimpleDateFormat ( format ) ; return ( dateFormat . parse ( dateString ) ) ; } \n', 0.41069942673787363)

('public static Date convertBirthdayStringToDate ( String userDateString ) { DateTimeFormatter dateTimeConvert = DateTimeFormat . forPattern ( birthdayFormat ) ; try { DateTime dateTimeParser = dateTimeConvert . parseDateTime ( userDateString ) ; return dateTimeParser . toDate ( ) ; } catch ( IllegalArgumentException e ) { return null ; } } \n', 0.4105406171592317)

('public static Converter < Date > toDate ( ) { return new Converter < Date > ( ) { public Date convert ( @ Nonnull String value ) { try { return DateFormat . getInstance ( ) . parse ( value ) ; } catch ( ParseException e ) { throw new ConversionException ( String . format ( "Unable-to-parse-\'%s\'-into-java.util.Date" , value ) , e ) ; } } } ; } \n', 0.410076412538404)

('private String convertDateStringToAnotherDateString ( String originalDateString , String incomingDateFormat , String outgoingDateFormat ) throws Exception { String newlyFormattedDateString = new String ( ) ; SimpleDateFormat incomingDateFormatter = new SimpleDateFormat ( incomingDateFormat ) ; SimpleDateFormat outgoingDateFormatter = new SimpleDateFormat ( outgoingDateFormat ) ; try { Date tempDateObject = incomingDateFormatter . parse ( originalDateString ) ; newlyFormattedDateString = outgoingDateFormatter . format ( tempDateObject ) ; } catch ( ParseException e ) { this . log . error ( e . getMessage ( ) , e ) ; throw e ; } return newlyFormattedDateString ; } \n', 0.4086427927288609)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 17 #################################
('private void parseCommandLineArguments ( final String [ ] arguments ) { if ( arguments == null || arguments . length == 0 ) { return ; } for ( String argument : arguments ) { if ( argument . startsWith ( "-m=" ) ) { this . minimized = Boolean . parseBoolean ( argument . substring ( "-m=" . length ( ) ) ) ; } } } \n', 0.4514160906825629)

('public static String parseCommandLineInput ( String [ ] args ) throws Exception { if ( args . length == 1 ) { String pattern = "[a-zA-z]+" ; String cityName = args [ 0 ] ; if ( cityName . matches ( pattern ) ) { return cityName ; } else { throw new InvalidParameterNameException ( "Please-pass-a-valid-city-name-as-a-parameter.-Aborting." ) ; } } else { throw new TooManyParametersException ( "Input-parameters-not-correctly-specified.-Please-only-specify-one-parameter.-Aborting." ) ; } } \n', 0.4454745052886194)

('private static void parseCommandLine ( final String [ ] args ) throws IOException { if ( args . length == 0 ) { Configuration . initializeFromClasspathConfig ( ) ; } else if ( args . length == 1 ) { Configuration . initializeFromConfigFile ( new File ( args [ 0 ] ) ) ; } else { System . err . println ( "usage:-Main-[config.properties]" ) ; System . exit ( 1 ) ; } } \n', 0.44481066389821966)

('public static List < String > parseCommandLine ( String commandLineString , VariableSpace variableSpace , boolean ignoreSqoopCommand ) throws IOException { List < String > args = new ArrayList < String > ( ) ; StringReader reader = new StringReader ( commandLineString ) ; try { StreamTokenizer tokenizer = new StreamTokenizer ( reader ) ; tokenizer . ordinaryChar ( \'-\' ) ; tokenizer . ordinaryChar ( \'.\' ) ; tokenizer . ordinaryChars ( \'0\' , \'9\' ) ; tokenizer . wordChars ( \'\x00\' , \'?\' ) ; tokenizer . whitespaceChars ( 0 , \'-\' ) ; tokenizer . quoteChar ( \'"\' ) ; tokenizer . quoteChar ( \'|\'\' ) ; boolean skipToken = false ; while ( tokenizer . nextToken ( ) != StreamTokenizer . TT_EOF ) { if ( tokenizer . sval != null ) { String s = tokenizer . sval ; if ( variableSpace != null ) { s = variableSpace . environmentSubstitute ( s ) ; } if ( ignoreSqoopCommand && args . isEmpty ( ) ) { if ( "sqoop" . equals ( s ) ) { skipToken = true ; continue ; } else if ( skipToken ) { ignoreSqoopCommand = false ; skipToken = false ; continue ; } } if ( s . startsWith ( ARG_D ) ) { handleCustomOption ( args , s , tokenizer , variableSpace ) ; continue ; } args . add ( escapeEscapeSequences ( s ) ) ; } } } finally { reader . close ( ) ; } return args ; } \n', 0.43703869449421345)

('@ SuppressWarnings ( "unchecked" ) public static Map < String , String > parseCommandLineArguments ( String [ ] args ) { return ( Map ) parseCommandLineArguments ( args , false ) ; }\n', 0.43691366114696084)

('public void parseCommandLineArguments ( String [ ] args ) { if ( args != null ) { for ( int i = 0 ; i < args . length ; i ++ ) { String argument = args [ i ] ; if ( argument . startsWith ( "-lang=" ) ) { int pos = argument . indexOf ( "=" ) ; JogreGlobals . setLocale ( argument . substring ( pos + 1 ) ) ; } } } } \n', 0.421918919218626)

('public List < String > parseCommandLine ( String commandLineString ) throws IOException { List < String > args = new ArrayList < String > ( ) ; StringReader reader = new StringReader ( commandLineString ) ; try { StreamTokenizer tokenizer = new StreamTokenizer ( reader ) ; tokenizer . ordinaryChar ( \'-\' ) ; tokenizer . ordinaryChar ( \'.\' ) ; tokenizer . ordinaryChars ( \'0\' , \'9\' ) ; tokenizer . wordChars ( \'\x00\' , \'?\' ) ; tokenizer . whitespaceChars ( 0 , \'-\' ) ; tokenizer . quoteChar ( \'"\' ) ; tokenizer . quoteChar ( \'|\'\' ) ; while ( tokenizer . nextToken ( ) != StreamTokenizer . TT_EOF ) { if ( tokenizer . sval != null ) { String s = tokenizer . sval ; s = environmentSubstitute ( s ) ; args . add ( s ) ; } } } finally { reader . close ( ) ; } return args ; } \n', 0.42157119119957626)

('public Command parseCommand ( ) { String userCommand ; try { userCommand = scanner . nextLine ( ) ; } catch ( NoSuchElementException e ) { return null ; } String [ ] splittedCommand = userCommand . split ( "-" ) ; CommandType type ; try { type = CommandType . valueOf ( splittedCommand [ 0 ] ) ; } catch ( IllegalArgumentException e ) { System . out . println ( "Command-unknown:-" + splittedCommand [ 0 ] ) ; type = CommandType . NOTHANDLED ; } final String [ ] arguments = Arrays . copyOfRange ( splittedCommand , 1 , splittedCommand . length ) ; Command command = new Command ( type , arguments ) ; System . out . println ( "Command-accepted:-" + command ) ; return command ; } \n', 0.4214411933027888)

('static public void parseCommandLineProperties ( Properties props , String [ ] cmdLineArgs ) { parseCommandLineProperties ( props , Arrays . asList ( cmdLineArgs ) ) ; } \n', 0.4214303520935423)

('private void parseCommand ( ) throws IOException { try { currentInputLine = in . readLine ( ) ; out . println ( currentInputLine ) ; out . flush ( ) ; if ( currentInputLine == null ) { executeExit ( ) ; return ; } currentInputLine = currentInputLine . trim ( ) ; parser . parse ( currentInputLine . split ( "|s+" ) ) ; command = parser . getRemainingArgs ( ) ; if ( command . length < 1 ) { error = true ; out . println ( "-1-sintax-error-" + USAGE ) ; out . flush ( ) ; } else { command [ 0 ] = command [ 0 ] . trim ( ) ; if ( command [ 0 ] . length ( ) == 0 ) { error = true ; } else { boolean recognizedCommand = false ; for ( String c : allCommands ) { if ( c . equals ( command [ 0 ] ) ) { recognizedCommand = true ; } } if ( ! recognizedCommand ) { out . println ( command [ 0 ] + ":-command-not-found" ) ; out . println ( USAGE ) ; error = true ; } } } } catch ( IllegalOptionValueException e ) { error = true ; out . println ( "-2-sintax-error-" + USAGE ) ; out . flush ( ) ; } catch ( UnknownOptionException e ) { error = true ; out . println ( "-3-sintax-error-" + USAGE ) ; out . flush ( ) ; } } \n', 0.41701090813374564)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 18 #################################
('public static < E extends Enum < E >> E getEnumFromName ( ResultSet resultSet , int columnIndex , Class < E > enumClass ) throws SQLException { String name = resultSet . getString ( columnIndex ) ; if ( name == null ) { return null ; } try { return Enum . valueOf ( enumClass , name ) ; } catch ( IllegalArgumentException e ) { throw new IllegalStateException ( "The-name-" + name + "-is-not-a-valid-name-for-the-enum-" + enumClass , e ) ; } } \n', 0.3852608269663103)

('private ElementNames getElementNameEnum ( String localName ) throws SAXException { ElementNames elementName ; try { elementName = Enum . valueOf ( ElementNames . class , localName ) ; return elementName ; } catch ( IllegalArgumentException iae ) { throw getException ( iae , "Unexpected-element-name-found.-This-is-a-bug-in-xml2csv-because-the-schema-validation-" + "should-have-caught-this-already" ) ; } } \n', 0.3735112042965889)

('private HashMap < String , Enum < ? >> fetchEnumNameToEnumValueHash ( ) { if ( this . enumerationClass == null ) { this . enumerationClass = fetchEnumClass ( ) ; } HashMap < String , Enum < ? >> ourHash = new HashMap < > ( ) ; for ( Object o : this . enumerationClass . getEnumConstants ( ) ) { Enum < ? > aValue = ( Enum < ? > ) o ; String aName = aValue . toString ( ) ; ourHash . put ( aName , aValue ) ; } return ourHash ; } \n', 0.3677317626182458)

('static public < E extends Enum < E >> E getEnum ( Class < E > enumType , String name ) throws NoSuchEnumException { if ( name == null || name . length ( ) == 0 ) { return null ; } try { try { return Enum . valueOf ( enumType , name ) ; } catch ( Exception e ) { return Enum . valueOf ( enumType , name . toUpperCase ( ) ) ; } } catch ( Exception e ) { throw new NoSuchEnumException ( text . get ( "enumName" , enumType , name ) ) ; } } \n', 0.3648127505852028)

('public String getEnumName ( String id ) throws BuildException { if ( id == null ) return EMPTY_STRING ; if ( enumList == null ) { if ( superClass != null ) { return superClass . getEnumName ( id ) ; } else { return EMPTY_STRING ; } } if ( getValueType ( ) != ENUMERATED ) { throw new BuildException ( ManagedMakeMessages . getResourceString ( "Option.error.bad_value_type" ) ) ; } String name = getEnumNameMap ( ) . get ( id ) ; if ( name == null ) { name = id ; } return name ; } \n', 0.36465063140037546)

('static LanguageCode getByEnumName ( String name ) { try { return Enum . valueOf ( LanguageCode . class , name ) ; } catch ( IllegalArgumentException e ) { return null ; } } \n', 0.35520198407971626)

('@ Nullable public static < T extends Enum < T >> T getEnum ( String constantName , Class < T > enumClass , @ Nullable T def ) { PreCon . notNull ( constantName ) ; PreCon . notNull ( enumClass ) ; if ( ! constantName . isEmpty ( ) ) { if ( constantName . startsWith ( "." ) ) return getAlternateEnum ( constantName , enumClass , def ) ; T value ; try { value = Enum . valueOf ( enumClass , constantName ) ; } catch ( Exception e ) { return def ; } return value ; } return def ; } \n', 0.35439486923938635)

('private static LocaleCode getByEnumName ( String name ) { try { return Enum . valueOf ( LocaleCode . class , name ) ; } catch ( IllegalArgumentException e ) { return null ; } } \n', 0.3520942657713191)

('public static final < T extends Enum < T >> T getEnumItem ( Class < T > enumType , String name , boolean fuzzy ) throws IllegalArgumentException { MandatoryArgumentChecker . check ( "enumType" , enumType , "name" , name ) ; if ( fuzzy ) { name = name . trim ( ) . replaceAll ( "|s+" , "_" ) . toUpperCase ( ) ; } try { return Enum . valueOf ( enumType , name ) ; } catch ( IllegalArgumentException cause ) { return null ; } } \n', 0.3506895124632185)

('static LanguageAlpha3Code getByEnumName ( String name ) { try { return Enum . valueOf ( LanguageAlpha3Code . class , name ) ; } catch ( IllegalArgumentException e ) { return null ; } } \n', 0.3482318162593994)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 19 #################################
('public static void exportReportToXls ( String reportSourcePath , String outputDirectory , String outputFileName , Map params , Connection connection ) throws IOException , JRException { String op = null ; if ( outputFileName == null ) { op = outputDirectory ; File userDir = new File ( outputDirectory . substring ( 0 , outputDirectory . lastIndexOf ( "|" ) ) ) ; if ( ! userDir . exists ( ) ) userDir . mkdirs ( ) ; } else { op = outputDirectory + outputFileName ; File userDir = new File ( outputDirectory ) ; if ( ! userDir . exists ( ) ) userDir . mkdirs ( ) ; } File sourceFile = Resources . getResourceAsFile ( reportSourcePath ) ; JasperReport jasperReport = ( JasperReport ) JRLoader . loadObject ( sourceFile ) ; JasperPrint jasperPrint = JasperFillManager . fillReport ( jasperReport , params , connection ) ; JRXlsExporter jrxlsexporter = new JRXlsExporter ( ) ; jrxlsexporter . setParameter ( JRExporterParameter . JASPER_PRINT , jasperPrint ) ; jrxlsexporter . setParameter ( JRExporterParameter . OUTPUT_FILE_NAME , op ) ; jrxlsexporter . exportReport ( ) ; } \n', 0.4017084932605199)

('private void exportPreferencesToFile ( Preferences prefs , String fileName , String desc ) { File file = new File ( fileName ) ; FileOutputStream output = null ; if ( ! file . exists ( ) ) { try { file . createNewFile ( ) ; } catch ( IOException e ) { log . warn ( "Impossible-to-export-" + desc + "-to-"" + fileName + ""-:-" + e . getMessage ( ) ) ; } } if ( file . exists ( ) ) { try { output = new FileOutputStream ( file ) ; prefs . exportSubtree ( output ) ; log . info ( desc + "-exported-into-"" + fileName + """ ) ; } catch ( FileNotFoundException e ) { log . warn ( "Impossible-to-export-" + desc + "-into-"" + fileName + ""-:-" + e . getMessage ( ) ) ; } catch ( IOException e ) { log . warn ( "Impossible-to-export-" + desc + "-into-"" + fileName + ""-:-" + e . getMessage ( ) ) ; } catch ( BackingStoreException e ) { log . warn ( "Impossible-to-export-" + desc + "-into-"" + fileName + ""-:-" + e . getMessage ( ) ) ; } finally { if ( output != null ) { try { output . close ( ) ; } catch ( IOException e ) { } } } } } \n', 0.39910885699278165)

('public void exportSettingsToFile ( SharedPreferences prefs , File settingsFile ) throws JSONException , IOException { JSONObject json = exportSettings ( prefs ) ; if ( settingsFile . exists ( ) ) { settingsFile . delete ( ) ; } settingsFile . getParentFile ( ) . mkdirs ( ) ; settingsFile . createNewFile ( ) ; FileWriter writer = new FileWriter ( settingsFile ) ; writer . write ( json . toString ( 2 ) ) ; writer . flush ( ) ; writer . close ( ) ; } \n', 0.3916413605100637)

('public void export ( Display display ) { if ( chooser == null ) { initializeChooser ( ) ; } File outFile = null ; int returnVal = chooser . showSaveDialog ( display ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { outFile = chooser . getSelectedFile ( ) ; } else { return ; } String format = ( ( SimpleFileFilter ) chooser . getFileFilter ( ) ) . getExtension ( ) ; String ext = IOLib . getExtension ( outFile ) ; if ( ! format . equals ( ext ) ) { outFile = new File ( outFile . toString ( ) + "." + format ) ; } boolean exported = false ; String errorMessage = null ; try { OutputStream out = new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ; exported = export ( display , out , format ) ; out . flush ( ) ; out . close ( ) ; } catch ( Exception ex ) { exported = false ; errorMessage = ex . getMessage ( ) ; ex . printStackTrace ( ) ; } if ( ! exported ) { JOptionPane . showMessageDialog ( display , errorMessage , "Export-Error" , JOptionPane . ERROR_MESSAGE ) ; } } \n', 0.38385205500364006)

('public void exportCsv ( final ArrayList < CityInformationField > fieldsToExport ) throws IOException { FileWriter writer = new FileWriter ( this . exportedCsvFileName ) ; writeCsvHeaderToFile ( writer ) ; for ( CityInformationField f : fieldsToExport ) { writeFieldToFile ( writer , f ) ; } writer . flush ( ) ; writer . close ( ) ; System . out . println ( "Sucessfully-exported-" + fieldsToExport . size ( ) + "-fields-to-" + this . exportedCsvFileName + "." ) ; } \n', 0.3823097519175188)

('public static File saveExcelWebFormsToFS ( String reportType , Date initialDate , Date finalDate ) throws Exception { try { String folder = UtilMethods . getTemporaryDirPath ( ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "MMddyyyy" ) ; String fileNameDate = sdf . format ( initialDate ) ; String filePath = folder + fileName + "_" + reportType + "_" + fileNameDate + fileExtension ; File excelFile = new File ( filePath ) ; if ( ! excelFile . exists ( ) ) { excelFile . createNewFile ( ) ; } FileWriter fileWriter = new FileWriter ( excelFile ) ; String code = CreateExcelWebForms ( reportType , initialDate , finalDate ) ; fileWriter . write ( code ) ; fileWriter . flush ( ) ; fileWriter . close ( ) ; return excelFile ; } catch ( Exception ex ) { String message = ex . toString ( ) ; Logger . debug ( WebFormFactory . class , message ) ; throw ex ; } } \n', 0.3792061345233127)

('public static String exportToFile ( Context context , boolean includeGlobals , Set < String > accountUuids ) throws SettingsImportExportException { OutputStream os = null ; String filename = null ; try { File dir = new File ( Environment . getExternalStorageDirectory ( ) + File . separator + context . getPackageName ( ) ) ; dir . mkdirs ( ) ; File file = FileHelper . createUniqueFile ( dir , EXPORT_FILENAME ) ; filename = file . getAbsolutePath ( ) ; os = new FileOutputStream ( filename ) ; exportPreferences ( context , os , includeGlobals , accountUuids ) ; return filename ; } catch ( Exception e ) { throw new SettingsImportExportException ( e ) ; } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException ioe ) { Log . w ( K9 . LOG_TAG , "Couldn\'t-close-exported-settings-file:-" + filename ) ; } } } } \n', 0.3787072590516105)

('private boolean exportConfirmed ( int imgWidth , int imgHeight , String imgType , String imgFile ) { File file = null ; try { file = ( new File ( imgFile ) ) . getAbsoluteFile ( ) ; if ( file . isDirectory ( ) ) { JOptionPane . showMessageDialog ( this , "You-have-specified-a-directory.-Please-specify-a-file." ) ; return false ; } if ( ! file . exists ( ) ) { File parent = file . getParentFile ( ) ; if ( null == parent || ! parent . isDirectory ( ) || ! parent . exists ( ) ) { JOptionPane . showMessageDialog ( this , "Please-specify-a-filename-within-an-existing-directory." ) ; return false ; } } if ( file . exists ( ) ) { int opt = JOptionPane . showConfirmDialog ( this , "Do-you-want-to-overwrite-the-file-" + file . getAbsolutePath ( ) + "?-" , "Overwrite-file?" , JOptionPane . YES_NO_OPTION ) ; if ( JOptionPane . YES_OPTION != opt ) return false ; } } catch ( SecurityException e ) { JOptionPane . showMessageDialog ( this , "The-Java-security-environment-does-not-permit-access" + "-to-the-specified-file.-You-may-be-running-LiveGraph-in" + "-a-restricted-security-environment." ) ; return false ; } if ( null != file ) exporter . doExportGraph ( imgWidth , imgHeight , imgType , file ) ; return true ; } \n', 0.37488377499151126)

('public int exportToFile ( File file ) throws IOException { PrintWriter writer = new PrintWriter ( file ) ; writeHeader ( writer ) ; int cnt = writeLog ( writer ) ; writer . flush ( ) ; writer . close ( ) ; return cnt ; } \n', 0.37359010221682715)

('public static void exportReportToPdf ( String reportSourcePath , String outputDirectory , String outputFileName , Map params , Connection connection , Integer permissions , String ownerPassword , String userPassword ) throws IOException , JRException { String op = null ; if ( outputFileName == null ) { op = outputDirectory ; File userDir = new File ( outputDirectory . substring ( 0 , outputDirectory . lastIndexOf ( "|" ) ) ) ; if ( ! userDir . exists ( ) ) userDir . mkdirs ( ) ; } else { op = outputDirectory + "|" + outputFileName ; File userDir = new File ( outputDirectory ) ; if ( ! userDir . exists ( ) ) userDir . mkdirs ( ) ; } File sourceFile = Resources . getResourceAsFile ( reportSourcePath ) ; JasperReport jasperReport = ( JasperReport ) JRLoader . loadObject ( sourceFile ) ; JasperPrint jasperPrint = JasperFillManager . fillReport ( jasperReport , params , connection ) ; JRPdfExporter jrpdfexporter = new JRPdfExporter ( ) ; jrpdfexporter . setParameter ( JRExporterParameter . JASPER_PRINT , jasperPrint ) ; jrpdfexporter . setParameter ( JRExporterParameter . OUTPUT_FILE_NAME , op ) ; jrpdfexporter . exportReport ( ) ; } \n', 0.3732302237731383)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 20 #################################
('public void setWorkingDirectory ( File wd ) { workingDirectory = ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) ? null : wd ; } \n', 0.42783612258074766)

('public void setWorkingDirectory ( File wd ) { if ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) workingDirectory = null ; else workingDirectory = wd ; } \n', 0.42783612258074766)

('public void setWorkingDirectory ( File workingDirectory ) throws MojoExecutionException { try { this . workingDirectory = workingDirectory . getCanonicalPath ( ) ; } catch ( IOException ignored ) { throw new MojoExecutionException ( "Unable-to-set-working-directory-for-JMeter-process!" ) ; } } \n', 0.4259656264195995)

('public void setWorkingDirectory ( File workingDir ) { Assert . notNull ( workingDir ) ; logger . info ( "Setting-working-directory-for-LDAP_PROVIDER:-" + workingDir . getAbsolutePath ( ) ) ; if ( workingDir . exists ( ) ) { throw new IllegalArgumentException ( "The-specified-working-directory-\'" + workingDir . getAbsolutePath ( ) + "\'-already-exists.-Another-directory-service-instance-may-be-using-it-or-it-may-be-from-a-" + "-previous-unclean-shutdown.-Please-confirm-and-delete-it-or-configure-a-different-" + "working-directory" ) ; } this . workingDir = workingDir ; service . setWorkingDirectory ( workingDir ) ; } \n', 0.4249093399552469)

('public void setWorkingDirectory ( File workingDirectory ) { this . workingDirectory = workingDirectory . getAbsolutePath ( ) ; } \n', 0.42299142273823637)

('protected void setCurrentWorkingDirectory ( File cwd ) { if ( cwd != null ) { if ( cwd . isDirectory ( ) ) this . currentWorkingDirectory = cwd ; else this . currentWorkingDirectory = cwd . getParentFile ( ) ; } else this . currentWorkingDirectory = null ; } \n', 0.4201508468648839)

('public void setWorkingDirectory ( File workingDirectory ) { m_workingDirectory = workingDirectory ; if ( m_workingDirectoryPropertySupport != null ) { m_workingDirectoryPropertySupport . firePropertyChange ( null , null , null ) ; } } \n', 0.41996574521941077)

('public void setWorkingDirectory ( File workingDirectory ) { this . configurationFile = new File ( new File ( workingDirectory . getAbsolutePath ( ) , "conf" ) , "communication.xml" ) ; } \n', 0.4183743921216871)

('public void setWorkingDirectory ( File workingDirectory ) { if ( workingDirectory != null ) { this . workingDir = workingDirectory . getAbsolutePath ( ) ; } } \n', 0.4183002165749376)

('public void setWorkingDirectory ( File workingDirectory ) { if ( ! workingDirectory . isAbsolute ( ) ) { throw new IllegalArgumentException ( "The-working-directory-must-be" + "-an-absolute-path" ) ; } this . workingDirectory = workingDirectory ; } \n', 0.41826233439862964)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 21 #################################
('public static String getStatusText ( int nHttpStatusCode ) { Integer intKey = new Integer ( nHttpStatusCode ) ; if ( ! _status_codes . containsKey ( intKey ) ) { return "" ; } else { return ( String ) _status_codes . get ( intKey ) ; } } \n', 0.3874130869968625)

('public static String getHTTPStatusCode ( String httpHeaders ) throws WSIException { String statusCode = null ; if ( httpHeaders . startsWith ( "HTTP" ) ) { int index = httpHeaders . indexOf ( "-" ) ; int index2 = httpHeaders . indexOf ( "-" , index + 1 ) ; if ( ( index == - 1 ) || ( index2 == - 1 ) ) { throw new WSIException ( "Could-not-find-status-code-in-http-headers:-[" + httpHeaders + "]." ) ; } else { statusCode = httpHeaders . substring ( index + 1 , index2 ) ; } } else { throw new WSIException ( "Could-not-find-status-code-in-http-headers:-[" + httpHeaders + "]." ) ; } return statusCode ; } \n', 0.38298904877439427)

('public static int getStatusCode ( String url ) throws IOException { int statusCode ; HttpURLConnection con = ( HttpURLConnection ) new URL ( url ) . openConnection ( ) ; con . setInstanceFollowRedirects ( false ) ; statusCode = con . getResponseCode ( ) ; con . disconnect ( ) ; return statusCode ; } \n', 0.3828281849891292)

('public static String getStatusText ( int nHttpStatusCode ) { Integer intKey = Integer . valueOf ( nHttpStatusCode ) ; if ( ! mapStatusCodes . containsKey ( intKey ) ) { return "" ; } else { return mapStatusCodes . get ( intKey ) ; } } \n', 0.37664580656189534)

('public static String getStatusText ( int nHttpStatusCode ) { if ( ! mapStatusCodes . containsKey ( nHttpStatusCode ) ) { return "" ; } return mapStatusCodes . get ( nHttpStatusCode ) ; } \n', 0.37369547934920017)

('protected int getResponseStatus ( String url ) { try { URL theURL = new URL ( url ) ; HttpURLConnection connection = ( HttpURLConnection ) theURL . openConnection ( ) ; int code = connection . getResponseCode ( ) ; connection . disconnect ( ) ; return code ; } catch ( IOException ioe ) { log . debug ( "Bad-link:-" + ioe . getMessage ( ) ) ; return 0 ; } } \n', 0.36768632876744156)

('private int getSCFromHttpStatusLine ( String line ) { int statusStart = line . indexOf ( \'-\' ) + 1 ; if ( statusStart < 1 || line . length ( ) < statusStart + 3 ) { log ( "runCGI:-invalid-HTTP-Status-Line:" + line ) ; return HttpServletResponse . SC_INTERNAL_SERVER_ERROR ; } String status = line . substring ( statusStart , statusStart + 3 ) ; int statusCode ; try { statusCode = Integer . parseInt ( status ) ; } catch ( NumberFormatException nfe ) { log ( "runCGI:-invalid-status-code:" + status ) ; return HttpServletResponse . SC_INTERNAL_SERVER_ERROR ; } return statusCode ; } \n', 0.35785846469482563)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 22 #################################
('public static HttpResponse postJSON ( JSONObject jsonData , String apiEndpoint , Context context ) { HttpResponse result = null ; if ( ! isOnline ( context ) ) { return null ; } else { result = postJsonString ( jsonData . toString ( ) , apiEndpoint , context ) ; return result ; } } \n', 0.3768976922373781)

('public static JsonElement postSerializedJSON ( URL url , final byte [ ] jsonBytes ) throws IOException { JsonParser jp = new JsonParser ( ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setDoOutput ( true ) ; conn . setDoInput ( true ) ; conn . setRequestMethod ( "POST" ) ; conn . setRequestProperty ( "Content-Type" , "application/json" ) ; conn . setRequestProperty ( "charset" , "utf-8" ) ; conn . setRequestProperty ( "Content-Length" , Integer . toString ( jsonBytes . length ) ) ; DataOutputStream wr = new DataOutputStream ( conn . getOutputStream ( ) ) ; wr . write ( jsonBytes , 0 , jsonBytes . length ) ; wr . flush ( ) ; wr . close ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; return jp . parse ( reader ) ; } \n', 0.35085202095759604)

('public static JSONObject postJsonRequest ( String url , String postData ) throws IOException , JSONException { URL obj = new URL ( url ) ; HttpURLConnection con = ( HttpURLConnection ) obj . openConnection ( ) ; con . setRequestMethod ( "POST" ) ; if ( DEBUG ) Log . d ( TAG , "Posting:-" + postData + "-to-" + url ) ; con . setDoOutput ( true ) ; DataOutputStream wr = new DataOutputStream ( con . getOutputStream ( ) ) ; wr . writeBytes ( postData ) ; wr . flush ( ) ; wr . close ( ) ; int responseCode = con . getResponseCode ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String inputLine ; StringBuffer response = new StringBuffer ( ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { response . append ( inputLine ) ; } in . close ( ) ; JSONObject json = new JSONObject ( response . toString ( ) ) ; return json ; } \n', 0.34975675414772045)

('public String postBusinessJsonProcess ( String entity_id , String json , String _user_id ) throws Exception { Hashtable params = new Hashtable ( ) ; String retval = "" ; try { params . put ( "entity_id" , entity_id ) ; params . put ( "json" , json ) ; params . put ( "_user_id" , _user_id ) ; retval = this . doCurl ( "POST" , "/business/json/process" , params ) ; } finally { } return retval ; } \n', 0.33597753489326254)

('public Map < String , Object > requestJson ( String path , Map < String , Object > getParams , Map < String , Object > postParams , Map < String , Object > requestOptions ) throws BoxViewException { HttpUriRequest request = createRequest ( path , getParams , postParams , requestOptions ) ; Integer timeout = createTimeout ( requestOptions ) ; HttpResponse response = execute ( request , timeout ) ; String responseBody = null ; try { responseBody = EntityUtils . toString ( response . getEntity ( ) ) ; } catch ( IOException e ) { } return handleJsonResponse ( responseBody , request ) ; } \n', 0.3323959691024525)

('private void postObject ( JSONObject object ) throws IOException { OutputStreamWriter out = null ; try { out = new OutputStreamWriter ( connection . getOutputStream ( ) ) ; out . write ( object . toJSONString ( ) ) ; } catch ( IOException e ) { throw ( e ) ; } finally { out . close ( ) ; } } \n', 0.3304106797427016)

('public CloseableHttpResponse postJson ( String url , String json , Map < String , String > reqHeaders ) throws IOException { CloseableHttpClient req = getClient ( ) ; CloseableHttpResponse resp = null ; HttpPost post = new HttpPost ( url ) ; addHeaders ( post , reqHeaders ) ; post . setHeader ( json , url ) ; StringEntity input = new StringEntity ( json , ContentType . APPLICATION_JSON ) ; post . setEntity ( input ) ; resp = req . execute ( post ) ; return resp ; }\n', 0.32600127778539023)

('void postJson ( String url , String json ) { PrintWriter writer = null ; try { HttpURLConnection connection = ( HttpURLConnection ) new URL ( url ) . openConnection ( ) ; connection . setConnectTimeout ( 5000 ) ; connection . setReadTimeout ( 5000 ) ; connection . setDoOutput ( true ) ; connection . setRequestProperty ( API_KEY_HEADER , apiKey ) ; connection . setRequestProperty ( CONTENT_TYPE_HEADER , JSON_CONTENT_TYPE ) ; writer = new PrintWriter ( connection . getOutputStream ( ) , true ) ; writer . append ( json ) ; writer . close ( ) ; int responseCode = connection . getResponseCode ( ) ; if ( responseCode != 200 ) { logger . warning ( String . format ( "Analytics-server-returned-HTTP-response-code:-%s-when-posting-data-to-url:-%s" , responseCode , url ) ) ; } } catch ( Exception e ) { logger . warning ( String . format ( "Error-sending-data-to-url:-%s,-error:-%s" , url , e . getMessage ( ) ) ) ; } finally { IOUtils . closeQuietly ( writer ) ; } } \n', 0.32217285242814575)

('public static JSONObject postRequestWithData ( String action , HashMap < String , String > params ) throws JSONException { String json_data = encodeData ( params ) ; try { String data = URLEncoder . encode ( "action" , "UTF-8" ) + "=" + URLEncoder . encode ( action , "UTF-8" ) ; data += "&" + URLEncoder . encode ( "data" , "UTF-8" ) + "=" + URLEncoder . encode ( json_data , "UTF-8" ) ; URL url = new URL ( SERVER_URL ) ; URLConnection conn = url . openConnection ( ) ; conn . setDoOutput ( true ) ; OutputStreamWriter wr = new OutputStreamWriter ( conn . getOutputStream ( ) ) ; wr . write ( data ) ; wr . flush ( ) ; StringBuilder answer = new StringBuilder ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; String line = "" ; while ( ( line = rd . readLine ( ) ) != null ) { answer . append ( line ) ; } wr . close ( ) ; rd . close ( ) ; returnData = new JSONObject ( answer . toString ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; returnData = new JSONObject ( ) ; returnData . put ( "message" , "ERROR" ) ; } return returnData ; } \n', 0.31966237259204866)

('private static void validateOAuthRequest ( String requestUrl , Map < String , String [ ] > requestParams , String jsonBody , String consumerKey , String consumerSecret ) throws NoSuchAlgorithmException , IOException , URISyntaxException , OAuthException { List < OAuth . Parameter > params = new ArrayList < OAuth . Parameter > ( ) ; for ( Entry < String , String [ ] > entry : requestParams . entrySet ( ) ) { for ( String value : entry . getValue ( ) ) { params . add ( new OAuth . Parameter ( entry . getKey ( ) , value ) ) ; } } OAuthMessage message = new OAuthMessage ( POST , requestUrl , params ) ; MessageDigest md = MessageDigest . getInstance ( SHA_1 ) ; byte [ ] hash = md . digest ( jsonBody . getBytes ( UTF_8 ) ) ; String encodedHash = new String ( Base64 . encodeBase64 ( hash , false ) , UTF_8 ) ; if ( ! encodedHash . equals ( message . getParameter ( OAUTH_BODY_HASH ) ) ) { throw new IllegalArgumentException ( "Body-hash-does-not-match.-Expected:-" + encodedHash + ",-provided:-" + message . getParameter ( OAUTH_BODY_HASH ) ) ; } OAuthConsumer consumer = new OAuthConsumer ( null , consumerKey , consumerSecret , null ) ; OAuthAccessor accessor = new OAuthAccessor ( consumer ) ; LOG . info ( "Signature-base-string:-" + OAuthSignatureMethod . getBaseString ( message ) ) ; message . validateMessage ( accessor , new SimpleOAuthValidator ( ) ) ; } \n', 0.3195619103359002)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 23 #################################
('public static void finishConnect ( String username , Socket socket ) { Server . println ( "Continuing-to-connect-with-username-" + username ) ; sendAll ( new ConnectionMessage ( username , Utils . Utils . getCurrentTimestamp ( ) , ConnectionMessage . types . CONNECT ) ) ; giveAllConnections ( username ) ; Server . println ( "True;-can-connect-with" + username ) ; } \n', 0.3481096675283152)

('public void connected ( ) throws CommunicatorException { try { myConnection . getChannel ( ) . finishConnect ( ) ; LOG . info ( "Connection-extablished-successfully-with" + "-the-remote-host" ) ; } catch ( IOException e ) { throw new CommunicatorException ( e ) ; } } \n', 0.3459954982339756)

('protected void receiveAndAddConnection ( ) { try { DatagramPacket receivePacket = new DatagramPacket ( receiveData , receiveData . length ) ; if ( logger != null ) logger . info ( "waiting-for-" + ( numClients - connections . size ( ) ) + "-more-clients-to-reconnect..." ) ; socket . receive ( receivePacket ) ; InetAddress ip = receivePacket . getAddress ( ) ; int port = receivePacket . getPort ( ) ; String connID = UDPConnection . buildHash ( ip , port ) ; if ( connections . get ( connID ) == null ) { if ( connections . size ( ) == 0 ) { frameCount = 0 ; if ( logger != null ) logger . info ( "resetting-frame-count" ) ; } UDPConnection conn = new UDPConnection ( ip , port ) ; connections . put ( connID , conn ) ; conn . send ( socket , getSyncPayload ( ) ) ; if ( logger != null ) logger . fine ( "added-new-connection:-" + conn ) ; if ( listener != null ) { listener . clientConnected ( conn ) ; } } } catch ( SocketTimeoutException e ) { } catch ( IOException e ) { handleException ( e ) ; } } \n', 0.34473075443449164)

('public void manageProfileConnection ( IConnectionProfile profile , String factoryID , Object client ) { ManagedProfileKey key = new ManagedProfileKey ( profile , factoryID ) ; if ( ! mManagedProfileKeyToConnections . containsKey ( key ) ) { IConnection con = createConnection ( profile , factoryID ) ; mManagedProfileKeyToConnections . put ( key , con ) ; mManagedProfileKeyToClientSet . put ( key , new HashSet ( ) ) ; IConnectListener listener = ( IConnectListener ) mFactoryIDToListener . get ( factoryID ) ; if ( listener == null ) { listener = new ProfileConnectListener ( factoryID ) ; mFactoryIDToListener . put ( factoryID , listener ) ; } Set listeners = ( Set ) mProfileToListenerSet . get ( profile ) ; if ( listeners == null ) { listeners = new HashSet ( ) ; mProfileToListenerSet . put ( profile , listeners ) ; } listeners . add ( listener ) ; profile . addConnectListener ( listener ) ; } ( ( Set ) mManagedProfileKeyToClientSet . get ( key ) ) . add ( client ) ; } \n', 0.34381061683868597)

('private Connection establishOutboundConnection ( ) throws ConnectException , InterruptedException { final Socket socket = new Socket ( ) ; final InetSocketAddress peerAddr = getRemotePeer ( ) . toInetSocketAddress ( ) ; final long startTime = System . currentTimeMillis ( ) ; try { try { socket . setReuseAddress ( true ) ; } catch ( final SocketException e ) { throw new ConnectSocketConfigException ( e ) ; } while ( true ) { try { socket . connect ( peerAddr , CONNECT_INTERVAL_TIMEOUT ) ; } catch ( SocketTimeoutException e ) { if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; } catch ( IOException e ) { throw new ConnectIOException ( e ) ; } catch ( IllegalBlockingModeException e ) { throw new LogicError ( e ) ; } catch ( IllegalArgumentException e ) { throw new LogicError ( e ) ; } if ( socket . isConnected ( ) ) break ; if ( System . currentTimeMillis ( ) - startTime >= CONNECT_TIMEOUT ) throw new ConnectTimeoutException ( ) ; } return new Connection ( socket , getLocalPeer ( ) , getRemotePeer ( ) ) ; } finally { if ( ! socket . isConnected ( ) ) { try { socket . close ( ) ; } catch ( IOException e ) { throw new ConnectSocketFailedToCloseException ( e ) ; } } } } \n', 0.34110208204359943)

('public static NtlmHttpURLConnection openConnection ( URL url , PasswordAuthentication cred , boolean encrypt ) { synchronized ( pool ) { String id = createId ( url ) ; if ( pool . containsKey ( id ) ) { Queue < NtlmHttpURLConnection > connections = pool . get ( id ) ; while ( connections . size ( ) > 0 ) { NtlmHttpURLConnection conn = connections . remove ( ) ; long dormant = System . currentTimeMillis ( ) - conn . lastUsed ; if ( conn . connection . connected ( ) ) { if ( dormant > MAX_KEEPALIVE ) { conn . connection . disconnect ( ) ; } else { conn . cred = cred ; return conn ; } } } } else { pool . put ( id , new ConcurrentLinkedQueue < NtlmHttpURLConnection > ( ) ) ; } return new NtlmHttpURLConnection ( url , cred , encrypt ) ; } } \n', 0.3397925087879554)

('public MBeanServerConnection openConnection ( JMXServiceURL serviceUrl , String username , String password ) throws IOException { JMXConnector connector ; HashMap < String , Object > environment = new HashMap < String , Object > ( ) ; environment . put ( "jmx.remote.x.client.connection.check.period" , 5000 ) ; if ( username != null && password != null ) { environment . put ( JMXConnector . CREDENTIALS , new String [ ] { username , password } ) ; connector = JMXConnectorFactory . connect ( serviceUrl , environment ) ; } else { connector = JMXConnectorFactory . connect ( serviceUrl , environment ) ; } MBeanServerConnection connection = connector . getMBeanServerConnection ( ) ; connections . put ( connection , connector ) ; return connection ; } \n', 0.3379328375631272)

('private void closeAllConnections ( ) { for ( Iterator < Connection > iterator = this . pendingConnections . iterator ( ) ; iterator . hasNext ( ) ; ) { Connection connection = iterator . next ( ) ; iterator . remove ( ) ; try { connection . close ( ) ; } catch ( IOException e ) { } } for ( Iterator < Connection > iterator = this . unconnectedPeers . iterator ( ) ; iterator . hasNext ( ) ; ) { Connection connection = iterator . next ( ) ; iterator . remove ( ) ; try { connection . close ( ) ; } catch ( IOException e ) { } } for ( Iterator < ManageablePeer > iterator = this . connectedPeers . iterator ( ) ; iterator . hasNext ( ) ; ) { ManageablePeer peer = iterator . next ( ) ; iterator . remove ( ) ; peer . close ( ) ; } this . connectedPeerIDs . clear ( ) ; } \n', 0.3376989161452197)

('private void connectConnection ( String host , int port ) throws ChannelError { if ( HydnaDebug . HYDNADEBUG ) { DebugHelper . debugPrint ( "Connection" , 0 , "Connecting,-attempt-" ) ; } try { SocketAddress address = new InetSocketAddress ( host , port ) ; m_socketChannel = SocketChannel . open ( address ) ; m_socket = m_socketChannel . socket ( ) ; try { m_socket . setTcpNoDelay ( true ) ; } catch ( SocketException e ) { System . err . println ( "WARNING:-Could-not-set-TCP_NODELAY" ) ; } m_outStream = new DataOutputStream ( m_socket . getOutputStream ( ) ) ; m_inStreamReader = new BufferedReader ( new InputStreamReader ( m_socket . getInputStream ( ) ) ) ; if ( HydnaDebug . HYDNADEBUG ) { DebugHelper . debugPrint ( "Connection" , 0 , "Connected,-sending-HTTP-upgrade-request" ) ; } m_connecting = false ; m_connected = true ; connectHandler ( ) ; } catch ( UnresolvedAddressException e ) { m_connecting = false ; throw new ChannelError ( "The-host-"" + host + ""-could-not-be-resolved" ) ; } catch ( IOException e ) { m_connecting = false ; throw new ChannelError ( "Could-not-connect-to-the-host-"" + host + ""-on-the-port-" + port ) ; } } \n', 0.3373394020702864)

('public void connect ( String username , String password ) throws Exception { this . username = username ; this . password = password ; if ( ! connection . isConnected ( ) ) { try { connection . connect ( ) ; connection . login ( username , password ) ; psm = new PubSubManager ( connection , service ) ; addItemListenerToSubscribedNodes ( ) ; updateTopicList ( ) ; } catch ( Exception e ) { if ( connection . isConnected ( ) ) { connection . disconnect ( ) ; } throw e ; } } } \n', 0.33638168968528187)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 24 #################################
('public void copyFileFromLocalToHDFS ( Path inLocalFileSystem , Path inHDFS ) throws IOException { fs . copyFromLocalFile ( inLocalFileSystem , inHDFS ) ; } \n', 0.37192418807053074)

('public static long copyInputStreamToPath ( final InputStream is , final Path destPath , final Configuration conf ) throws IOException { if ( is == null ) { throw new NullPointerException ( "The-input-stream-is-null" ) ; } if ( destPath == null ) { throw new NullPointerException ( "The-destination-path-is-null" ) ; } if ( conf == null ) { throw new NullPointerException ( "The-configuration-object-is-null" ) ; } final FileSystem fs = FileSystem . get ( destPath . toUri ( ) , conf ) ; final OutputStream os = fs . create ( destPath ) ; return FileUtils . copy ( is , os ) ; } \n', 0.37169980749232523)

('public void copyToLocalFile ( boolean delSrc , boolean validate , Path src , Path dst ) throws IOException { FileUtil . copy ( this , src , getLocal ( getConf ( ) ) , dst , delSrc , validate , getConf ( ) ) ; } \n', 0.3694456612481368)

('public void copyToLocalFile ( boolean delSrc , Path src , Path dst ) throws IOException { FileUtil . copy ( this , src , getLocal ( getConf ( ) ) , dst , delSrc , getConf ( ) ) ; } \n', 0.3686831406995327)

('public void copyToLocalFile ( Path src , Path dst ) throws IOException { copyToLocalFile ( false , src , dst ) ; } \n', 0.367337288907915)

('public void copyToLocalFile ( Path src , Path dst ) throws IOException { fs . copyToLocalFile ( src , dst ) ; } \n', 0.3619510225046954)

('@ Deprecated public void copyToLocalFile ( Path src , Path dst ) throws IOException { copyToLocalFile ( false , false , src , dst ) ; } \n', 0.35844416534828727)

('@ Override public void copyToLocalFile ( Path src , Path dst ) throws IOException { underlyingFs . copyToLocalFile ( src , dst ) ; } \n', 0.35648878803593625)

('private static void copyToFile ( InputStream source , Path destination ) throws IOException { Files . createDirectories ( destination . getParent ( ) ) ; try ( OutputStream out = Files . newOutputStream ( destination ) ) { IOUtils . copy ( source , out ) ; } } \n', 0.3515260461233495)

('public void copyToLocalFile ( boolean delSrc , Path src , Path dst ) throws IOException { fs . copyToLocalFile ( delSrc , src , dst ) ; } \n', 0.3507480292938136)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 25 #################################
('public static void readFileBufferedFileReader ( File file ) { BufferedReader bufferedReader = null ; try { log . info ( "##-[ReadFile]-read-file:-" + file . getCanonicalPath ( ) + "-##" ) ; bufferedReader = new BufferedReader ( new FileReader ( file ) ) ; String line ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { log . info ( "##-[ReadFile]-line:-" + line + "-##" ) ; } } catch ( FileNotFoundException e ) { log . error ( "##-[ReadFile]-open-file-failed-##" ) ; log . error ( e . getMessage ( ) ) ; } catch ( IOException e ) { log . error ( "##-[ReadFile]-read-file-failed-##" ) ; log . error ( e . getMessage ( ) ) ; } finally { try { if ( bufferedReader != null ) { bufferedReader . close ( ) ; } } catch ( IOException e ) { log . error ( "##-[ReadFile]-close-file-failed-##" ) ; log . error ( e . getMessage ( ) ) ; } } } \n', 0.3653537608164582)

('public static String loadTextFile ( File file ) throws IOException { char [ ] buffer = new char [ 4096 ] ; int len ; StringBuilder input = new StringBuilder ( ) ; BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; try { while ( ( len = reader . read ( buffer ) ) != - 1 ) { input . append ( buffer , 0 , len ) ; } } finally { reader . close ( ) ; } return input . toString ( ) ; } \n', 0.3607215733120297)

('private String readEmbeddedTextFile ( String filepath ) throws IOException { InputStream is = BuildConfigGenerator . class . getResourceAsStream ( filepath ) ; if ( is != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String line ; StringBuilder total = new StringBuilder ( reader . readLine ( ) ) ; while ( ( line = reader . readLine ( ) ) != null ) { total . append ( \'|n\' ) ; total . append ( line ) ; } return total . toString ( ) ; } throw new IOException ( "BuildConfig-template-is-missing!" ) ; } \n', 0.3606868883824992)

('public static BufferedReader loadTextFile ( String path ) throws FileNotFoundException { return new BufferedReader ( new InputStreamReader ( loadFile ( path ) ) ) ; } \n', 0.35917215435214767)

('public static String readEntireTextFile ( File file ) throws IOException { return extractReaderContents ( new BufferedReader ( new FileReader ( file ) ) ) ; } \n', 0.35549003093331955)

('public static BufferedReader getTextFileReader ( String fileName ) throws IOException { BufferedReader fileIn = new BufferedReader ( new InputStreamReader ( new FileInputStream ( fileName ) , "UTF-8" ) ) ; String inLine = fileIn . readLine ( ) ; if ( inLine == null ) { } else if ( inLine . equals ( "UTF-8" ) ) { return fileIn ; } fileIn . close ( ) ; return new BufferedReader ( new FileReader ( fileName ) ) ; } \n', 0.35431480627018913)

('public static String [ ] readTextFile ( InputStream in , String encoding ) throws IOException { ArrayList < String > lines = new ArrayList < String > ( ) ; BufferedReader bufferedIn ; if ( encoding != null ) { bufferedIn = new BufferedReader ( new InputStreamReader ( in , encoding ) ) ; } else { bufferedIn = new BufferedReader ( new InputStreamReader ( in ) ) ; } String line ; while ( ( line = bufferedIn . readLine ( ) ) != null ) { lines . add ( line ) ; } bufferedIn . close ( ) ; in . close ( ) ; return ( String [ ] ) lines . toArray ( new String [ lines . size ( ) ] ) ; } \n', 0.3542119389207141)

('public static String readTextFile ( InputStream textFile ) throws IOException { return readTextFile ( new BufferedReader ( new InputStreamReader ( textFile ) ) ) ; } \n', 0.3539053268818163)

('private void loadTextFile ( ) throws IOException { logger . debug ( "Entering-loadTextFile()" ) ; FileReader fr = new FileReader ( selectedFile ) ; int ch = 0 ; StringBuffer readFile = new StringBuffer ( ) ; while ( ch != - 1 ) { ch = fr . read ( ) ; if ( ch != - 1 ) readFile . append ( ( char ) ch ) ; } fr . close ( ) ; resultTextFile = readFile . toString ( ) ; } \n', 0.35376825871898543)

('public static String [ ] readTextFileStream ( Reader reader ) throws IOException { String [ ] content = null ; String txt = null ; Vector buffer = new Vector ( ) ; BufferedReader rd = new BufferedReader ( reader ) ; while ( ( txt = rd . readLine ( ) ) != null ) { buffer . addElement ( txt ) ; } rd . close ( ) ; content = new String [ buffer . size ( ) ] ; for ( int i = 0 ; i < content . length ; i ++ ) { content [ i ] = ( String ) buffer . elementAt ( i ) ; } return content ; } \n', 0.3535162367840342)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 26 #################################
('@ Override public long getLowPowerModeEnabledTime ( long elapsedRealtimeUs , int which ) { return mLowPowerModeEnabledTimer . getTotalTimeLocked ( elapsedRealtimeUs , which ) ; } \n', 0.3882932110312676)

('public long getTotalElapsedTime ( ) { long currentTime = toMilliseconds ( System . nanoTime ( ) ) ; return getTotalElapsedTime ( currentTime ) ; } \n', 0.3749015926737518)

('public long getTotalElapsedTime ( ) { long currentTime = System . nanoTime ( ) / 1000000 ; return getTotalElapsedTime ( currentTime ) ; } \n', 0.37260753582694134)

('@ Override public long getInteractiveTime ( long elapsedRealtimeUs , int which ) { return mInteractiveTimer . getTotalTimeLocked ( elapsedRealtimeUs , which ) ; } \n', 0.3692850597938019)

('public long getTotalElapsedTime ( ) { return getTotalElapsedTime ( System . nanoTime ( ) ) ; } \n', 0.3692384046096513)

('private String getInProgressTimeElapsed ( ) { long millis = System . currentTimeMillis ( ) - firstHitCreateTime . getTimeInMillis ( ) ; return millisToTimeElapsedString ( millis ) ; } \n', 0.36356890268359854)

('private boolean timerTick ( ) { this . remainingInterval = Math . max ( this . adjustedInterval - ( System . currentTimeMillis ( ) - this . startTime ) , 0L ) ; this . invokeOnTimerTick ( this . remainingInterval ) ; if ( this . isElapsed ( ) ) { this . stop ( ) ; this . fireOnTimerElapsed ( ) ; } return ! this . isElapsed ( ) ; } \n', 0.3626171361730315)

('public long getElapsedTimeSecs ( ) { long elapsed ; if ( running ) { elapsed = ( ( System . currentTimeMillis ( ) - startTime ) / 1000 ) ; } else { elapsed = ( ( stopTime - startTime ) / 1000 ) ; } return elapsed ; } \n', 0.3619020856459324)

('public long getElapsedTimeSecs ( ) { long elapsed ; if ( this . running ) { elapsed = ( ( System . currentTimeMillis ( ) - this . startTime ) / 1000 ) ; } else { elapsed = ( ( this . stopTime - this . startTime ) / 1000 ) ; } return elapsed ; } \n', 0.3619020856459324)

('public long getElapsedTimeSecs ( ) { long elapsed = this . getElapsedTime ( ) / 1000 ; return elapsed ; } \n', 0.35775980058433643)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 27 #################################
('public String stringReverse ( String binExp ) { StringBuilder revbinExp = new StringBuilder ( ) ; for ( int i = 0 ; i < binExp . length ( ) ; i ++ ) { revbinExp . append ( binExp . charAt ( i ) ) ; } return revbinExp . reverse ( ) . toString ( ) ; } \n', 0.37652263895113425)

('private static String stringReverse ( String s ) { if ( s . length ( ) <= 1 ) { return s ; } return stringReverse ( s . substring ( 1 , s . length ( ) ) ) + s . charAt ( 0 ) ; } \n', 0.3719384710030047)

('private static String reverseBynaryString ( final String binaryString ) { final StringBuilder reversedBinaryStringBuilder = new StringBuilder ( ) ; for ( int i = BITS - BYTE ; i >= 0 ; i -= BYTE ) { reversedBinaryStringBuilder . append ( binaryString . substring ( i , i + BYTE ) ) ; } return reversedBinaryStringBuilder . toString ( ) ; } \n', 0.3668415434075186)

('private static String reverseString ( String input ) { return new StringBuilder ( input ) . reverse ( ) . toString ( ) ; } \n', 0.36683190618055767)

('public static String reverseStringUsingRecursion ( String inputString ) { if ( inputString . length ( ) == 0 ) { return "" ; } return inputString . charAt ( inputString . length ( ) - 1 ) + reverseStringUsingRecursion ( inputString . substring ( 0 , inputString . length ( ) - 1 ) ) ; } \n', 0.3631486670384907)

('public static String reverseString ( String str ) { if ( str . length ( ) < 2 ) { return str ; } else { return reverseString ( str . substring ( 1 ) ) + str . charAt ( 0 ) ; } } \n', 0.3627650394343838)

('public static String reverseString ( String inputString ) { String reversedString = "" ; if ( inputString . length ( ) == 1 ) { return inputString ; } else { reversedString += inputString . charAt ( inputString . length ( ) - 1 ) + reverseString ( inputString . substring ( 0 , inputString . length ( ) - 1 ) ) ; return reversedString ; } } \n', 0.36049334819153733)

('private static String reverseString3 ( String s ) { if ( s . length ( ) == 1 ) return s . substring ( 0 , 1 ) ; return s . substring ( s . length ( ) - 1 ) + reverseString3 ( s . substring ( 0 , s . length ( ) - 1 ) ) ; } \n', 0.36000768826033835)

('public static String reverseString ( String in ) { return new StringBuffer ( in ) . reverse ( ) . toString ( ) ; } \n', 0.35802043036793435)

('static String reverseStringRecursive ( String str ) { if ( str . length ( ) == 0 ) { return "" ; } return str . substring ( str . length ( ) - 1 ) + reverseStringRecursive ( str . substring ( 0 , str . length ( ) - 1 ) ) ; } \n', 0.35481307463608236)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 28 #################################
('public static String extractHtml ( String content , String startpoint , String endpoint ) { Pattern startPattern = Pattern . compile ( startpoint , Pattern . CASE_INSENSITIVE ) ; Pattern endPattern = Pattern . compile ( endpoint , Pattern . CASE_INSENSITIVE ) ; Matcher startMatcher = startPattern . matcher ( content ) ; Matcher endMatcher = endPattern . matcher ( content ) ; int start = 0 ; int end = content . length ( ) ; if ( startMatcher . find ( ) ) { start = startMatcher . end ( ) ; } if ( endMatcher . find ( start ) ) { end = endMatcher . start ( ) ; } return content . substring ( start , end ) ; } \n', 0.4225099506087976)

('public static String extractContentStrippingMarkup ( String htmlText , String startMark , String endMark ) { String content = "" ; int startMarkIndex = htmlText . indexOf ( startMark ) ; int endMarkIndex = htmlText . indexOf ( endMark ) ; if ( startMarkIndex != - 1 && endMarkIndex != - 1 ) { startMarkIndex += startMark . length ( ) ; content = htmlText . substring ( startMarkIndex , endMarkIndex ) ; Source src = new Source ( content ) ; content = src . getTextExtractor ( ) . toString ( ) ; } return content ; } \n', 0.4201197423600136)

("public boolean extractJSONfromHTML ( ) { JSONValue jsonValue ; String tagId = url . substring ( url . lastIndexOf ( '/' ) + 1 ) ; Element dataTag = Document . get ( ) . getElementById ( tagId ) ; if ( dataTag != null ) { jsonValue = JSONParser . parseStrict ( dataTag . getInnerHTML ( ) ) ; task . process ( jsonValue ) ; return true ; } else { String location = Window . Location . getHref ( ) ; return false ; } } \n", 0.41435941131403653)

('private String extractFromHtml ( String content ) throws Exception { Parser myParser ; Node [ ] nodes = null ; myParser = Parser . createParser ( content , null ) ; NodeFilter filter = new NodeClassFilter ( TextNode . class ) ; nodes = myParser . extractAllNodesThatMatch ( filter ) . toNodeArray ( ) ; StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) { TextNode textnode = ( TextNode ) nodes [ i ] ; String line = textnode . toPlainTextString ( ) . trim ( ) ; result . append ( line ) ; } return result . toString ( ) ; } \n', 0.41264880182455893)

('public static LinkedList extractFootnotesFromContent ( String content ) { LinkedList < String > footnotes = new LinkedList < > ( ) ; int pos = 0 ; while ( pos != - 1 ) { pos = content . indexOf ( Constants . footnoteHtmlTag , pos ) ; if ( pos != - 1 ) { int end = content . indexOf ( """ , pos + Constants . footnoteHtmlTag . length ( ) ) ; if ( end != - 1 ) { String fn = content . substring ( pos + Constants . footnoteHtmlTag . length ( ) , end ) ; if ( - 1 == footnotes . indexOf ( fn ) ) { footnotes . add ( fn ) ; } pos = end ; } else { pos = pos + Constants . footnoteHtmlTag . length ( ) ; } } } return footnotes ; } \n', 0.4123791874405629)

('private HashMap < String , String > extractContentFromLPISTable ( final String input ) { HashMap < String , String > output = new HashMap < String , String > ( ) ; String [ ] rows = extractDataBetweenStartAndEndString ( input , "<tr" , "</tr>" ) ; Pattern startGoals = Pattern . compile ( ".*<b>Lernergebnisse.*</b>.*" ) ; Pattern startContent = Pattern . compile ( ".*<b>Inhalte-der-LV:</b>.*" ) ; for ( int i = 0 ; i < rows . length ; i ++ ) { Log . v ( TAG , "Row:-" + rows [ i ] ) ; if ( startGoals . matcher ( rows [ i ] ) . matches ( ) ) { output . put ( "goals" , extractDataBetweenStartAndEndString ( rows [ ++ i ] , "<td" , "</td>" ) [ 0 ] ) ; } else if ( startContent . matcher ( rows [ i ] ) . matches ( ) ) { output . put ( "content" , extractDataBetweenStartAndEndString ( rows [ ++ i ] , "<td" , "</td>" ) [ 0 ] ) ; } } return output ; } \n', 0.40641326792359056)

('private Map < String , Object > extractHTMLContent ( String url , InputStream in ) throws Exception { Map < String , Object > config = new HashMap < String , Object > ( ) ; config . put ( "perComponentDOM" , false ) ; config . put ( "perPipelineDOM" , true ) ; Map < String , Object > metadata = new HashMap < String , Object > ( ) ; metadata . put ( "url" , url ) ; List < String > components = new ArrayList < String > ( ) ; components . add ( "meaningfulweb" ) ; Map < String , Object > output = new HashMap < String , Object > ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; byte [ ] contentBytes = new byte [ DEFAULT_BUFFER_SIZE ] ; long totalBytesRead = 0L ; while ( true ) { int count = in . read ( contentBytes ) ; if ( count > 0 ) { totalBytesRead += count ; baos . write ( contentBytes , 0 , count ) ; } else if ( count < 0 ) { break ; } if ( totalBytesRead >= MAX_CONTENT_LEN ) break ; } if ( totalBytesRead >= MAX_CONTENT_LEN ) throw new IOException ( "content-too-large" ) ; contentBytes = baos . toByteArray ( ) ; Extract extract = new Extract ( contentBytes ) ; extract . getComponents ( ) . addAll ( components ) ; extract . setConfig ( config ) ; extract . setMetadata ( metadata ) ; try { htmlExtractor . extract ( extract ) ; output = extract . getExtracted ( ) ; } catch ( Exception e ) { logger . error ( "Error-extracting-content" , e ) ; } return output ; } \n', 0.4033043923545837)

('private void extractFaviconFromHTML ( Image icon , File cachedFile ) { try { String page = fetchPage ( icon . getArticleURL ( ) ) ; Matcher matcher = FAVICON_PATTERN . matcher ( page ) ; if ( matcher . find ( ) ) { URL url = new URL ( icon . getArticleURL ( ) , matcher . group ( 1 ) ) ; StreamUtils . copyStreamToFile ( openConnection ( url ) . getInputStream ( ) , cachedFile ) ; LOG . debug ( "Downloaded-favicon-via-web-page:-" + url . toString ( ) ) ; } else { LOG . info ( "No-favicon-for:-" + icon . getArticleURL ( ) ) ; } } catch ( IOException ex ) { cachedFile . delete ( ) ; LOG . warn ( "Failed-downloading-home-page-for-favicon:-" + icon . getArticleURL ( ) ) ; } } \n', 0.40291513158355446)

('public static List < String > extractUrlsFromHtml ( String html ) { List < String > result = new ArrayList < String > ( ) ; Matcher matcher = HTML_URLS . matcher ( html ) ; while ( matcher . find ( ) ) { result . add ( matcher . group ( 2 ) ) ; } return result ; } \n', 0.3992919839028373)

('public static String extractHtmlBody ( String content ) { Matcher startMatcher = BODY_START_PATTERN . matcher ( content ) ; Matcher endMatcher = BODY_END_PATTERN . matcher ( content ) ; int start = 0 ; int end = content . length ( ) ; if ( startMatcher . find ( ) ) { start = startMatcher . end ( ) ; } if ( endMatcher . find ( start ) ) { end = endMatcher . start ( ) ; } return content . substring ( start , end ) ; } \n', 0.39899179354834174)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 29 #################################
('private static String getWebLinkHtml ( ) { String content = null ; URLConnection connection = null ; try { connection = new URL ( SECI_LINKS_URL ) . openConnection ( ) ; Scanner scanner = new Scanner ( connection . getInputStream ( ) ) ; scanner . useDelimiter ( "|Z" ) ; content = scanner . next ( ) ; scanner . close ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return content ; } \n', 0.38798269203140223)

('public static String getExtMetadataFromPage ( HtmlPage page ) throws Exception { String metadata = "" ; String metaPage = page . getWebResponse ( ) . getContentAsString ( ) ; metaPage = decoder . decode ( metaPage ) ; log ( Level . FINEST , "getMetadataFromPage" , "metaPage-=-" + "metaPage" ) ; if ( ! ( metaPage . indexOf ( "EntityConfig" ) == - 1 ) ) { metadata = metaPage . substring ( metaPage . indexOf ( "EntityConfig" ) - 1 , metaPage . lastIndexOf ( "EntityConfig" ) + 13 ) ; } log ( Level . FINEST , "getMetadataFromPage" , "Encoded-metadata-=-" + metadata ) ; log ( Level . FINEST , "getMetadataFromPage" , "Decoded-metadata-=-" + metadata ) ; return metadata ; } \n', 0.3693512602908423)

('public static String getExtMetadataFromPage ( HtmlPage page , String spec ) throws Exception { String metadata = "" ; if ( spec . equals ( "wsfed" ) ) { String metaPage = page . getWebResponse ( ) . getContentAsString ( ) ; log ( Level . FINEST , "getExtMetadataFromPage" , "Encoded-metaPage-for-" + "wsfed-=-" + metaPage ) ; metaPage = decoder . decode ( metaPage ) ; log ( Level . FINEST , "getExtMetadataFromPage" , "Decoded-metaPage-for-" + "wsfed-=-" + metaPage ) ; if ( ! ( metaPage . indexOf ( "FederationConfig" ) == - 1 ) ) { metadata = metaPage . substring ( metaPage . indexOf ( "FederationConfig" ) - 1 , metaPage . lastIndexOf ( "FederationConfig" ) + 17 ) ; } } else if ( ( spec . equals ( "saml2" ) ) || ( spec . equals ( "idff" ) ) ) { metadata = getExtMetadataFromPage ( page ) ; log ( Level . FINEST , "getExtMetadataFromPage" , "Encoded-metadata-=-" + metadata ) ; } log ( Level . FINEST , "getExtMetadataFromPage" , "Decoded-metadata-=-" + metadata ) ; return metadata ; } \n', 0.36595382575486624)

('public List < String > getWebLinksListFromHtml ( String htmlData ) { final List < String > webLinksList = new ArrayList < String > ( ) ; htmlData . replaceAll ( "|s+" , "-" ) ; final HTMLLinkExtractor extractor = new HTMLLinkExtractor ( ) ; final List < HtmlLink > links = extractor . grabHTMLLinks ( htmlData ) ; for ( int i = 0 ; i < links . size ( ) ; i ++ ) { final HtmlLink htmlLinks = links . get ( i ) ; webLinksList . add ( htmlLinks . getLink ( ) ) ; } return webLinksList ; } \n', 0.3633318176434981)

('public String getWebPageContents ( ) { if ( webPageContents == null || webPageContents . isEmpty ( ) ) { final String htmlPageLocationInitial = getHtmlPageLocation ( ) ; final String pageLocation ; pageLocation = htmlPageLocationInitial . startsWith ( "/" ) ? htmlPageLocationInitial . substring ( 1 , htmlPageLocationInitial . length ( ) ) : htmlPageLocationInitial ; webPageContents = IO . read ( Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( pageLocation ) ) ; } return webPageContents ; } \n', 0.3583296544198321)

('public static String getWebHtml ( String webUrl ) { System . out . println ( "Reading-Web-" ) ; URL u = null ; InputStream in = null ; InputStreamReader r = null ; BufferedReader br = null ; String message = null ; String html = null ; try { u = new URL ( webUrl ) ; in = u . openStream ( ) ; r = new InputStreamReader ( in , "UTF-8" ) ; br = new BufferedReader ( r ) ; while ( ( message = br . readLine ( ) ) != null ) { html = html + message ; } } catch ( Exception e ) { e . getStackTrace ( ) ; System . out . println ( e . getMessage ( ) ) ; } finally { try { u = null ; in . close ( ) ; r . close ( ) ; br . close ( ) ; } catch ( Exception e ) { } } System . out . println ( "----Read-finisded" ) ; return html ; } \n', 0.3538113579091579)

('public static final String getWebPageSource ( String url , String htmlRqd_atEnd ) { return appendWebPageSource ( ( new StringBuilder ( ) ) , url , htmlRqd_atEnd ) . toString ( ) ; } \n', 0.3463842801638882)

('public static final String getWebPageSourceX ( String url , String htmlRqd_atEnd ) throws MalformedURLException , IOException { return appendWebPageSourceX ( ( new StringBuilder ( ) ) , url , htmlRqd_atEnd ) . toString ( ) ; } \n', 0.3463842801638882)

('public String getOlatUrlAsHtmlHref ( ) { return Formatter . getHtmlHref ( olatWebUrl , "OLAT" ) ; } \n', 0.34495244209203607)

('public String getOuterHTML ( ) { String outerhtml = "" ; JavascriptExecutor js = null ; if ( curWebElement != null ) { Logger . log ( "Getting-outerHTML-value-from-" + getElementName ( ) + "-link-" + "in-page-" + getPageName ( ) ) ; if ( driver instanceof JavascriptExecutor ) { js = ( JavascriptExecutor ) driver ; } outerhtml = ( String ) js . executeScript ( "return-arguments[0].outerHTML;" , curWebElement ) ; } else { Logger . log ( getElementName ( ) + "-link-" + "is-null.-Hence-no-operation-can-be-performed-in-page-" + getPageName ( ) ) ; } return outerhtml ; } \n', 0.3435298682664102)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 30 #################################
('public void logHTMLContext ( String path ) { String source = getHtmlSource ( ) ; BufferedWriter writer = null ; try { writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( path ) ) ) ; writer . write ( source ) ; writer . flush ( ) ; } catch ( Exception e ) { throw new RuntimeException ( "Unable-to-save-HTML-body" , e ) ; } finally { try { writer . close ( ) ; } catch ( Exception e ) { } } } \n', 0.39967193479731933)

('public HtmlReporter ( Main client , File output ) throws IOException { super ( client , output ) ; mWriter = new BufferedWriter ( new FileWriter ( output ) ) ; } \n', 0.3995449554227901)

('public void dumpToHTMLFile ( File file ) throws IOException { PrintWriter w = new PrintWriter ( new FileWriter ( file ) ) ; w . println ( "<html><body>" ) ; w . println ( "<h1>List-of-all-artifacts</h1>" ) ; TreeSet < String > sortedSet = new TreeSet < String > ( ) ; sortedSet . addAll ( nodes . keySet ( ) ) ; for ( String path : sortedSet ) { w . println ( "<a-href="#" + path . replace ( \'/\' , \'_\' ) + "">" + path + "</a><br>" ) ; } w . println ( "<h1>Dependencies-per-artifact</h1>" ) ; for ( String path : nodes . keySet ( ) ) { w . println ( "<h2><a-name="" + path . replace ( \'/\' , \'_\' ) + "">" + path + "</a></h2>" ) ; INode n = nodes . get ( path ) ; w . println ( "<h3>Uses</h3>" ) ; for ( Link link : sortList ( n . getOutgoing ( ) ) ) { w . println ( "<a-href="#" + link . getTarget ( ) . getPath ( ) . replace ( \'/\' , \'_\' ) + "">" + link . getTarget ( ) . getPath ( ) + "</a><br>" ) ; } w . println ( "<h3>Used-by</h3>" ) ; for ( Link link : sortList ( n . getIncoming ( ) ) ) { w . println ( "<a-href="#" + link . getSource ( ) . getPath ( ) . replace ( \'/\' , \'_\' ) + "">" + link . getSource ( ) . getPath ( ) + "</a><br>" ) ; } } w . println ( "</body></html>" ) ; w . close ( ) ; } \n', 0.3952643947424098)

('public void saveHTMLFile ( String filename ) { tempfilename = filename ; Thread runner = new Thread ( ) { public void run ( ) { try { OutputStream out = new FileOutputStream ( tempfilename ) ; parentword . htmlkit . write ( out , parentword . dsd_stydoc , 0 , parentword . dsd_stydoc . getLength ( ) ) ; out . close ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } } ; runner . start ( ) ; } \n', 0.3936293349277132)

('public void generateHTMLReportFile ( String filename , int minImportance ) { try { PrintStream file = new PrintStream ( new FileOutputStream ( filename ) ) ; file . print ( getHTMLReportString ( ) ) ; file . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } \n', 0.3933323448281699)

('public static void endHTMLFile ( DataOutputStream writer , boolean include_text ) throws IOException { String section_end_rule = "<br>-<hr>-" ; String anchor_link = "<p><tt><a-href="#Top">-top-of-page-</a></tt></p>-" ; String end_tags = "</body>-</html>-" ; if ( include_text ) { writer . writeBytes ( section_end_rule ) ; writer . writeBytes ( anchor_link ) ; } writer . writeBytes ( end_tags ) ; writer . close ( ) ; } \n', 0.3917720662165949)

('public static void dumpToHtml ( File file , String dnaSequence , int frame ) throws Exception { BufferedWriter writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( "<html><body><pre>-" ) ; int currentPos = 0 ; for ( int x = frame ; x > 0 ; x -- ) { writer . write ( dnaSequence . charAt ( currentPos ) ) ; currentPos ++ ; } System . out . println ( currentPos ) ; writer . write ( "-" ) ; while ( currentPos < dnaSequence . length ( ) - 1 ) { writeProteinLine ( writer , dnaSequence , currentPos ) ; writeDnaLine ( writer , dnaSequence , currentPos ) ; currentPos += NUM_PROTEIN_RESIDUES_PER_LINE * 3 ; System . out . println ( currentPos ) ; writer . write ( "-" ) ; } writer . write ( "</pre></body></html>" ) ; writer . flush ( ) ; writer . close ( ) ; } \n', 0.38627560576235975)

('public HtmlReporter ( Main client , File output ) throws IOException { super ( client , output ) ; mWriter = new BufferedWriter ( Files . newWriter ( output , Charsets . UTF_8 ) ) ; } \n', 0.38607233498701937)

('public void logHtml ( String xmlFilename , String xslUri , String outFilename , String textFilename ) { logXml ( xmlFilename , xslUri ) ; File xmlFile = new File ( xmlFilename ) ; if ( xslUri == null || xmlFile . length ( ) > getMaxXmlConversionLength ( ) ) { logHtmlFromText ( textFilename , outFilename ) ; return ; } File xsltFile = new File ( xslUri ) ; Source xmlSource = new StreamSource ( xmlFile ) ; Source xsltSource = new StreamSource ( xsltFile ) ; try { TransformerFactory transFact = TransformerFactory . newInstance ( ) ; Transformer trans = transFact . newTransformer ( xsltSource ) ; PrintStream pout = null ; try { pout = new PrintStream ( new FileOutputStream ( outFilename ) ) ; trans . transform ( xmlSource , new StreamResult ( pout ) ) ; } catch ( Exception ex ) { this . err . println ( "Can\'t-open-output-file-" + outFilename ) ; logHtmlFromText ( textFilename , outFilename ) ; } finally { if ( pout != null ) { pout . close ( ) ; } } } catch ( Throwable e ) { logHtmlFromText ( textFilename , outFilename ) ; } } \n', 0.3842749330921675)

('public HTMLWriter ( File outputFile ) throws IOException { writer = new BufferedWriter ( new FileWriter ( outputFile ) ) ; start ( ) ; } \n', 0.3838952065843634)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 31 #################################
('public static String getCurrentIPAddress ( ) { String ipAddress ; ipAddress = "IP-address-not-available" ; try { InetAddress IP = InetAddress . getLocalHost ( ) ; ipAddress = IP . getHostAddress ( ) ; } catch ( UnknownHostException e ) { System . err . println ( e . getMessage ( ) ) ; } return ipAddress ; } \n', 0.3904638152124602)

('public static String getDefaultIPAddress ( ) { String address = "127.0.0.1" ; List < String > localAddresses = getLocalIPAddresses ( ) ; if ( localAddresses . size ( ) > 0 ) { address = localAddresses . get ( 0 ) ; } return address ; } \n', 0.38277236460476105)

('private static InetAddress getFloatingIpAddress ( Server server ) { Preconditions . checkNotNull ( server , "instance-is-null" ) ; InetAddress floatingIpAddress = null ; try { Iterator < Address > iterator = server . getAddresses ( ) . values ( ) . iterator ( ) ; Address floatingAddress = null ; while ( iterator . hasNext ( ) ) { Address address = iterator . next ( ) ; if ( address . getVersion ( ) == 4 ) { break ; } } while ( iterator . hasNext ( ) ) { floatingAddress = iterator . next ( ) ; if ( floatingAddress . getVersion ( ) == 4 ) { floatingIpAddress = InetAddress . getByName ( floatingAddress . getAddr ( ) ) ; break ; } } } catch ( UnknownHostException e ) { throw new IllegalArgumentException ( "Invalid-floating-IP-address" , e ) ; } return floatingIpAddress ; } \n', 0.37901534522061797)

('public static String getLocalIPAddress ( IPMode mode , Integer retry ) { try { for ( Enumeration < NetworkInterface > en = NetworkInterface . getNetworkInterfaces ( ) ; en . hasMoreElements ( ) ; ) { NetworkInterface intf = en . nextElement ( ) ; for ( Enumeration < InetAddress > enumIpAddr = intf . getInetAddresses ( ) ; enumIpAddr . hasMoreElements ( ) ; ) { InetAddress inetAddress = enumIpAddr . nextElement ( ) ; switch ( mode ) { case ipv4 : if ( ! inetAddress . isLoopbackAddress ( ) && InetAddressUtilsHC4 . isIPv4Address ( inetAddress . getHostAddress ( ) ) && intf . getName ( ) . toLowerCase ( ) . startsWith ( "wlan" ) ) { return inetAddress . getHostAddress ( ) ; } break ; case ipv6 : String address = inetAddress . getHostAddress ( ) ; if ( ! inetAddress . isLoopbackAddress ( ) && ( InetAddressUtilsHC4 . isIPv6Address ( address ) || InetAddressUtilsHC4 . isIPv6HexCompressedAddress ( address ) || InetAddressUtilsHC4 . isIPv6StdAddress ( address ) ) ) { return inetAddress . getHostAddress ( ) ; } break ; } } } } catch ( SocketException ex ) { Log . e ( "GetIP" , ex . toString ( ) ) ; } catch ( Exception e ) { Log . e ( "GetIP" , e . toString ( ) ) ; return getLocalIPAddress ( mode , -- retry ) ; } return null ; } \n', 0.3780785425569024)

('private String getCurrentEnvironmentNetworkIp ( ) { if ( currentHostIpAddress == null ) { Enumeration < NetworkInterface > netInterfaces = null ; try { netInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; while ( netInterfaces . hasMoreElements ( ) ) { NetworkInterface ni = netInterfaces . nextElement ( ) ; Enumeration < InetAddress > address = ni . getInetAddresses ( ) ; while ( address . hasMoreElements ( ) ) { InetAddress addr = address . nextElement ( ) ; if ( ! addr . isLoopbackAddress ( ) && addr . isSiteLocalAddress ( ) && ! ( addr . getHostAddress ( ) . indexOf ( ":" ) > - 1 ) ) { currentHostIpAddress = addr . getHostAddress ( ) ; byte [ ] mac = ni . getHardwareAddress ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < mac . length ; i ++ ) { sb . append ( String . format ( "%02X%s" , mac [ i ] , ( i < mac . length - 1 ) ? "-" : "" ) ) ; } deviceID = sb . toString ( ) ; break ; } } } if ( currentHostIpAddress == null ) { currentHostIpAddress = "127.0.0.1" ; } } catch ( SocketException e ) { currentHostIpAddress = "127.0.0.1" ; } } return currentHostIpAddress ; } \n', 0.3729703365217987)

('public static String getLocalIPAddress ( ) { try { for ( Enumeration < NetworkInterface > en = NetworkInterface . getNetworkInterfaces ( ) ; en . hasMoreElements ( ) ; ) { NetworkInterface intf = en . nextElement ( ) ; for ( Enumeration < InetAddress > enumIpAddr = intf . getInetAddresses ( ) ; enumIpAddr . hasMoreElements ( ) ; ) { InetAddress inetAddress = enumIpAddr . nextElement ( ) ; String iface = intf . getName ( ) ; if ( iface . matches ( ".*" + p2pInt + ".*" ) ) { if ( inetAddress instanceof Inet4Address ) { return getDottedDecimalIP ( inetAddress . getAddress ( ) ) ; } } } } } catch ( SocketException ex ) { Log . e ( "AndroidNetworkAddressFactory" , "getLocalIPAddress()" , ex ) ; } catch ( NullPointerException ex ) { Log . e ( "AndroidNetworkAddressFactory" , "getLocalIPAddress()" , ex ) ; } return null ; } \n', 0.3728701989787586)

('public String getLocalIpAddress ( ) { logger . trace ( "Thread-<{}>::getLocalIpAddress" , Thread . currentThread ( ) . getId ( ) ) ; try { for ( Enumeration < NetworkInterface > en = NetworkInterface . getNetworkInterfaces ( ) ; en . hasMoreElements ( ) ; ) { NetworkInterface intf = en . nextElement ( ) ; for ( Enumeration < InetAddress > enumIpAddr = intf . getInetAddresses ( ) ; enumIpAddr . hasMoreElements ( ) ; ) { InetAddress inetAddress = enumIpAddr . nextElement ( ) ; if ( ! inetAddress . isLoopbackAddress ( ) ) { return inetAddress . getHostAddress ( ) . toString ( ) ; } } } } catch ( SocketException ex ) { logger . error ( "get-local-IP-address" , ex ) ; } return null ; } \n', 0.3721857204715544)

('public String getApIp ( long timeout ) { long until = System . currentTimeMillis ( ) + timeout ; String ip ; while ( ( ip = Utils . getLocalIpAddress ( ) ) == null && System . currentTimeMillis ( ) < until ) { try { Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } return ip ; } \n', 0.3721617040058005)

('public static String getGPRSLocalIPAddress ( ) { try { Enumeration < NetworkInterface > en = NetworkInterface . getNetworkInterfaces ( ) ; while ( en . hasMoreElements ( ) ) { NetworkInterface nif = en . nextElement ( ) ; Enumeration < InetAddress > enumIpAddr = nif . getInetAddresses ( ) ; while ( enumIpAddr . hasMoreElements ( ) ) { InetAddress mInetAddress = enumIpAddr . nextElement ( ) ; if ( ! mInetAddress . isLoopbackAddress ( ) && InetAddressUtils . isIPv4Address ( mInetAddress . getHostAddress ( ) ) ) { return mInetAddress . getHostAddress ( ) ; } } } } catch ( SocketException e ) { e . printStackTrace ( ) ; } return null ; } \n', 0.3717470770178134)

('public static String getLocalIpAddressForRds ( ) { if ( myLocalIp == null ) { try { for ( Enumeration < NetworkInterface > en = NetworkInterface . getNetworkInterfaces ( ) ; en . hasMoreElements ( ) ; ) { NetworkInterface intf = en . nextElement ( ) ; for ( Enumeration < InetAddress > enumIpAddr = intf . getInetAddresses ( ) ; enumIpAddr . hasMoreElements ( ) ; ) { InetAddress inetAddress = enumIpAddr . nextElement ( ) ; if ( ! inetAddress . isLoopbackAddress ( ) && ! inetAddress . getHostAddress ( ) . contains ( ":" ) ) { myLocalIp = inetAddress . getHostAddress ( ) ; return myLocalIp ; } } } } catch ( SocketException ex ) { Log . e ( "ResourceAgent" , ex . getMessage ( ) ) ; } } return myLocalIp ; } \n', 0.37079694555378795)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 32 #################################
('public static int levenshteinSimilarity ( String compareString1 , String compareString2 , int minPercent ) { int dlw = getLevenshteinDistance ( compareString1 , compareString2 , minPercent ) ; if ( ( minPercent > - 1 ) && ( dlw == - 1 ) ) return 0 ; int maxlwlm = Math . max ( compareString1 . length ( ) , compareString2 . length ( ) ) ; int percent = 100 ; if ( maxlwlm > 0 ) { percent = 100 - ( dlw * 100 ) / maxlwlm ; if ( percent >= 100 ) { percent = 100 ; if ( ! compareString1 . equals ( compareString2 ) ) percent = percent - 1 ; } else if ( percent < 0 ) { percent = 0 ; } } return percent ; } \n', 0.4052618261405815)

('private void evaluateByCosineSimilarity ( ) { ArrayList < EvaluateResult > resultList = new ArrayList < EvaluateResult > ( ) ; int qid ; int rel ; String docSten = "" ; HashMap < String , Integer > doctokenMap ; HashMap < String , Integer > qryTokenMap ; double score ; for ( int i = 0 ; i < qIdList . size ( ) ; i ++ ) { qid = qIdList . get ( i ) ; rel = relList . get ( i ) ; doctokenMap = tokMapList . get ( i ) ; docSten = strList . get ( i ) ; if ( rel != 99 ) { qryTokenMap = tokMapList . get ( getQrySentIndex ( qid ) ) ; score = computeCosineSimilarity ( qryTokenMap , doctokenMap ) ; EvaluateResult docResult = new EvaluateResult ( ) ; docResult . qid = qid ; docResult . rel = rel ; docResult . score = score ; docResult . sentence = docSten ; resultList . add ( docResult ) ; } } sortAndPrintResult ( resultList ) ; } \n', 0.39114900246594875)

('public double similarity ( StringRef stringRef1 , StringRef stringRef2 ) { double length1 = stringRef1 . length ; double length2 = stringRef2 . length ; HashMapVector v1 = stringRef1 . vector ; HashMapVector v2 = stringRef2 . vector ; double similarity = 0 ; if ( length1 == 0 || length2 == 0 ) { return 0 ; } Iterator mapEntries = v1 . iterator ( ) ; while ( mapEntries . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) mapEntries . next ( ) ; String token = ( String ) entry . getKey ( ) ; if ( v2 . hashMap . containsKey ( token ) ) { double count1 = ( ( Weight ) entry . getValue ( ) ) . getValue ( ) ; double count2 = ( ( Weight ) v2 . hashMap . get ( token ) ) . getValue ( ) ; TokenInfo tokenInfo = m_tokenInfoMap . get ( token ) ; if ( tokenInfo != null ) { double increment = count1 * count2 ; if ( m_useIDF ) { increment *= tokenInfo . idf * tokenInfo . idf ; } similarity += increment ; } } } similarity /= length1 * length2 ; return similarity ; } \n', 0.38298104986865705)

('public static int stringSimilarity ( String str ) { char [ ] charArr = str . toCharArray ( ) ; int length = charArr . length ; int sum = length ; for ( int i = 1 ; i < length ; i ++ ) { int similarity = 0 ; for ( ; similarity < length - i ; similarity ++ ) if ( charArr [ similarity ] != charArr [ similarity + i ] ) { break ; } sum += similarity ; } return sum ; } \n', 0.3782002166733061)

('public static int levenshteinWordBasedSimilarity ( String compareString1 , String compareString2 , int minPercent ) { if ( compareString1 == null ) return 0 ; if ( compareString2 == null ) return 0 ; compareString1 = compareString1 . trim ( ) ; compareString2 = compareString2 . trim ( ) ; if ( compareString1 . equals ( "" ) ) return 0 ; if ( compareString2 . equals ( "" ) ) return 0 ; String splitchars = "[|s+" + Pattern . quote ( ";!|.-()]+*[]{}" ) + "]+" ; String [ ] compareString1Tokens = compareString1 . split ( splitchars ) ; String [ ] compareString2Tokens = compareString2 . split ( splitchars ) ; Hashtable < String , String > wordtable = new Hashtable < String , String > ( ) ; String cs1 = "" ; String cs2 = "" ; char startChar = \'a\' ; for ( int i = 0 ; i < compareString1Tokens . length ; i ++ ) { if ( wordtable . containsKey ( compareString1Tokens [ i ] ) ) { cs1 = cs1 + wordtable . get ( compareString1Tokens [ i ] ) ; } else { cs1 = cs1 + startChar ; wordtable . put ( compareString1Tokens [ i ] , startChar + "" ) ; startChar ++ ; } } for ( int i = 0 ; i < compareString2Tokens . length ; i ++ ) { if ( wordtable . containsKey ( compareString2Tokens [ i ] ) ) { cs2 = cs2 + wordtable . get ( compareString2Tokens [ i ] ) ; } else { cs2 = cs2 + startChar ; wordtable . put ( compareString2Tokens [ i ] , startChar + "" ) ; startChar ++ ; } } return levenshteinSimilarity ( cs1 , cs2 , minPercent ) ; } \n', 0.3753201481200311)

('public static double computeJaccardSimilarity ( String doc1 , String doc2 ) { String [ ] docOneTerms = doc1 . toLowerCase ( ) . split ( "[^A-Za-z0-9]" ) ; List < String > termList = new ArrayList < String > ( Arrays . asList ( docOneTerms ) ) ; termList . removeAll ( Arrays . asList ( "" , null ) ) ; Set < String > docOneBag = new HashSet < String > ( termList ) ; String [ ] docTwoTerms = doc2 . toLowerCase ( ) . split ( "[^A-Za-z0-9]" ) ; termList = new ArrayList < String > ( Arrays . asList ( docTwoTerms ) ) ; termList . removeAll ( Arrays . asList ( "" , null ) ) ; Set < String > docTwoBag = new HashSet < String > ( termList ) ; return computeJaccardSimilarity ( docOneBag , docTwoBag ) ; } \n', 0.3676158113872383)

('public double cosSimilarity ( Document doc1 , Document doc2 ) { String word ; double similarity = 0 ; for ( Iterator < String > it = doc1 . words . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { word = it . next ( ) ; if ( doc2 . words . containsKey ( word ) ) { similarity += doc1 . words . get ( word ) [ 2 ] * doc2 . words . get ( word ) [ 2 ] ; } } similarity = similarity / ( doc1 . vectorlength * doc2 . vectorlength ) ; return similarity ; } \n', 0.3661470367112355)

('public float getSimilarity ( final String pFirst , @ Nonnull final String pSecond ) { checkNotNull ( pFirst ) ; checkNotNull ( pSecond ) ; if ( pFirst == pSecond || pFirst . equals ( pSecond ) ) { return 1f ; } final int firstLength = pFirst . length ( ) ; final int secondLength = pSecond . length ( ) ; if ( firstLength > MAX | secondLength > MAX | firstLength < MIN | secondLength < MIN ) { if ( pFirst . equals ( pSecond ) ) { return 1f ; } else { return 0f ; } } final float levenshteinDistance = getUnNormalisedSimilarity ( pFirst , pSecond ) ; final float maxLen = firstLength > secondLength ? firstLength : secondLength ; final float norm = 1f - ( levenshteinDistance / maxLen ) ; assert norm >= 0f && norm <= 1f ; return norm ; } \n', 0.36537373233957293)

('public static double getSimilarity ( final List < String > strings1 , final List < String > strings2 ) { if ( strings1 . isEmpty ( ) && strings2 . isEmpty ( ) ) { return 1.0 ; } final int minListSize = Math . min ( strings1 . size ( ) , strings2 . size ( ) ) ; final List < String > longestList = strings1 . size ( ) > minListSize ? strings1 : strings2 ; final int extraStringLengths = countExtraStringLengths ( longestList , minListSize ) ; int cumulativeLevDistance = 0 ; int cumulativeMaxDistance = 0 ; for ( int i = 0 ; i < minListSize ; i ++ ) { final String string1 = strings1 . get ( i ) ; final String string2 = strings2 . get ( i ) ; String [ ] tokens1 = tokenise ( string1 ) ; String [ ] tokens2 = tokenise ( string2 ) ; final int levenshteinDistance = getLevenshteinDistanceInWords ( tokens1 , tokens2 ) ; cumulativeLevDistance += levenshteinDistance ; cumulativeMaxDistance += Math . max ( tokens1 . length , tokens2 . length ) ; } final int totalLevDistance = cumulativeLevDistance + extraStringLengths ; final int totalMaxDistance = cumulativeMaxDistance + extraStringLengths ; if ( totalMaxDistance == 0 ) { return 0.0 ; } return ( totalMaxDistance - totalLevDistance ) / ( double ) totalMaxDistance ; } \n', 0.3604842378955983)

('public double similarity ( InstanceReference iRef1 , InstanceReference iRef2 ) { double length1 = iRef1 . length ; double length2 = iRef1 . length ; HashMapVector v1 = iRef1 . vector ; HashMapVector v2 = iRef2 . vector ; double similarity = 0 ; if ( length1 == 0 || length2 == 0 ) { return 0 ; } Iterator mapEntries = v1 . iterator ( ) ; while ( mapEntries . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) mapEntries . next ( ) ; String token = ( String ) entry . getKey ( ) ; if ( v2 . hashMap . containsKey ( token ) ) { double count1 = ( ( Weight ) entry . getValue ( ) ) . getValue ( ) ; double count2 = ( ( Weight ) v2 . hashMap . get ( token ) ) . getValue ( ) ; TokenInfo tokenInfo = ( TokenInfo ) m_tokenHash . get ( token ) ; if ( tokenInfo != null ) { double increment = count1 * count2 ; if ( m_useIDF ) { increment *= tokenInfo . idf * tokenInfo . idf ; } similarity += increment ; } } } similarity /= length1 * length2 ; return similarity ; } \n', 0.3555641548408608)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 33 #################################
('public void computeDistribution ( ) throws IOException { computeDistribution ( EmpiricalDistributionImpl . DEFAULT_BIN_COUNT ) ; } \n', 0.3835667312988993)

('public int nextBinomial ( int numberOfTrials , double probabilityOfSuccess ) { return new BinomialDistribution ( getRandomGenerator ( ) , numberOfTrials , probabilityOfSuccess ) . sample ( ) ; } \n', 0.3834891603205558)

('public static double log10BinomialProbability ( final int n , final int k , final double log10p ) { if ( log10p > 1e-18 ) throw new IllegalArgumentException ( "log10p:-Log-probability-must-be-0-or-less" ) ; double log10OneMinusP = Math . log10 ( 1 - Math . pow ( 10 , log10p ) ) ; return log10BinomialCoefficient ( n , k ) + log10p * k + log10OneMinusP * ( n - k ) ; } \n', 0.3805805373510208)

('public static double binomialProbability ( int n , int k , double p ) { return Math . pow ( 10 , log10BinomialProbability ( n , k , Math . log10 ( p ) ) ) ; } \n', 0.3759102551077473)

('public static double binomialProbability ( final int n , final int k , final double p ) { return Math . pow ( 10 , log10BinomialProbability ( n , k , Math . log10 ( p ) ) ) ; } \n', 0.3759102551077473)

('public double [ ] distributionForInstance ( Instance inst ) throws Exception { double [ ] result = new double [ 2 ] ; if ( m_replaceMissing != null ) { m_replaceMissing . input ( inst ) ; inst = m_replaceMissing . output ( ) ; } if ( m_nominalToBinary != null ) { m_nominalToBinary . input ( inst ) ; inst = m_nominalToBinary . output ( ) ; } if ( m_normalize != null ) { m_normalize . input ( inst ) ; inst = m_normalize . output ( ) ; } double wx = dotProd ( inst , m_weights , inst . classIndex ( ) ) ; double z = ( wx + m_weights [ m_weights . length - 1 ] ) ; if ( z <= 0 ) { if ( m_loss == LOGLOSS ) { result [ 0 ] = 1.0 / ( 1.0 + Math . exp ( z ) ) ; result [ 1 ] = 1.0 - result [ 0 ] ; } else { result [ 0 ] = 1 ; } } else { if ( m_loss == LOGLOSS ) { result [ 1 ] = 1.0 / ( 1.0 + Math . exp ( - z ) ) ; result [ 0 ] = 1.0 - result [ 1 ] ; } else { result [ 1 ] = 1 ; } } return result ; } \n', 0.3756459099780087)

('public static final double binomialDistribution ( double accuracy , double ruleCount , double premiseCount ) { double mu , sigma ; if ( premiseCount < MAX_N ) return Math . pow ( 2 , ( Utils . log2 ( Math . pow ( accuracy , ruleCount ) ) + Utils . log2 ( Math . pow ( ( 1.0 - accuracy ) , ( premiseCount - ruleCount ) ) ) + PriorEstimation . logbinomialCoefficient ( ( int ) premiseCount , ( int ) ruleCount ) ) ) ; else { mu = premiseCount * accuracy ; sigma = Math . sqrt ( ( premiseCount * ( 1.0 - accuracy ) ) * accuracy ) ; return Statistics . normalProbability ( ( ( ruleCount + 0.5 ) - mu ) / ( sigma * Math . sqrt ( 2 ) ) ) ; } } \n', 0.3714970856348991)

('public double [ ] distributionForInstance ( Instance instance ) throws Exception { double [ ] probOfClassGivenDoc = new double [ m_numClasses ] ; double [ ] logDocGivenClass = new double [ m_numClasses ] ; for ( int h = 0 ; h < m_numClasses ; h ++ ) logDocGivenClass [ h ] = probOfDocGivenClass ( instance , h ) ; double max = logDocGivenClass [ Utils . maxIndex ( logDocGivenClass ) ] ; double probOfDoc = 0.0 ; for ( int i = 0 ; i < m_numClasses ; i ++ ) { probOfClassGivenDoc [ i ] = Math . exp ( logDocGivenClass [ i ] - max ) * m_probOfClass [ i ] ; probOfDoc += probOfClassGivenDoc [ i ] ; } Utils . normalize ( probOfClassGivenDoc , probOfDoc ) ; return probOfClassGivenDoc ; } \n', 0.37139365107590905)

('protected double [ ] distributionForInstanceMajorityVoting ( Instance instance ) throws Exception { double [ ] probs = new double [ instance . classAttribute ( ) . numValues ( ) ] ; double [ ] votes = new double [ probs . length ] ; for ( int i = 0 ; i < m_Classifiers . length ; i ++ ) { probs = getClassifier ( i ) . distributionForInstance ( instance ) ; int maxIndex = 0 ; for ( int j = 0 ; j < probs . length ; j ++ ) { if ( probs [ j ] > probs [ maxIndex ] ) maxIndex = j ; } for ( int j = 0 ; j < probs . length ; j ++ ) { if ( probs [ j ] == probs [ maxIndex ] ) votes [ j ] ++ ; } } int tmpMajorityIndex = 0 ; for ( int k = 1 ; k < votes . length ; k ++ ) { if ( votes [ k ] > votes [ tmpMajorityIndex ] ) tmpMajorityIndex = k ; } Vector < Integer > majorityIndexes = new Vector < Integer > ( ) ; for ( int k = 0 ; k < votes . length ; k ++ ) { if ( votes [ k ] == votes [ tmpMajorityIndex ] ) majorityIndexes . add ( k ) ; } int majorityIndex = majorityIndexes . get ( m_Random . nextInt ( majorityIndexes . size ( ) ) ) ; for ( int k = 0 ; k < probs . length ; k ++ ) probs [ k ] = 0 ; probs [ majorityIndex ] = 1 ; return probs ; } \n', 0.36379482085357623)

('public double [ ] distributionForInstance ( Instance inst ) throws Exception { double [ ] result = ( inst . classAttribute ( ) . isNominal ( ) ) ? new double [ 2 ] : new double [ 1 ] ; if ( m_replaceMissing != null ) { m_replaceMissing . input ( inst ) ; inst = m_replaceMissing . output ( ) ; } if ( m_nominalToBinary != null ) { m_nominalToBinary . input ( inst ) ; inst = m_nominalToBinary . output ( ) ; } if ( m_normalize != null ) { m_normalize . input ( inst ) ; inst = m_normalize . output ( ) ; } double wx = dotProd ( inst , m_weights , inst . classIndex ( ) ) ; double z = ( wx + m_weights [ m_weights . length - 1 ] ) ; if ( inst . classAttribute ( ) . isNumeric ( ) ) { result [ 0 ] = z ; return result ; } if ( z <= 0 ) { if ( m_loss == LOGLOSS ) { result [ 0 ] = 1.0 / ( 1.0 + Math . exp ( z ) ) ; result [ 1 ] = 1.0 - result [ 0 ] ; } else { result [ 0 ] = 1 ; } } else { if ( m_loss == LOGLOSS ) { result [ 1 ] = 1.0 / ( 1.0 + Math . exp ( - z ) ) ; result [ 0 ] = 1.0 - result [ 1 ] ; } else { result [ 1 ] = 1 ; } } return result ; } \n', 0.3631227727196545)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 34 #################################
('private void writeCSV ( String value , OutputStreamWriter w ) throws IOException { w . append ( value + ";" ) ; } \n', 0.39220637127913405)

('private void writeCSV ( String div ) { dataCSV csv ; int nivel = 0 ; csv = ( dataCSV ) csvData . elementAt ( 0 ) ; nivel = csv . data . size ( ) ; for ( int i = 1 ; i < csvData . size ( ) ; i ++ ) { csv = ( dataCSV ) csvData . elementAt ( i ) ; if ( csv . data . size ( ) > nivel ) { nivel = csv . data . size ( ) ; } } for ( int i = 0 ; i < csvData . size ( ) ; i ++ ) { csv = ( dataCSV ) csvData . elementAt ( i ) ; for ( int j = csv . data . size ( ) ; j < nivel ; j ++ ) { if ( csv . parent ) csv . data . addElement ( csv . data . elementAt ( 0 ) ) ; else csv . data . addElement ( "" ) ; } } String data ; int i ; if ( nivel > 1 ) i = 1 ; else i = 0 ; for ( ; i < nivel ; i ++ ) { for ( int j = 0 ; j < csvData . size ( ) ; j ++ ) { csv = ( dataCSV ) csvData . elementAt ( j ) ; data = ( String ) csv . data . elementAt ( i ) ; sb . append ( """ ) . append ( data ) . append ( """ ) . append ( div ) ; } sb . append ( "-" ) ; } } \n', 0.39163111143393403)

('public void writeCsv ( ConsoleTable table , PrintWriter writer ) { OutputStream os = new WriterOutputStream ( writer ) ; PrintStream ps = new PrintStream ( os ) ; try { writeCsv ( table , ps ) ; } finally { ps . close ( ) ; } } \n', 0.38846976505952546)

('public void saveCSVConfig ( final OutputStream out ) throws IOException { final OutputStreamWriter writer = new OutputStreamWriter ( out ) ; final CsvWriter csv = new CsvWriter ( ) ; try { final Enumeration keys = params . keys ( ) ; final Enumeration values = params . elements ( ) ; while ( keys . hasMoreElements ( ) ) { final String key = ( String ) keys . nextElement ( ) ; final String value = ( String ) values . nextElement ( ) ; csv . append ( key ) ; csv . append ( value ) ; csv . nl ( ) ; writer . write ( csv . toString ( ) ) ; csv . reset ( ) ; } } finally { writer . close ( ) ; out . close ( ) ; } } \n', 0.3874548523264726)

('private static void writeCSV ( String table , HashMap < String , ArrayList < String >> data , String output ) throws Exception { int max = 0 ; for ( String key : data . keySet ( ) ) { int size = data . get ( key ) . size ( ) ; if ( size > max ) max = size ; } StringBuilder s = new StringBuilder ( ) ; for ( String key : data . keySet ( ) ) { s . append ( key ) ; s . append ( ";" ) ; } s . append ( "-" ) ; for ( int i = 0 ; i < max ; i ++ ) { for ( String key : data . keySet ( ) ) { if ( data . get ( key ) . size ( ) > i ) { s . append ( data . get ( key ) . get ( i ) ) ; } else { s . append ( "%empty%" ) ; } s . append ( ";" ) ; } s . append ( "-" ) ; } FileWriter fw = new FileWriter ( output + table + ".csv" ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( s . toString ( ) ) ; bw . close ( ) ; } \n', 0.38683860103531653)

('public void writeCSV ( Writer writer , String columnDelimiter , String rowDelimiter ) throws IOException { for ( K k : getItems ( ) ) { writer . write ( k . toString ( ) ) ; writer . write ( columnDelimiter ) ; writer . write ( acc . get ( k ) . toString ( ) ) ; writer . write ( rowDelimiter ) ; } } \n', 0.3868236753386918)

('public StringBuilder writeCsv ( LinkedHashMap < String , List < String >> csvMap ) { StringBuilder sb = new StringBuilder ( ) ; int nrOfRows = 0 ; for ( String header : csvMap . keySet ( ) ) { nrOfRows = csvMap . get ( header ) . size ( ) ; sb . append ( header ) ; sb . append ( "," ) ; } sb . setLength ( sb . length ( ) - 1 ) ; sb . append ( "-" ) ; for ( int row = 0 ; row < nrOfRows ; row ++ ) { for ( String header : csvMap . keySet ( ) ) { sb . append ( csvMap . get ( header ) . get ( row ) ) ; sb . append ( "," ) ; } sb . setLength ( sb . length ( ) - 1 ) ; sb . append ( "-" ) ; } return sb ; } \n', 0.3837516138978032)

('private void writeCSV ( ResultSet rs , PrintWriter writer ) throws SQLException { ResultSetMetaData meta = rs . getMetaData ( ) ; int columns = meta . getColumnCount ( ) + 1 ; StringBuffer line = new StringBuffer ( ) ; String item ; for ( int i = 1 ; i < columns ; i ++ ) { if ( i != 1 ) { line . append ( ",-" ) ; } line . append ( meta . getColumnName ( i ) ) ; } writer . println ( line . toString ( ) ) ; while ( rs . next ( ) ) { line = new StringBuffer ( ) ; for ( int i = 1 ; i < columns ; i ++ ) { item = rs . getString ( i ) ; if ( i != 1 ) { line . append ( ",-" ) ; } if ( item != null ) { line . append ( item ) ; } } writer . println ( line . toString ( ) ) ; } } \n', 0.37947071595943155)

('public void saveCSV ( OutputStream out , Charset cs , List < UJO > ujoList , Object context ) throws IOException , InstantiationException , IllegalAccessException { final Writer writer = new OutputStreamWriter ( out , cs != null ? cs : UTF_8 ) ; try { saveCSV ( writer , ujoList , context ) ; } finally { writer . close ( ) ; } } \n', 0.37751844472317647)

('protected void writeCsv ( OutputStream out , DataProcessor dp , DateFormat exportDateFormat ) throws IOException { String sources [ ] = dp . getSourceNames ( ) ; StringBuilder sourcesline = new StringBuilder ( ) ; sourcesline . append ( "Date," ) ; for ( String name : sources ) { if ( ! name . startsWith ( "rev_" ) ) sourcesline . append ( name ) . append ( "," ) ; } sourcesline . deleteCharAt ( sourcesline . length ( ) - 1 ) ; sourcesline . append ( "-" ) ; out . write ( sourcesline . toString ( ) . getBytes ( ) ) ; double [ ] [ ] values = dp . getValues ( ) ; long [ ] ts = dp . getTimestamps ( ) ; for ( int i = 0 ; i < ts . length ; i ++ ) { sourcesline . setLength ( 0 ) ; sourcesline . append ( exportDateFormat . format ( org . rrd4j . core . Util . getDate ( ts [ i ] ) ) ) . append ( "," ) ; for ( int j = 0 ; j < sources . length ; j ++ ) { if ( ! sources [ j ] . startsWith ( "rev_" ) ) sourcesline . append ( values [ j ] [ i ] ) . append ( "," ) ; } sourcesline . deleteCharAt ( sourcesline . length ( ) - 1 ) ; sourcesline . append ( "-" ) ; out . write ( sourcesline . toString ( ) . getBytes ( ) ) ; } } \n', 0.3750451990348691)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 35 #################################
('private void checkAll ( boolean checked ) { searchEnginesCheckboxListener . enable ( false ) ; for ( JCheckBox cBox : searchEngineCheckboxes ) { cBox . setSelected ( checked ) ; cBoxes . get ( cBox ) . setValue ( cBox . isSelected ( ) ) ; } searchEnginesCheckboxListener . enable ( true ) ; if ( ! checked ) { searchEngineCheckboxes . get ( 0 ) . setSelected ( true ) ; } } \n', 0.39119113923151666)

('public static JCheckBox checkbox ( String text , final PropertyChangeBean bean , final String property ) { final JCheckBox checkbox = new JCheckBox ( text ) ; bean . addPropertyChangeListener ( property , new PropertyChangeListener ( ) { @ Override public void propertyChange ( PropertyChangeEvent evt ) { checkbox . setSelected ( ( boolean ) evt . getNewValue ( ) ) ; } } ) ; checkbox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { ReflectionUtils . setValue ( bean , property , checkbox . isSelected ( ) ) ; } } ) ; return checkbox ; } \n', 0.3860983005918478)

('@ SuppressWarnings ( "unchecked" ) default boolean isChecked ( Supplier < By > selector ) { return new Checkbox < > ( ( T ) this , selector ) . isChecked ( ) ; } \n', 0.37809268689644926)

('public void checkForAllSelections ( ) { JCheckBox masterCheckbox = getMasterCheckbox ( ) ; if ( isAllSelected ( ) ) { if ( ! masterCheckbox . isSelected ( ) ) { masterCheckbox . setSelected ( true ) ; } } else { if ( masterCheckbox . isSelected ( ) ) { masterCheckbox . setSelected ( false ) ; } } } \n', 0.3721905150105631)

('public boolean isCheckboxSet ( ) { return checkbox . getSelection ( ) ; } \n', 0.3662414467241962)

('public Checkbox ( String label , boolean state ) throws HeadlessException { this ( label , state , null ) ; } \n', 0.3635988032145001)

('public Checkbox ( String label , CheckboxGroup group , boolean state ) throws HeadlessException { this ( label , state , group ) ; } \n', 0.361998155350282)

('public Checkbox ( ) throws HeadlessException { this ( "" , false , null ) ; } \n', 0.3605021347291407)

('public boolean isCheckboxChecked ( ) { return _checkbox . isSelected ( ) ; } \n', 0.3601055874084005)

('public Checkbox ( String label ) throws HeadlessException { this ( label , false , null ) ; } \n', 0.3580427617831895)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 36 #################################
('protected Label addLabel ( Composite parent , String label , int indentation ) { Label labelWidget = new Label ( parent , SWT . None ) ; labelWidget . setText ( label ) ; GridData gd = new GridData ( GridData . HORIZONTAL_ALIGN_BEGINNING ) ; gd . horizontalIndent = indentation ; gd . horizontalSpan = 2 ; labelWidget . setLayoutData ( gd ) ; return labelWidget ; } \n', 0.3814926365388429)

('public Label getLabelControl ( Composite parent ) { if ( label == null ) { label = new Label ( parent , SWT . LEFT ) ; label . setFont ( parent . getFont ( ) ) ; String text = getLabelText ( ) ; if ( text != null ) { label . setText ( text ) ; } label . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { label = null ; } } ) ; } else { checkParent ( label , parent ) ; } return label ; } \n', 0.37696314698653777)

('@ Override public Label getLabelControl ( Composite parent ) { if ( myLabel == null ) { myLabel = new Label ( parent , SWT . LEFT | SWT . WRAP ) ; myLabel . setFont ( parent . getFont ( ) ) ; String text = getLabelText ( ) ; if ( text != null ) { myLabel . setText ( text ) ; } myLabel . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { myLabel = null ; } } ) ; } else { checkParent ( myLabel , parent ) ; } return myLabel ; } \n', 0.37584921973272173)

('public void setLabel ( String text ) { ( ( Label ) ( getWidget ( 0 ) ) ) . setText ( text ) ; } \n', 0.36727124184764437)

('void setLabel ( String label ) { ( ( Label ) this . canvas . getWidget ( 1 , 1 ) ) . setText ( label ) ; } \n', 0.3646346247521117)

('public static void makeLinkedLabel ( Label label , String hyperlink ) { label . setData ( hyperlink ) ; String tooltip = label . getToolTipText ( ) ; if ( tooltip == null && ! hyperlink . equals ( label . getText ( ) ) ) { label . setToolTipText ( hyperlink == null ? null : hyperlink . replaceAll ( "&" , "&&" ) ) ; } label . setCursor ( label . getDisplay ( ) . getSystemCursor ( SWT . CURSOR_HAND ) ) ; label . setForeground ( Colors . blue ) ; label . addMouseListener ( new MouseAdapter ( ) { public void mouseDoubleClick ( MouseEvent arg0 ) { Utils . launch ( ( String ) ( ( Label ) arg0 . widget ) . getData ( ) ) ; } public void mouseUp ( MouseEvent arg0 ) { Utils . launch ( ( String ) ( ( Label ) arg0 . widget ) . getData ( ) ) ; } } ) ; } \n', 0.35798825489008806)

('public static String extractWidgetLabel ( Component widget ) { String label = null ; if ( widget instanceof AbstractButton ) { label = ( ( AbstractButton ) widget ) . getText ( ) ; if ( label == null ) label = "" ; } return label ; } \n', 0.35765075012538367)

('void initLabel ( String label ) { formattedLabel = new AttributedString ( label ) ; formattedLabel . addAttribute ( TextAttribute . FONT , comDiaView . getFont ( ) ) ; formattedLabel . addAttribute ( TextAttribute . UNDERLINE , TextAttribute . UNDERLINE_ON ) ; } \n', 0.3574061125474781)

('public void setMandatoryLabel ( final String mandatoryLabel ) { mandatoryWidget . setText ( mandatoryLabel ) ; } \n', 0.3543897618419066)

('private Label createLabel ( Composite parent , String text , int style ) { Label label ; if ( widgetFactory == null ) { label = new Label ( parent , SWT . PUSH ) ; label . setText ( text ) ; } else { label = widgetFactory . createLabel ( parent , text , style ) ; } return label ; } \n', 0.34910798098942725)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 37 #################################
('public static int convertToNumber ( String str , int fallback ) { try { if ( StringUtils . isEmpty ( str ) ) { return fallback ; } return Integer . valueOf ( str . trim ( ) ) ; } catch ( NumberFormatException ex ) { LOGGER . error ( "Could-not-parse-string-{}-as-number" , str , ex ) ; return fallback ; } } \n', 0.4172186775606706)

('private Number convertStringToNumber ( String strValue ) { Number value = null ; try { if ( StringUtils . hasText ( strValue ) ) { if ( strValue . indexOf ( "." ) > 0 ) { value = Double . valueOf ( strValue ) ; } else { value = Long . valueOf ( strValue ) ; } } } catch ( NumberFormatException ne ) { value = null ; } return value ; } \n', 0.41008809922380574)

('public static String convertNumberToFriendlyString ( long number ) { int numDigits = String . valueOf ( number ) . length ( ) ; int numDigitsLeftover = numDigits % 3 ; if ( numDigitsLeftover == 0 ) { numDigitsLeftover = 3 ; } int precision = 4 - numDigitsLeftover ; return convertNumberToFriendlyString ( number , precision ) ; } \n', 0.40835450164816467)

('public static int convertStringToInteger ( String number , int defaultValue ) { try { return Integer . parseInt ( number ) ; } catch ( Exception e ) { } return defaultValue ; } \n', 0.3987867870175923)

('public static int [ ] convertStringToInt ( String [ ] numbers ) { int [ ] intArr = new int [ numbers . length ] ; for ( int index = 0 ; index < numbers . length ; index ++ ) { int number = Integer . parseInt ( numbers [ index ] ) ; intArr [ index ] = number ; } return intArr ; } \n', 0.39475773951862786)

("private Number convertStringToNumber ( String strValue ) { Number value = null ; try { if ( StringUtils . hasText ( strValue ) ) { if ( strValue . indexOf ( '.' ) > 0 ) { value = Double . valueOf ( strValue ) ; } else { value = Long . valueOf ( strValue ) ; } } } catch ( NumberFormatException ne ) { value = null ; } return value ; } \n", 0.3947383442853425)

('protected Number convertToNumber ( String value , Class < ? extends Number > targetType , Locale locale ) throws ConversionException { if ( value == null ) { return null ; } value = value . trim ( ) ; ParsePosition parsePosition = new ParsePosition ( 0 ) ; Number parsedValue = getFormat ( locale ) . parse ( value , parsePosition ) ; if ( parsePosition . getIndex ( ) != value . length ( ) ) { throw new ConversionException ( "Could-not-convert-\'" + value + "\'-to-" + getModelType ( ) . getName ( ) ) ; } if ( parsedValue == null ) { return null ; } return parsedValue ; } \n', 0.38479405216693646)

('@ Override protected BigDecimal convertObjectToNumber ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return BigDecimal . ZERO ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToNumber ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToNumber ( sourceObject ) ; } \n', 0.3808780771587239)

('private static Object convertToNumber ( Object value ) { try { return Integer . parseInt ( String . valueOf ( value ) ) ; } catch ( NumberFormatException e ) { try { return Double . parseDouble ( String . valueOf ( value ) ) ; } catch ( NumberFormatException e2 ) { } } return value ; } \n', 0.37736934051313253)

('protected BigDecimal convertObjectToNumber ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return BigDecimal . ZERO ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToNumber ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToNumber ( sourceObject ) ; } \n', 0.3756330614695591)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 38 #################################
('void saveListToFile ( JList list , File file ) { try { if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } final BufferedWriter bw = new BufferedWriter ( new FileWriter ( file ) ) ; final ListModel model = list . getModel ( ) ; final int size = model . getSize ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final String s = model . getElementAt ( i ) + "-" ; bw . write ( s , 0 , s . length ( ) ) ; } bw . close ( ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; } } \n', 0.4380274028738482)

('public void SaveArrayListToFile ( ArrayList < String > text , File file ) throws IOException { FileWriter output = new FileWriter ( file ) ; for ( String word : text ) { output . append ( word + "-" ) ; } output . close ( ) ; } \n', 0.4265884105092066)

('public void saveListOfNamedEntityToFile ( HashMap < String , NamedEntity > hmNamedEntity , String outputFile ) { FileWriter fw = new FileWriter ( ) ; if ( outputFile . equals ( "" ) ) { fw . writeNamedEntityToFile ( "../data/skwiki_merged_inflected_forms.txt" , hmNamedEntity ) ; } else { fw . writeNamedEntityToFile ( "outputFile" , hmNamedEntity ) ; } } \n', 0.42477762186901796)

('public void saveBiblioListToFile ( String [ ] entriesList ) throws IOException { try { PrintWriter pw = new PrintWriter ( new FileWriter ( BIBLIO_FILE_NAME ) ) ; Reference . saveBiblioToFile ( entriesList , pw ) ; } catch ( FileNotFoundException e ) { } } \n', 0.42198431801604247)

('private void saveListToFile ( ) { OutputStream fos = null ; try { fos = new FileOutputStream ( scoreFile ) ; ObjectOutputStream out = new ObjectOutputStream ( fos ) ; out . writeObject ( list ) ; out . close ( ) ; fos . close ( ) ; } catch ( IOException e ) { System . out . println ( "Fehler-beim-Speichern-der-Highscores:-" + e ) ; } } \n', 0.4164931980345136)

('public void saveListToFile ( ) { try { ObjectOutputStream oos = null ; try { oos = new ObjectOutputStream ( new FileOutputStream ( HOTKEY_LIST_FILE ) ) ; oos . writeObject ( this ) ; oos . flush ( ) ; } finally { oos . close ( ) ; } } catch ( FileNotFoundException e ) { Logger . error ( e ) ; } catch ( IOException e ) { Logger . error ( e ) ; } } \n', 0.4154518592683567)

('public static void saveListToFile ( List < ? > list , String path ) { try { FileOutputStream outStream = new FileOutputStream ( path ) ; ObjectOutputStream objectOutputStream = new ObjectOutputStream ( outStream ) ; objectOutputStream . writeObject ( list ) ; outStream . close ( ) ; } catch ( Exception e ) { } } \n', 0.41470343884576055)

('private static void saveListToFile ( SinglyLinkedList lst ) { try { ObjectOutputStream os = new ObjectOutputStream ( new FileOutputStream ( fileName ) ) ; os . writeObject ( lst ) ; os . flush ( ) ; os . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.4098895712312167)

('public static void saveListToFile ( SinglyLinkedList lst ) { try { ObjectOutputStream os = new ObjectOutputStream ( new FileOutputStream ( fileName ) ) ; os . writeObject ( lst ) ; os . flush ( ) ; os . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.4098895712312167)

('public void SaveArrayArrayListToFile ( ArrayList < ArrayList < String >> text , File file ) throws IOException { FileWriter output = new FileWriter ( file ) ; for ( ArrayList < String > sentences : text ) { String phrase = null ; for ( String word : sentences ) { phrase += word + "-" ; } phrase += "-" ; output . append ( phrase ) ; } output . close ( ) ; } \n', 0.4087235492961013)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 39 #################################
('public void writeContactsFileHeaderLine ( File newContactsFile ) throws IOException { BufferedWriter newContactsBW = null ; try { newContactsBW = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( newContactsFile , true ) , "UTF8" ) ) ; List < String > contactColumnNames = new LinkedList < String > ( ) ; contactColumnNames . add ( "role" ) ; contactColumnNames . add ( "name" ) ; contactColumnNames . add ( "telephone" ) ; contactColumnNames . add ( "address" ) ; contactColumnNames . add ( "email" ) ; fileUtils . writeValuesToFile ( newContactsBW , contactColumnNames ) ; newContactsBW . close ( ) ; } catch ( Exception e ) { log . error ( "An-error-occurred-writing-contact-file:-" + e . getMessage ( ) , e ) ; } finally { if ( newContactsBW != null ) { try { newContactsBW . close ( ) ; } catch ( Exception e ) { log . error ( "An-error-occurred-closing-output-stream-on-contact-file:-" + e . getMessage ( ) , e ) ; } } } } \n', 0.3581788275637395)

('private static LinkedHashMap < String , String > splitInHeaderTail ( File f ) throws IOException { String content = fileToString ( f ) ; int lineIndex = 0 , positionNewline = 0 , nHeaderLines = 11 ; String newlineChar = "-" ; content = content . replace ( \'|r\' , \'|n\' ) ; for ( positionNewline = content . indexOf ( newlineChar ) ; positionNewline != - 1 && lineIndex < nHeaderLines - 1 ; positionNewline = content . indexOf ( newlineChar , positionNewline + 1 ) ) { lineIndex ++ ; } String header = content . substring ( 0 , positionNewline + 1 ) ; String body = content . substring ( positionNewline + 1 ) ; LinkedHashMap < String , String > fsplit = new LinkedHashMap < String , String > ( ) ; fsplit . put ( HEADER , header ) ; fsplit . put ( BODY , body ) ; int nComma = StringUtils . countOccurrencesOf ( header , "," ) ; int nSemiColon = StringUtils . countOccurrencesOf ( header , ";" ) ; if ( nSemiColon < nComma ) fsplit . put ( CSVSEPARATOR , "," ) ; else fsplit . put ( CSVSEPARATOR , ";" ) ; return fsplit ; } \n', 0.3295982907414461)

('private static String readHeaderLine ( FileSystem fs , CSVFileFormatProperties prop , String smallestFile ) throws IOException { String line = null ; BufferedReader br = new BufferedReader ( new InputStreamReader ( fs . open ( new Path ( smallestFile ) ) ) ) ; line = br . readLine ( ) ; br . close ( ) ; if ( prop . hasHeader ( ) ) { ; } else { int ncol = Pattern . compile ( Pattern . quote ( prop . getDelim ( ) ) ) . split ( line , - 1 ) . length ; line = null ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "V1" ) ; for ( int i = 2 ; i <= ncol ; i ++ ) sb . append ( prop . getDelim ( ) + "V" + i ) ; line = sb . toString ( ) ; } return line ; } \n', 0.32686831757941304)

('private void writeHeaderLineOfImageFile ( BufferedWriter bw , List < String > orderedPojoAttrList ) throws IOException { bw . write ( LINE_NUMBER_COLUMN_NAME + "-" ) ; if ( orderedPojoAttrList . size ( ) > 0 ) { Iterator < String > iter = orderedPojoAttrList . iterator ( ) ; while ( iter . hasNext ( ) ) { String pojoAttr = iter . next ( ) ; bw . write ( pojoAttr ) ; if ( iter . hasNext ( ) ) { bw . write ( "-" ) ; } } } bw . write ( "-" ) ; } \n', 0.32372367282353237)

('public static File removeDuplicateLines ( File dataSet , int inputCount , int outputCount , boolean headers ) throws IOException { BufferedReader reader = Files . newBufferedReader ( dataSet . toPath ( ) , Charset . defaultCharset ( ) ) ; File newFile = generateFile ( dataSet , "_nodup" ) ; BufferedWriter writer = Files . newBufferedWriter ( newFile . toPath ( ) , Charset . defaultCharset ( ) ) ; ParseCSVLine csvParser = new ParseCSVLine ( CSVFormat . ENGLISH ) ; String line = null ; if ( headers ) { line = reader . readLine ( ) ; writer . write ( line + System . getProperty ( "line.separator" ) ) ; } ArrayList < RunTimeCase > existedCases = new ArrayList < RunTimeCase > ( ) ; List < String > lineStrings = null ; while ( ( line = reader . readLine ( ) ) != null ) { lineStrings = csvParser . parse ( line ) ; RunTimeCase rtCase = resolveCase ( lineStrings , inputCount , outputCount ) ; if ( ! existedCases . contains ( rtCase ) ) { existedCases . add ( rtCase ) ; writer . append ( line + System . getProperty ( "line.separator" ) ) ; } } writer . close ( ) ; reader . close ( ) ; return newFile ; } \n', 0.3211363225558012)

('private Map < Integer , String > parseHeaderLine ( ) throws Exception { Map < Integer , String > hash = new HashMap < Integer , String > ( ) ; if ( CRConstants . FIXED . equals ( fileType ) ) { for ( int i = 0 ; i < headerColumns . size ( ) ; i ++ ) { hash . put ( new Integer ( i + 1 ) , headerLine . substring ( headerColumns . get ( i ) . getStart ( ) , headerColumns . get ( i ) . getEnd ( ) ) . trim ( ) ) ; } } else if ( CRConstants . DELIMITED . equals ( fileType ) ) { int cnt = 1 ; List < String > list = processDelimitedLine ( headerLine ) ; for ( String value : list ) { hash . put ( new Integer ( cnt ++ ) , value ) ; } } return hash ; } \n', 0.31359320937952084)

('public List < String > parseHeaderLineOnly ( String fileName ) throws FileNotFoundException { BufferedReader br = new BufferedReader ( new FileReader ( fileName ) ) ; String strLine = null ; List < String > headerLine = new ArrayList < String > ( ) ; try { strLine = br . readLine ( ) ; System . out . println ( strLine ) ; headerLine = parseLine ( strLine ) ; logger . info ( headerLine . toString ( ) ) ; } catch ( IOException ex ) { logger . error ( "CSVFileParser:parseFile-Exception-in-the-file-parser" , ex ) ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( Exception ex ) { logger . error ( "CSVFileParser:parseFile:-unable-to-close-the-reader" , ex ) ; } } } return headerLine ; } \n', 0.30878092681250874)

('public static void createWekaInputFile ( String inputFile , String outputFile , boolean removeFilter ) { try { String lastActivity = "o" ; int FIELD_LENGTH_OF_LABELED_RECORD = 7 ; Scanner sc ; FileWriter fw = new FileWriter ( outputFile ) ; writeMotionStateArffHeader ( fw , Constants . ACCELEROMETER_RAW_DATA_DIR + "arff_header.txt" ) ; sc = new Scanner ( new File ( inputFile ) ) ; while ( sc . hasNextLine ( ) ) { String line = sc . nextLine ( ) . trim ( ) ; if ( ! line . contains ( ":" ) || line . startsWith ( "#" ) ) continue ; String [ ] fields = line . split ( "-" ) ; int startFieldIdx ; if ( removeFilter ) startFieldIdx = 2 ; else startFieldIdx = 0 ; if ( fields . length < FIELD_LENGTH_OF_LABELED_RECORD ) fw . write ( CommonUtils . cutField ( line , "-" , startFieldIdx ) . replaceAll ( "-" , "," ) + "," + lastActivity + "-" ) ; else { fw . write ( CommonUtils . cutField ( line , "-" , startFieldIdx ) . replaceAll ( "-" , "," ) + "-" ) ; lastActivity = fields [ FIELD_LENGTH_OF_LABELED_RECORD - 1 ] ; } } sc . close ( ) ; fw . close ( ) ; System . out . println ( "Complete-activity-labeld-file-was-written-to-"" + CommonUtils . getFileName ( outputFile ) + """ ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } \n', 0.30359676825252946)

('private void addCompressLineToHeader ( int metaLineNum , String compressLine ) { List < String > originalHeader = History . getMetaData ( ) . getOriginalHeader ( ) ; if ( metaLineNum != - 1 ) { originalHeader . remove ( metaLineNum ) ; originalHeader . add ( metaLineNum , compressLine ) ; } else { int position = originalHeader . size ( ) <= 1 ? 0 : originalHeader . size ( ) - 1 ; originalHeader . add ( position , compressLine ) ; } } \n', 0.30026296712907863)

('private void trimHeaders ( ) throws Exception { if ( this . br != null ) throw new Exception ( "Called-trimHeaders,-but-br-isn\'t-null.-This-should-not-happen." ) ; File file = new File ( this . filename ) ; if ( ! file . exists ( ) ) throw new Exception ( this . filename + "-does-not-exist." ) ; if ( ! file . canRead ( ) ) throw new Exception ( "Insufficient-privledges-to-read:-" + this . filename ) ; try { this . br = new BufferedReader ( new FileReader ( file ) ) ; this . lastLineRead = br . readLine ( ) ; while ( this . lastLineRead . startsWith ( "H" ) ) this . lastLineRead = br . readLine ( ) ; } catch ( Exception e ) { this . lastLineRead = null ; this . close ( ) ; } finally { file = null ; } } \n', 0.2939923154276639)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 40 #################################
('private String replaceIllegalFileNameCharacters ( final String pFilename , final char [ ] pIllegalChars , final char pReplacementChar ) { String returnString = pFilename ; for ( char c : pIllegalChars ) { returnString = returnString . replace ( c , pReplacementChar ) ; } return returnString ; } \n', 0.43883244836736746)

('public static boolean replaceInFile ( File file , String oldS , String newS , String encoding ) { try { String s = FileUtils . readFileToString ( file ) ; if ( s . indexOf ( oldS ) != - 1 ) { s = s . replaceAll ( oldS , newS ) ; Writer bw = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( file ) , encoding ) ) ; try { bw . write ( s ) ; bw . flush ( ) ; } finally { bw . close ( ) ; } return true ; } } catch ( IOException e ) { Log . error ( e ) ; } return false ; } \n', 0.43388371384611535)

('public static Map . Entry < Integer , String > replaceAllWeirdCharsFromFile ( String f ) throws IOException { Charset charset = Charset . forName ( "UTF-8" ) ; int weirdCharsCount = 0 ; Set < String > weirdCharsList = new HashSet < > ( ) ; String text = new String ( Files . readAllBytes ( Paths . get ( f ) ) , charset ) ; char [ ] textArray = text . toCharArray ( ) ; for ( int i = 0 ; i < textArray . length ; i ++ ) { if ( text . codePointAt ( i ) > 500 && i != 0 ) { textArray [ i ] = \'-\' ; weirdCharsList . add ( String . valueOf ( text . charAt ( i ) ) ) ; System . out . println ( i + "-" + text . charAt ( i ) + "-" + text . codePointAt ( i ) ) ; weirdCharsCount ++ ; } } text = String . valueOf ( textArray ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( Paths . get ( f . substring ( 0 , f . length ( ) - 4 ) + "_clean.srt" ) , charset ) ) { writer . write ( text ) ; writer . flush ( ) ; } catch ( EOFException e ) { Log . appendToInfoArea ( e . toString ( ) ) ; e . printStackTrace ( ) ; } return new AbstractMap . SimpleEntry < > ( weirdCharsCount , String . join ( ",-" , weirdCharsList ) ) ; } \n', 0.41923295526177545)

('private static String replaceIllegalCharactersInFileName ( String fileName ) { return fileName . replaceAll ( "[^a-zA-Z0-9.-]" , "_" ) ; } \n', 0.4178377442573138)

('public static boolean replaceInFile ( File file , String find , String replace ) throws IOException { String fileString = fileToString ( file . getPath ( ) ) ; String newString = fileString . replace ( find , replace ) ; if ( fileString . equals ( newString ) ) { return false ; } print ( file , newString ) ; return true ; } \n', 0.417174850820299)

('public static void replaceInFile ( FileObject file , String searchedString , String replacement ) { replaceInFile ( file , new String [ ] { searchedString } , new String [ ] { replacement } ) ; } \n', 0.4161438638232624)

('public void replaceTag ( String tagName , String replacement ) { fileContent = fileContent . replace ( tagName , replacement ) ; } \n', 0.41419492225326626)

('public static String replaceFileExtension ( String fileName , String newExtension ) { String ext = getFileExtension ( fileName ) ; String newFileName ; if ( ext . equals ( "" ) ) { newFileName = fileName + "." + newExtension ; } else { newFileName = fileName . replaceAll ( "." + ext , newExtension ) ; } return newFileName ; } \n', 0.4126533666048869)

('public static String replaceInvalidFileChars ( final String fileName ) { String finalReplaceChar = IUtilCommonConstants . UNDER_SCORE ; String [ ] invalidChars = IUtilCommonConstants . INVALID_FILE_EXTENSIONS . split ( IUtilCommonConstants . INVALID_CHAR_SEPARATOR ) ; LOGGER . info ( "Entering-removeInvalidFileChars-method" ) ; String updatedFileName = fileName ; if ( fileName != null && ! fileName . isEmpty ( ) && invalidChars != null && invalidChars . length > UtilConstants . ZERO ) { if ( finalReplaceChar == null || finalReplaceChar . isEmpty ( ) ) { LOGGER . info ( "Replace-character-not-specified.-Using-default-character-\'-\'-as-a-replace-character." ) ; finalReplaceChar = DEFAULT_REPLACE_CHAR ; } for ( String invalidChar : invalidChars ) { if ( finalReplaceChar . equals ( invalidChar ) ) { LOGGER . info ( "Replace-character-not-specified-or-an-invalid-character.-Using-default-character-\'-\'-as-a-replace-character." ) ; finalReplaceChar = DEFAULT_REPLACE_CHAR ; } updatedFileName = updatedFileName . replace ( invalidChar , finalReplaceChar ) ; } } LOGGER . info ( "Exiting-removeInvalidFileChars-method" ) ; return updatedFileName ; } \n', 0.4125729074158446)

('public void replace ( CharSequence match , CharSequence replacement ) { file_hex_string = file_hex_string . replace ( match , replacement ) ; } \n', 0.40782756463562575)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 41 #################################
('protected void plotData ( Rectangle plotRect , Graphics2D g2 ) { if ( data == null ) return ; double boxHeight = plotRect . getHeight ( ) / rows ; double boxWidth = plotRect . getWidth ( ) / cols ; for ( int row = 0 ; row < data . length ; row ++ ) { int yPos = ( int ) Math . round ( plotRect . getY ( ) + ( row * boxHeight ) ) ; for ( int col = 0 ; col < data [ row ] . length ; col ++ ) { int xPos = ( int ) Math . round ( plotRect . getX ( ) + ( col * boxWidth ) ) ; int value ; if ( data [ row ] [ col ] < 0 ) value = 0 ; else value = ( int ) Math . round ( 255f * ( data [ row ] [ col ] - minVal ) / ( maxVal - minVal ) ) ; Color c = new Color ( ( 255 - value ) , ( 255 - value ) , ( 255 - value ) ) ; g2 . setColor ( c ) ; g2 . fill ( new Rectangle ( xPos , yPos , ( int ) ( boxWidth + 1 ) , ( int ) ( boxHeight + 1 ) ) ) ; } } } \n', 0.2852176352577874)

('protected void plotData ( Rectangle plotRect , Graphics2D g2 ) { if ( data == null ) return ; double boxHeight = plotRect . getHeight ( ) / rows ; double boxWidth = plotRect . getWidth ( ) / cols ; for ( int row = 0 ; row < data . length ; row ++ ) { int yPos = ( int ) Math . round ( plotRect . getY ( ) + ( row * boxHeight ) ) ; for ( int col = 0 ; col < data [ row ] . length ; col ++ ) { int xPos = ( int ) Math . round ( plotRect . getX ( ) + ( col * boxWidth ) ) ; int value ; if ( data [ row ] [ col ] < 0 ) value = 0 ; else value = ( int ) Math . round ( 255f * ( data [ row ] [ col ] - minVal ) / ( maxVal - minVal ) ) ; Color c ; if ( col < ( currFrame ) ) { c = new Color ( ( 255 - value ) , ( 255 - value ) , ( 255 - value ) ) ; } else if ( col == ( currFrame ) ) { c = new Color ( value , 200 , 200 ) ; } else { c = Color . BLACK ; } g2 . setColor ( c ) ; g2 . fill ( new Rectangle ( xPos , yPos , ( int ) ( boxWidth + 1 ) , ( int ) ( boxHeight + 1 ) ) ) ; } } } \n', 0.2730485762656025)

('protected void plotCompetitors ( Rectangle plotRect , Graphics2D g2 ) { if ( competitionData == null || data == null ) return ; double boxHeight = plotRect . getHeight ( ) / rows ; double boxWidth = plotRect . getWidth ( ) / cols ; for ( int i = 0 ; i < competitionData . length ; i ++ ) { int yPos = ( int ) Math . round ( plotRect . getY ( ) + ( i * boxHeight ) ) ; int xPos = ( int ) Math . round ( plotRect . getX ( ) + ( competitionData [ i ] [ 1 ] * boxWidth ) ) ; double value = ( ( double ) competitionData [ i ] [ 2 ] / ( double ) 100 ) ; if ( i == focusRow ) g2 . setColor ( Color . GREEN ) ; else { g2 . setColor ( new Color ( 255 , 200 - ( int ) ( value * 200d ) , 0 ) ) ; } g2 . fill ( new Rectangle ( xPos , yPos , ( int ) ( boxWidth + 1 ) , ( int ) ( boxHeight + 1 ) ) ) ; } } \n', 0.27225812154690493)

('public void plot ( double value ) throws IOException { if ( numSeries != 1 ) throw new ArrayIndexOutOfBoundsException ( "Dimension-mismatch" ) ; writeBuffer . clear ( ) ; writeBuffer . putDouble ( value ) ; sendData ( ) ; } \n', 0.2580306273848787)

('private void plot ( Rectangle b ) { if ( Rectangle . intersection ( b , scaledBox ) . empty ( ) ) return ; g2d . setColor ( boxes ) ; move ( b . sw ( ) ) ; plot ( b . nw ( ) ) ; plot ( b . ne ( ) ) ; plot ( b . se ( ) ) ; plot ( b . sw ( ) ) ; } \n', 0.2550568282367873)

('private void plot ( Polygon p ) { if ( p . size ( ) <= 0 ) return ; if ( Rectangle . intersection ( p . getBox ( ) , scaledBox ) . empty ( ) ) return ; if ( p . getAttributes ( ) . getAppearance ( ) == null ) { Debug . e ( "RrGraphics:-polygon-with-size->-0-has-null-appearance." ) ; return ; } setColour ( p . getAttributes ( ) ) ; move ( p . point ( 0 ) ) ; for ( int i = 1 ; i < p . size ( ) ; i ++ ) plot ( p . point ( i ) ) ; if ( p . isClosed ( ) ) { g2d . setColor ( Color . RED ) ; plot ( p . point ( 0 ) ) ; } } \n', 0.2508025682532904)

('public void plot ( double [ ] values ) throws IOException { if ( values . length != numSeries ) throw new ArrayIndexOutOfBoundsException ( "Dimension-mismatch" ) ; writeBuffer . clear ( ) ; for ( int i = 0 ; i < values . length ; i ++ ) writeBuffer . putDouble ( values [ i ] ) ; sendData ( ) ; } \n', 0.24971222150583916)

('public static PlotCanvas plot ( String id , double [ ] [ ] data , int [ ] y , char [ ] legend , Color [ ] palette ) { if ( data [ 0 ] . length != 2 && data [ 0 ] . length != 3 ) { throw new IllegalArgumentException ( "Invalid data dimension: " + data [ 0 ] . length ) ; } double [ ] lowerBound = Math . colMin ( data ) ; double [ ] upperBound = Math . colMax ( data ) ; PlotCanvas canvas = new PlotCanvas ( lowerBound , upperBound ) ; ScatterPlot plot = new ScatterPlot ( data , y , legend , palette ) ; plot . setID ( id ) ; canvas . add ( plot ) ; return canvas ; }\n', 0.24944885033867464)

('public Plot ( JFreeChart chart , Axis horizontalAxis , Axis verticalAxis , Insets insets , Paint background , Stroke outlineStroke , Paint outlinePaint ) throws AxisNotCompatibleException { this . chart = chart ; this . horizontalAxis = horizontalAxis ; horizontalAxis . setPlot ( this ) ; horizontalAxis . addChangeListener ( this ) ; this . verticalAxis = verticalAxis ; verticalAxis . setPlot ( this ) ; verticalAxis . addChangeListener ( this ) ; this . insets = insets ; this . backgroundPaint = background ; this . outlineStroke = outlineStroke ; this . outlinePaint = outlinePaint ; this . listeners = new java . util . ArrayList ( ) ; } \n', 0.24547481833054538)

('public void plotFromFile ( final FileInputStream fstream , final float samplesPerPixel , final float sampleRate , final Color color ) throws IOException { DataInputStream in = new DataInputStream ( fstream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int position = 0 ; Graphics2D graph = buffImage . createGraphics ( ) ; graph . setColor ( color ) ; String strLine ; while ( ( strLine = br . readLine ( ) ) != null ) { position = ( int ) ( ( int ) ( Float . valueOf ( strLine ) * sampleRate ) / samplesPerPixel ) ; graph . drawLine ( position , 0 , position , buffImage . getHeight ( ) ) ; } in . close ( ) ; } \n', 0.24082158817954727)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 42 #################################
('protected void extractPluginFiles ( ) throws Exception { if ( isExtractNeeded ( ) ) { if ( extractionDirectory . exists ( ) ) { FileUtils . deleteDirectory ( extractionDirectory ) ; } if ( ! extractionDirectory . mkdir ( ) ) { throw new WorkflowRuntimeException ( "Could-not-create-the-extraction-directory-for-the-plugin:-" + extractionDirectory . getAbsolutePath ( ) ) ; } ZipFile zipFile = new ZipFile ( pluginZipFile , ZipFile . OPEN_READ ) ; for ( Enumeration entries = zipFile . entries ( ) ; entries . hasMoreElements ( ) ; ) { ZipEntry entry = ( ZipEntry ) entries . nextElement ( ) ; File entryFile = new File ( extractionDirectory + java . io . File . separator + entry . getName ( ) ) ; if ( entry . isDirectory ( ) ) { if ( ! entryFile . mkdir ( ) ) { throw new WorkflowRuntimeException ( "Failed-to-create-directory:-" + entryFile . getAbsolutePath ( ) ) ; } continue ; } InputStream is = null ; OutputStream os = null ; try { is = new BufferedInputStream ( zipFile . getInputStream ( entry ) ) ; os = new BufferedOutputStream ( new FileOutputStream ( entryFile ) ) ; while ( is . available ( ) > 0 ) { os . write ( is . read ( ) ) ; } } finally { if ( os != null ) { os . close ( ) ; } if ( is != null ) { is . close ( ) ; } } } } } \n', 0.4262977380096596)

('public static String extractZip ( File zipArchive , String outputDir ) { try { String rootDirectoryPath = null ; ZipFile zipFile = new ZipFile ( zipArchive ) ; Enumeration < ? > enu = zipFile . entries ( ) ; while ( enu . hasMoreElements ( ) ) { ZipEntry zipEntry = ( ZipEntry ) enu . nextElement ( ) ; String name = zipEntry . getName ( ) ; long size = zipEntry . getSize ( ) ; long compressedSize = zipEntry . getCompressedSize ( ) ; System . out . printf ( "name:-%-20s-|-size:-%6d-|-compressed-size:-%6d-" , name . substring ( 0 , name . indexOf ( \'/\' ) ) , size , compressedSize ) ; if ( rootDirectoryPath == null ) { rootDirectoryPath = name . substring ( 0 , name . indexOf ( \'/\' ) ) ; } File file = new File ( outputDir , name ) ; if ( name . endsWith ( "/" ) ) { file . mkdirs ( ) ; continue ; } File parent = file . getParentFile ( ) ; if ( parent != null ) { parent . mkdirs ( ) ; } InputStream is = zipFile . getInputStream ( zipEntry ) ; FileOutputStream fos = new FileOutputStream ( file ) ; byte [ ] bytes = new byte [ 1024 ] ; int length ; while ( ( length = is . read ( bytes ) ) >= 0 ) { fos . write ( bytes , 0 , length ) ; } is . close ( ) ; fos . close ( ) ; } zipFile . close ( ) ; return rootDirectoryPath ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } } \n', 0.4103092891729835)

('private static File extractZipFile ( File sourceFile ) throws IOException { File tempDir = File . createTempFile ( "owlapi-project" , "" ) ; tempDir . mkdir ( ) ; ZipFile zipFile = new ZipFile ( sourceFile ) ; Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry zipEntry = entries . nextElement ( ) ; if ( zipEntry . isDirectory ( ) ) { File dir = new File ( tempDir , zipEntry . getName ( ) ) ; dir . mkdirs ( ) ; } else { InputStream is = zipFile . getInputStream ( zipEntry ) ; int bufferSize = 10 * 1024 * 1024 ; BufferedInputStream bis = new BufferedInputStream ( is , bufferSize ) ; File entryFile = new File ( tempDir , zipEntry . getName ( ) ) ; entryFile . getParentFile ( ) . mkdirs ( ) ; FileOutputStream fos = new FileOutputStream ( entryFile ) ; BufferedOutputStream bos = new BufferedOutputStream ( fos ) ; byte [ ] buffer = new byte [ bufferSize ] ; while ( true ) { int read = bis . read ( buffer ) ; if ( read == - 1 ) { break ; } bos . write ( buffer , 0 , read ) ; if ( read < buffer . length ) { break ; } } bis . close ( ) ; bos . close ( ) ; } } return tempDir ; } \n', 0.4071921254880825)

('public static List < File > extractFilesFromZIP ( File zipFilename , File outputDir , boolean filesWithAbsolutePath ) throws IOException { ZipInputStream zipInputStream = new ZipInputStream ( new FileInputStream ( zipFilename ) ) ; ZipEntry zipEntry = zipInputStream . getNextEntry ( ) ; if ( zipEntry == null ) { zipInputStream . close ( ) ; throw new IOException ( "No-files-inside-ZIP" ) ; } else { List < File > extractedFiles = new ArrayList < File > ( ) ; while ( zipEntry != null ) { String entryName = zipEntry . getName ( ) ; logger . debug ( "Extracting-" + entryName ) ; File newFile = new File ( outputDir , entryName ) ; if ( filesWithAbsolutePath ) { extractedFiles . add ( newFile ) ; } else { extractedFiles . add ( new File ( entryName ) ) ; } if ( zipEntry . isDirectory ( ) ) { newFile . mkdirs ( ) ; } else { if ( newFile . getParentFile ( ) != null && ( ! newFile . getParentFile ( ) . exists ( ) ) ) { newFile . getParentFile ( ) . mkdirs ( ) ; } FileOutputStream newFileOutputStream = new FileOutputStream ( newFile ) ; IOUtils . copyLarge ( zipInputStream , newFileOutputStream ) ; newFileOutputStream . close ( ) ; zipInputStream . closeEntry ( ) ; } zipEntry = zipInputStream . getNextEntry ( ) ; } zipInputStream . close ( ) ; return extractedFiles ; } } \n', 0.4071647156098561)

('public static void extractZipArchive ( File zipFile , File targetDirectory , String entryPattern , String removedEntryPrefix ) throws IOException { if ( zipFile == null || targetDirectory == null ) throw new IllegalArgumentException ( "The-ZIP-file-and-the-target-directory-cannot-be-null." ) ; if ( ! zipFile . isFile ( ) ) throw new IllegalArgumentException ( "ZIP-file-" + targetDirectory . getName ( ) + "-does-not-exist." ) ; if ( targetDirectory . exists ( ) && ! targetDirectory . isDirectory ( ) ) throw new IllegalArgumentException ( "Target-directory-" + targetDirectory . getName ( ) + "-is-not-a-directory." ) ; Utils . createDirectory ( targetDirectory ) ; ZipFile theZipFile = new ZipFile ( zipFile ) ; Enumeration < ? extends ZipEntry > entries = theZipFile . entries ( ) ; try { while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; String suffix = entry . getName ( ) ; if ( entryPattern != null && ! suffix . matches ( entryPattern ) ) continue ; if ( removedEntryPrefix != null && suffix . startsWith ( removedEntryPrefix ) ) suffix = suffix . substring ( removedEntryPrefix . length ( ) ) ; if ( isEmptyOrWhitespaces ( suffix ) ) continue ; File f = new File ( targetDirectory , suffix ) ; if ( entry . isDirectory ( ) ) { Utils . createDirectory ( f ) ; } else { Utils . createDirectory ( f . getParentFile ( ) ) ; copyStream ( theZipFile . getInputStream ( entry ) , f ) ; } } } finally { theZipFile . close ( ) ; } } \n', 0.4050441893718282)

('public static List < String > extractZip ( ZipFile zip , File outputDir , StringFilter filter ) throws IOException { final ArrayList < String > files = new ArrayList < > ( ) ; if ( ! outputDir . mkdirs ( ) ) throw new IOException ( "Could-not-create-output-directory." ) ; final Enumeration < ? extends ZipEntry > zipFileEntries = zip . entries ( ) ; while ( zipFileEntries . hasMoreElements ( ) ) { final ZipEntry entry = zipFileEntries . nextElement ( ) ; final String entryPath = entry . getName ( ) ; final File destFile = new File ( outputDir , entryPath ) ; final File destinationParent = destFile . getParentFile ( ) ; if ( entry . isDirectory ( ) || ( filter != null && ! filter . isValid ( entryPath ) ) ) continue ; if ( ! destinationParent . mkdirs ( ) ) throw new IOException ( "Could-not-create-directory." ) ; if ( ! entry . isDirectory ( ) ) { extractZipEntry ( zip , entry , destFile ) ; files . add ( entryPath ) ; } } return files ; } \n', 0.40444430188822245)

('public static void extractZip ( ZipInputStream zin , File dir ) throws IOException { ZipEntry entry ; while ( ( entry = zin . getNextEntry ( ) ) != null ) { File file = new File ( dir , entry . getName ( ) ) ; if ( entry . isDirectory ( ) ) { if ( ! file . isDirectory ( ) ) { createDirectory ( file ) ; } } else { if ( ! file . getParentFile ( ) . isDirectory ( ) ) { createDirectory ( file . getParentFile ( ) ) ; } unzip ( zin , file ) ; } file . setLastModified ( entry . getTime ( ) ) ; } } \n', 0.4043798776957975)

('public void extractFromZip ( final File archive , final File destDir ) throws ZipException , FileNotFoundException , IOException { if ( ! destDir . exists ( ) ) { destDir . mkdir ( ) ; } final ZipFile zipFile = new ZipFile ( archive ) ; final Enumeration entries = zipFile . entries ( ) ; final byte [ ] buffer = new byte [ BUFFER ] ; int len ; while ( entries . hasMoreElements ( ) ) { final ZipEntry entry = ( ZipEntry ) entries . nextElement ( ) ; final String entryFileName = entry . getName ( ) ; final File dir = buildDirectoryHierarchyFor ( entryFileName , destDir ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } if ( ! entry . isDirectory ( ) ) { final BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( new File ( destDir , entryFileName ) ) ) ; final BufferedInputStream bis = new BufferedInputStream ( zipFile . getInputStream ( entry ) ) ; while ( ( len = bis . read ( buffer ) ) > 0 ) { bos . write ( buffer , 0 , len ) ; } bos . flush ( ) ; bos . close ( ) ; bis . close ( ) ; } } } \n', 0.40420842215807323)

('public static void extractZipFile ( File zipFile , File root ) throws IOException { ZipFile zip = new ZipFile ( zipFile ) ; Enumeration < ? > enum1 = zip . entries ( ) ; while ( enum1 . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) enum1 . nextElement ( ) ; File file = new File ( root , entry . getName ( ) ) ; if ( entry . isDirectory ( ) ) { file . mkdirs ( ) ; } else { if ( ! file . getParentFile ( ) . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; } extractOneFile ( file , zip . getInputStream ( entry ) ) ; } } zip . close ( ) ; } \n', 0.40215673897473847)

('private static Paths extractPackageFilesFromZip ( final File rootFile , final String directoryName ) throws IOException { final int length = directoryName . length ( ) ; boolean found = false ; Paths paths = new Paths ( ) ; ZipInputStream zipInputStream = new ZipInputStream ( new FileInputStream ( rootFile ) ) ; ZipEntry entry ; try { while ( ( entry = zipInputStream . getNextEntry ( ) ) != null ) { String name = entry . getName ( ) ; if ( name . startsWith ( directoryName ) && ! entry . isDirectory ( ) && name . lastIndexOf ( \'/\' ) <= length && name . endsWith ( ".java" ) ) { final File file = new File ( tempDir , directoryName ) ; if ( ! file . exists ( ) && ! file . mkdirs ( ) ) { throw new IOException ( "Unable-to-create-temp-dir:-" + file ) ; } final FileOutputStream fileOutputStream = new FileOutputStream ( new File ( tempDir , name ) ) ; try { copyStream ( zipInputStream , fileOutputStream ) ; paths . add ( tempDir . getAbsolutePath ( ) , name ) ; found = true ; } finally { fileOutputStream . close ( ) ; } zipInputStream . closeEntry ( ) ; } } } finally { zipInputStream . close ( ) ; } if ( found ) { return paths ; } return null ; } \n', 0.4005739517100593)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 43 #################################
('protected Map < String , Object > parseFile ( File file ) throws IOException { if ( file == null ) { return Collections . emptyMap ( ) ; } else if ( ! file . isFile ( ) || ! file . canRead ( ) ) { throw new IOException ( String . format ( "%s-is-not-a-readable-file" , file . getAbsolutePath ( ) ) ) ; } else { try { return new Gson ( ) . fromJson ( new FileReader ( file ) , new TypeToken < Map < String , Object >> ( ) { } . getType ( ) ) ; } catch ( JsonSyntaxException e ) { throw new AmbariException ( String . format ( "Failed-to-parse-JSON-formatted-file:-%s" , file . getAbsolutePath ( ) ) , e ) ; } } } \n', 0.4270172731475944)

('public static < T > T parseJson ( File jsonFile , Class < T > klass ) { try { FileReader reader = new FileReader ( jsonFile ) ; BufferedReader buf = new BufferedReader ( reader ) ; StringBuilder json = new StringBuilder ( ) ; String line ; while ( ( line = buf . readLine ( ) ) != null ) { json . append ( line ) ; } return new Gson ( ) . fromJson ( json . toString ( ) , klass ) ; } catch ( IOException ex ) { throw new JsonException ( ex ) ; } } \n', 0.42508075389284616)

('public static Map < String , Object > readJsonModel ( File jsFile ) throws IOException { try ( BufferedReader reader = new BufferedReader ( new FileReader ( jsFile ) ) ) { String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ( line . startsWith ( "ex$.$CCMM$=" ) || line . startsWith ( "var-$CCMM$=" ) || line . startsWith ( "var-$$METAMODEL$$=" ) || line . startsWith ( "var-$$metamodel$$=" ) ) && line . endsWith ( "};" ) ) { line = line . substring ( line . indexOf ( "{" ) , line . length ( ) - 1 ) ; @ SuppressWarnings ( "unchecked" ) Map < String , Object > rv = ( Map < String , Object > ) JSONValue . parse ( line ) ; return rv ; } } return null ; } } \n', 0.4183296797774425)

('public static JsonObject readJsonModel ( File jsFile ) throws IOException { try ( BufferedReader reader = new BufferedReader ( new FileReader ( jsFile ) ) ) { String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ( line . startsWith ( "ex$.$CCMM$=" ) || line . startsWith ( "var-$CCMM$=" ) || line . startsWith ( "var-$$METAMODEL$$=" ) || line . startsWith ( "var-$$metamodel$$=" ) ) && line . endsWith ( "};" ) ) { line = line . substring ( line . indexOf ( "{" ) , line . length ( ) - 1 ) ; JsonParser jsonParser = new JsonParser ( ) ; JsonObject rv = ( JsonObject ) jsonParser . parse ( line ) ; return rv ; } } return null ; } } \n', 0.41810444338179686)

('private Object parseFile ( File file , String scharset ) { Charset charset = scharset == null || scharset . length ( ) == 0 ? StandardCharsets . UTF_8 : Charset . forName ( scharset ) ; if ( file . length ( ) > ) { try ( Reader reader = Files . newBufferedReader ( IO . path ( file . toString ( ) ) , charset ) ) { return parse ( reader ) ; } catch ( IOException ioe ) { throw new JsonException ( "Unable-to-process-file:-" + file . getPath ( ) , ioe ) ; } } else { try { return JsonFactory . create ( ) . fromJson ( Files . newBufferedReader ( IO . path ( file . toString ( ) ) , charset ) ) ; } catch ( IOException e ) { throw new JsonException ( "Unable-to-process-file:-" + file . getPath ( ) , e ) ; } } } \n', 0.41726749414195474)

('public static DocumentContext parse ( File json , Configuration configuration ) throws IOException { return new ParseContextImpl ( configuration ) . parse ( json ) ; }\n', 0.41602598949862307)

('public static JSONObject parseJSONFile ( String configInfoPath ) { JSONObject jsonObject = null ; try { BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( configInfoPath ) ) ) ; StringBuilder builder = new StringBuilder ( ) ; String line = null ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { builder . append ( line ) ; } bufferedReader . close ( ) ; jsonObject = new JSONObject ( builder . toString ( ) ) ; } catch ( FileNotFoundException e ) { System . err . println ( "config-log-file-\'" + configInfoPath + "\'-could-not-be-found." ) ; System . exit ( - 1 ) ; } catch ( IOException e ) { System . err . println ( e . getMessage ( ) ) ; System . exit ( - 1 ) ; } catch ( JSONException e ) { System . err . println ( "Error-with-config-file:-" + configInfoPath ) ; System . err . println ( e . getLocalizedMessage ( ) ) ; System . exit ( - 1 ) ; } return jsonObject ; } \n', 0.4157611536108781)

('@ SuppressWarnings ( "ResultOfMethodCallIgnored" ) public static String parseJsonFile ( Context ctx , String filename ) { String json ; try { InputStream stream = ctx . getAssets ( ) . open ( filename ) ; byte [ ] buffer = new byte [ stream . available ( ) ] ; stream . read ( buffer ) ; stream . close ( ) ; json = new String ( buffer , "UTF-8" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } return json ; } \n', 0.4126202387377664)

('public static < T extends Object > T parseJson ( File path , Class < T > cl ) { if ( path != null && path . isFile ( ) && path . length ( ) > 0L ) { FileInputStream input = null ; Object var4 ; try { input = new FileInputStream ( path ) ; Object e = parseJson ( ( InputStream ) input , cl ) ; return null ; } catch ( Throwable var8 ) { var8 . printStackTrace ( ) ; var4 = null ; } finally { MCPatcherUtils . close ( ( Closeable ) input ) ; } return null ; } else { return null ; } } \n', 0.4107200289031231)

('private static ArrayList < String > parseJsonData ( String path ) throws IOException { FileInputStream fstream = new FileInputStream ( path ) ; DataInputStream in = new DataInputStream ( fstream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String strLine ; StringBuilder sb = new StringBuilder ( ) ; ArrayList < String > strings = new ArrayList < > ( ) ; while ( ( strLine = br . readLine ( ) ) != null ) { sb . append ( strLine ) ; if ( strLine . equals ( "" ) ) { strLine = sb . toString ( ) ; strings . add ( strLine ) ; sb = new StringBuilder ( ) ; } } strLine = sb . toString ( ) ; strings . add ( strLine ) ; br . close ( ) ; return strings ; } \n', 0.4078233608597779)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 44 #################################
('private static String readTextFromAddresseElement ( Node addresseeElement ) { StringBuilder text = new StringBuilder ( ) ; NodeList nodes = addresseeElement . getChildNodes ( ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; ++ i ) { Node node = nodes . item ( i ) ; switch ( node . getNodeType ( ) ) { case Node . TEXT_NODE : String unescapedText = StringEscapeUtils . unescapeHtml4 ( node . getNodeValue ( ) ) ; text . append ( StringUtils . cleanFormatting ( unescapedText ) ) ; break ; case Node . ELEMENT_NODE : if ( node . getNodeName ( ) . equalsIgnoreCase ( HTML_TAG_BR ) ) { text . append ( System . getProperty ( "line.separator" ) ) ; } else if ( node . getNodeName ( ) . equalsIgnoreCase ( HTML_TAG_TAB ) ) { text . append ( \'|t\' ) ; } break ; default : { logger . info ( "The-node-type-is-" + node . getNodeType ( ) ) ; } } } return text . toString ( ) . trim ( ) ; } \n', 0.40740678731509816)

('protected List < String > readFromUrl ( ) throws Exception { final DocumentBuilder documentBuilder = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; final Document document = documentBuilder . parse ( _url ) ; final Element documentElement = document . getDocumentElement ( ) ; final String codebase = documentElement . getAttribute ( "codebase" ) ; final NodeList jarElements = document . getElementsByTagName ( "jar" ) ; final int length = jarElements . getLength ( ) ; assert length > 0 ; final List < String > result = new ArrayList < String > ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { final Element jarElement = ( Element ) jarElements . item ( i ) ; final String href = jarElement . getAttribute ( "href" ) ; if ( codebase == null ) { result . add ( href ) ; } else if ( codebase . endsWith ( "/" ) ) { result . add ( codebase + href ) ; } else { result . add ( codebase + \'/\' + href ) ; } } return result ; } \n', 0.3939087656954905)

('public Element readHtml ( String html ) { try { html = html . replaceAll ( "&nbsp;" , "&#160;" ) ; return documentBuilder . parse ( new ByteArrayInputStream ( html . getBytes ( "UTF-8" ) ) ) . getDocumentElement ( ) ; } catch ( SAXException | IOException e ) { e . printStackTrace ( ) ; return null ; } } \n', 0.38844712466770637)

('public void readHTMLFromURL ( URL url ) throws IOException { InputStream in = url . openStream ( ) ; try { parseXHTML ( new InputStreamReader ( in , "UTF8" ) ) ; } finally { try { in . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( HTMLTextAreaModel . class . getName ( ) ) . log ( Level . SEVERE , "Exception-while-closing-InputStream" , ex ) ; } } } \n', 0.3738274331756572)

('private static List < String > parseHtml ( String html ) { List < String > data = new ArrayList < String > ( ) ; Document d = Jsoup . parse ( html ) ; Iterator < Element > i = d . select ( "table#ctl00_cphContent_gridLotto" ) . select ( "tr" ) . iterator ( ) ; Element tr = i . next ( ) ; if ( tr . select ( "th" ) . size ( ) == 0 ) { return null ; } Elements td ; StringBuilder sb ; while ( i . hasNext ( ) ) { tr = i . next ( ) ; td = tr . select ( "td" ) ; sb = new StringBuilder ( ) ; for ( Element e : td ) { sb . append ( e . text ( ) ) . append ( "-" ) ; } data . add ( sb . toString ( ) ) ; } return data ; } \n', 0.36595500549457993)

('private void loadHtmlIntoView ( String text , boolean ignoreCharset ) throws IOException { Document doc = getView ( ) . getDocument ( ) ; try { doc . remove ( 0 , doc . getLength ( ) ) ; if ( ( text == null ) || ( text . equals ( "" ) ) ) { return ; } if ( ignoreCharset ) { ( ( HTMLDocument ) getView ( ) . getDocument ( ) ) . putProperty ( "IgnoreCharsetDirective" , Boolean . TRUE ) ; } Reader r = new StringReader ( text ) ; EditorKit kit = getView ( ) . getEditorKit ( ) ; kit . read ( r , doc , 0 ) ; } catch ( BadLocationException e ) { LOG . severe ( "Error-deleting-old-view-content:-" + e . getMessage ( ) ) ; return ; } } \n', 0.36174882452826096)

('private void loadRenderElementsForEachRepeatElement ( Node node , List < List < Map < String , String >>> renderMaps ) throws Exception { NodeList list = node . getChildNodes ( ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { Node n = list . item ( i ) ; if ( n . getNodeName ( ) . equalsIgnoreCase ( "repeat" ) && ! n . hasAttributes ( ) ) { Node templateNode = HtmlFormEntryUtil . findChild ( n , "template" ) ; if ( templateNode == null ) { throw new IllegalArgumentException ( "All-<repeat>-elements-must-contain-a-child-<template>-element." ) ; } List < Map < String , String >> l = new ArrayList < Map < String , String >> ( ) ; NodeList repeatNodes = n . getChildNodes ( ) ; for ( int j = 0 ; j < repeatNodes . getLength ( ) ; j ++ ) { Node renderNode = repeatNodes . item ( j ) ; if ( renderNode . getNodeName ( ) . equalsIgnoreCase ( "render" ) ) { l . add ( HtmlFormEntryUtil . getNodeAttributes ( renderNode ) ) ; } } renderMaps . add ( l ) ; } else { loadRenderElementsForEachRepeatElement ( n , renderMaps ) ; } } } \n', 0.35686247637891094)

('public void readHTMLFromURL ( FileHandle url ) throws IOException { InputStream in = null ; try { parseXHTML ( new InputStreamReader ( in , "UTF8" ) ) ; } finally { try { in . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( HTMLTextAreaModel . class . getName ( ) ) . log ( Level . SEVERE , "Exception-while-closing-InputStream" , ex ) ; } } } \n', 0.3556314556696437)

('public static String extractInputValueFromHtmlContent ( @ NonNull final String input , @ NonNull final String htmlContent ) { Document document = Jsoup . parse ( htmlContent ) ; Elements elements = document . select ( "input[name=" + input + "]" ) ; if ( elements == null || elements . isEmpty ( ) ) { log . warn ( input + "-input-not-found-in-response." ) ; return null ; } Element element = elements . iterator ( ) . next ( ) ; return element . val ( ) ; } \n', 0.35441367546184044)

('private static Set < String > loadCsvFromHtml ( final URL html , final File root ) throws IOException { final Set < String > setUrls = new TreeSet < > ( ) ; final Set < URL > history = new HashSet < > ( ) ; final int aux [ ] = loadCsvFromHtml ( html , null , null , 0 , 0 , setUrls , history , root ) ; System . out . println ( "-Total-csv-files-parsed:-" + aux [ 1 ] ) ; return setUrls ; } \n', 0.35391484031129555)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 45 #################################
('public double [ ] distributionForInstance ( Instance instance ) throws Exception { double [ ] probOfClassGivenDoc = new double [ m_numClasses ] ; double [ ] logDocGivenClass = new double [ m_numClasses ] ; for ( int h = 0 ; h < m_numClasses ; h ++ ) logDocGivenClass [ h ] = probOfDocGivenClass ( instance , h ) ; double max = logDocGivenClass [ Utils . maxIndex ( logDocGivenClass ) ] ; double probOfDoc = 0.0 ; for ( int i = 0 ; i < m_numClasses ; i ++ ) { probOfClassGivenDoc [ i ] = Math . exp ( logDocGivenClass [ i ] - max ) * m_probOfClass [ i ] ; probOfDoc += probOfClassGivenDoc [ i ] ; } Utils . normalize ( probOfClassGivenDoc , probOfDoc ) ; return probOfClassGivenDoc ; } \n', 0.38181223751422)

('public double [ ] distributionForInstance ( Instance instance ) { double [ ] predValues = new double [ m_numOfClasses ] ; for ( int i = 0 ; i < m_numOfClasses ; i ++ ) predValues [ i ] = 0.0 ; double [ ] distribution = predictionValuesForInstance ( instance , m_root , predValues ) ; double max = distribution [ Utils . maxIndex ( distribution ) ] ; for ( int i = 0 ; i < m_numOfClasses ; i ++ ) { distribution [ i ] = Math . exp ( distribution [ i ] - max ) ; } double sum = Utils . sum ( distribution ) ; if ( sum > 0.0 ) Utils . normalize ( distribution , sum ) ; return distribution ; } \n', 0.37641908014788206)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 46 #################################
('protected String valueToCSV ( List < String > values ) { if ( values == null ) { return "" ; } String s ; if ( values . size ( ) == 1 ) { s = values . get ( 0 ) ; } else { StringBuilder str = new StringBuilder ( ) ; for ( String value : values ) { if ( str . length ( ) > 0 ) { str . append ( DSpaceCSV . valueSeparator ) ; } str . append ( value ) ; } s = str . toString ( ) ; } return """ + s . replaceAll ( """ , """" ) + """ ; } \n', 0.42133907245931446)

('protected String convertToValidCSV ( Object value ) throws IOException { if ( value == null ) return "" ; StringBuilder r = new StringBuilder ( value . toString ( ) ) ; boolean containsDoubleQuote = r . indexOf ( DOUBLEQUOTE ) >= 0 , containsDelimiter = r . indexOf ( DELIMITER ) >= 0 , containsNewline = r . indexOf ( NEWLINE ) >= 0 ; if ( containsDoubleQuote ) { int k = 0 ; while ( ( k = r . indexOf ( DOUBLEQUOTE , k ) ) >= 0 ) { r . insert ( k , DOUBLEQUOTE ) ; k += 2 ; } } if ( containsDoubleQuote || containsDelimiter || containsNewline ) { r . insert ( 0 , DOUBLEQUOTE ) ; r . append ( DOUBLEQUOTE ) ; } return r . toString ( ) ; } \n', 0.419594767180675)

('private String valueToCSV ( ArrayList < String > values ) { String s = "" ; if ( values == null ) { return s ; } if ( values . size ( ) == 1 ) { s = values . get ( 0 ) ; } else { Iterator i = values . iterator ( ) ; while ( i . hasNext ( ) ) { s = s + i . next ( ) ; if ( i . hasNext ( ) ) { s = s + DSpaceCSV . valueSeparator ; } } } s = s . replaceAll ( """ , """" ) ; s = """ + s + """ ; return s ; } \n', 0.4100924813565987)

('protected String valueToCSV ( List < String > values ) { if ( values == null ) { return "" ; } String s ; if ( values . size ( ) == 1 ) { s = values . get ( 0 ) ; } else { StringBuilder str = new StringBuilder ( ) ; for ( String value : values ) { if ( str . length ( ) > 0 ) { str . append ( DSpaceCSV . valueSeparator ) ; } str . append ( value ) ; } s = str . toString ( ) ; } return """ + s . replaceAll ( """ , """" ) + """ ; } \n', 0.40841408743552626)

('public String toCSV ( List < Map > list , String ... tokens ) { String output = "" ; for ( String token : tokens ) { output += token + "," ; } output = output . substring ( 0 , output . length ( ) - 1 ) + "-" ; for ( Map m : list ) { String line = "" ; for ( String arg : tokens ) { Object o = m . get ( arg ) ; if ( o instanceof String ) line += """ + m . get ( arg ) + ""," ; else if ( o instanceof Double ) line += m . get ( arg ) + "," ; else { String conv = gson . toJson ( o ) ; conv = conv . replaceAll ( "-" , "-" ) ; line += """ + conv + ""," ; } } line = line . substring ( 0 , line . length ( ) - 1 ) + "-" ; output += line ; } return output ; } \n', 0.40160961189122346)

('public static String stringToCsv ( String [ ] [ ] anArray ) { String csv = "" ; for ( int i = 0 ; i < anArray . length ; i ++ ) { for ( int j = 0 ; j < anArray [ i ] . length ; j ++ ) { csv += anArray [ i ] [ j ] + "," ; } csv = csv . substring ( 0 , csv . length ( ) - 2 ) ; csv += "-" ; } return csv ; } \n', 0.3984653394042661)

('public static String convertTopViolationsToCsv ( Map < String , Integer > violationsPerFile ) { StringBuffer buffer = new StringBuffer ( ) ; List < CheckStyleViolationInformation > violations = new ArrayList < CheckStyleViolationInformation > ( ) ; Iterator < String > keys = violationsPerFile . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { String key = keys . next ( ) ; int value = violationsPerFile . get ( key ) . intValue ( ) ; violations . add ( new CheckStyleViolationInformation ( key , value ) ) ; } Collections . sort ( violations ) ; for ( int i = 0 ; ( i < ( ( violations . size ( ) > 10 ) ? 10 : violations . size ( ) ) ) ; i ++ ) { CheckStyleViolationInformation info = violations . get ( i ) ; buffer . append ( info . getFileName ( ) ) . append ( "," ) ; buffer . append ( info . getNumberOfViolations ( ) ) . append ( LINE_SEPARATOR ) ; } return buffer . toString ( ) ; } \n', 0.3908840756975284)

('public String transformToCsv ( ) { StringBuilder csvString = new StringBuilder ( ) ; csvString . append ( toCsvString ( object ) ) ; return csvString . toString ( ) ; } \n', 0.38525366469048056)

('public static String convertToCsvString ( Collection collection , Class baseClass ) throws IllegalAccessException , IOException { StringBuilder csvSb = new StringBuilder ( ) ; appendCsv ( collection , csvSb , baseClass ) ; return csvSb . toString ( ) ; } \n', 0.3850594698844837)

('public static String convertToCsvString ( Collection collection ) throws IllegalAccessException , NoSuchElementException , IOException { StringBuilder csvSb = new StringBuilder ( ) ; appendCsv ( collection , csvSb ) ; return csvSb . toString ( ) ; } \n', 0.3836186076173315)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 47 #################################
('public int getSocketTimeout ( ) { return connection . getSocketTimeout ( ) ; } \n', 0.37636614636832677)

('public static void checkSocketTimeout ( int socketTimeout ) { if ( socketTimeout < 30 || socketTimeout > 300000 ) { throw new IllegalArgumentException ( messages . getString ( "message.illegal.argument.socket.timeout" ) ) ; } } \n', 0.3763474879245159)

('public void checkSocketTimeouts ( long inactiveMS ) { Iterator < Socket > it = subSockets . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Socket s = it . next ( ) ; if ( subSockets . get ( s ) < System . currentTimeMillis ( ) - inactiveMS ) { try { s . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( com . laytonsmith . core . functions . Federation . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } it . remove ( ) ; } } } \n', 0.3662723358744243)

('public int getSocketTimeoutMillis ( ) { try { return socket . getSoTimeout ( ) ; } catch ( SocketException e ) { throw new RuntimeException ( "Failed-to-get-timeout-on-Socket-[" + socket + "]" , e ) ; } } \n', 0.36536675289449294)

('public int getSocketTimeout ( ) throws SocketException { return socket . getSoTimeout ( ) ; } \n', 0.3638833369693565)

('public int getSocketTimeout ( ) throws SocketException { return socket != null ? socket . getSoTimeout ( ) : socketTimeout ; } \n', 0.3638833369693565)

('public void setSocketTimeout ( int socketTimeout ) throws SocketException { super . setSocketTimeout ( socketTimeout ) ; if ( proxySocket != null ) proxySocket . setSoTimeout ( socketTimeout ) ; } \n', 0.3586385974438018)

('public void setSocketTimeout ( int socketTimeout ) { this . socketTimeout = socketTimeout ; if ( socket != null ) { try { socket . setSoTimeout ( socketTimeout ) ; } catch ( SocketException ex ) { throw new RuntimeException ( ex ) ; } } } \n', 0.35839123251608807)

('public void setSocketTimeout ( int socketTimeout ) throws SocketException { dSocket . setSoTimeout ( socketTimeout ) ; } \n', 0.35839123251608807)

('public void setSocketTimeout ( int socketTimeout ) throws SocketException { if ( socketTimeout < 1 ) throw new IllegalArgumentException ( "socket-tiemout-must-be-positive" ) ; this . socketTimeout = socketTimeout ; if ( socket != null ) socket . setSoTimeout ( socketTimeout ) ; } \n', 0.35678361286972826)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 48 #################################
('private byte [ ] readFile ( File file ) throws IOException { File gzFile ; InputStream in ; if ( file . exists ( ) ) { in = new BufferedInputStream ( new FileInputStream ( file ) , BUFFER_SIZE ) ; } else { gzFile = new File ( file . getPath ( ) + ".gz" ) ; if ( ! gzFile . exists ( ) ) { gzFile = new File ( file . getPath ( ) + ".dz" ) ; } if ( gzFile . exists ( ) ) { in = new GZIPInputStream ( new BufferedInputStream ( new FileInputStream ( gzFile ) , BUFFER_SIZE ) ) ; } else { throw new FileNotFoundException ( file . getPath ( ) ) ; } } ByteArrayOutputStream out = new ByteArrayOutputStream ( BUFFER_SIZE ) ; try { LFileCopy . copy ( in , out ) ; } finally { in . close ( ) ; } return out . toByteArray ( ) ; } \n', 0.3843412920988142)

('public byte [ ] readContentRangeFromFile ( RandomAccessFile in , long contentRangeStart , long partSize ) throws IOException { byte [ ] buf = new byte [ ( int ) partSize ] ; in . seek ( contentRangeStart ) ; int bytesRead = in . read ( buf , 0 , ( int ) partSize ) ; return Arrays . copyOf ( buf , bytesRead ) ; } \n', 0.3786978118404164)

('private static String readContentOfFile ( BufferedReader bufferedReader , boolean addNewLine ) throws IOException { StringBuffer content = new StringBuffer ( ) ; String line = null ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { content . append ( line ) ; if ( addNewLine ) { content . append ( "-" ) ; } } return content . toString ( ) ; } \n', 0.3656495897965354)

('public static ByteBuffer readGZipFileToBuffer ( File gzFile ) throws IllegalArgumentException , IOException { if ( gzFile == null ) { String message = Logging . getMessage ( "nullValue.FileIsNull" ) ; Logging . logger ( ) . severe ( message ) ; throw new IllegalArgumentException ( message ) ; } if ( ! gzFile . exists ( ) ) { String message = Logging . getMessage ( "generic.FileNotFound" , gzFile . getAbsolutePath ( ) ) ; Logging . logger ( ) . severe ( message ) ; throw new FileNotFoundException ( message ) ; } if ( ! gzFile . canRead ( ) ) { String message = Logging . getMessage ( "generic.FileNoReadPermission" , gzFile . getAbsolutePath ( ) ) ; Logging . logger ( ) . severe ( message ) ; throw new IOException ( message ) ; } int inflatedLength = gzipGetInflatedLength ( gzFile ) ; if ( 0 == inflatedLength ) { String message = Logging . getMessage ( "generic.LengthIsInvalid" , gzFile . getAbsolutePath ( ) ) ; Logging . logger ( ) . severe ( message ) ; throw new IOException ( message ) ; } ByteBuffer buffer = null ; GZIPInputStream is = null ; try { is = new GZIPInputStream ( new BufferedInputStream ( new FileInputStream ( gzFile ) ) ) ; buffer = transferStreamToByteBuffer ( is , inflatedLength ) ; buffer . rewind ( ) ; } finally { WWIO . closeStream ( is , gzFile . getPath ( ) ) ; } return buffer ; } \n', 0.3607505873130072)

('public NBTCompound readCompressed ( File file ) throws FileNotFoundException { InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; return readCompressed ( inputStream ) ; } finally { if ( inputStream != null ) try { inputStream . close ( ) ; } catch ( IOException e ) { Bukkit . getLogger ( ) . log ( Level . ALL , "can-not-close-NBT-file-" + file , e ) ; } } } \n', 0.35742135315132983)

('public static String stringWithContentsOfFile ( File file ) { try { byte [ ] buffer = new byte [ ( int ) file . length ( ) ] ; BufferedInputStream stream = new BufferedInputStream ( new FileInputStream ( file ) ) ; stream . read ( buffer ) ; stream . close ( ) ; return new String ( buffer , "UTF-8" ) ; } catch ( IOException e ) { return null ; } } \n', 0.35534412601585236)

('private String readContentsOfFile ( File f ) throws IOException { return new BufferedReader ( new FileReader ( f ) ) . readLine ( ) ; } \n', 0.34547834270795397)

('public static BufferedReader readGZIPFile ( String fileName ) { BufferedReader reader = null ; try { FileInputStream file = new FileInputStream ( fileName ) ; GZIPInputStream gz = new GZIPInputStream ( file ) ; InputStreamReader input = new InputStreamReader ( gz ) ; reader = new BufferedReader ( input ) ; } catch ( FileNotFoundException f ) { log . error ( ":-Error---the-file-was-not-found:-" + f . getMessage ( ) ) ; } catch ( IOException e ) { log . error ( ":-Error---an-IOException-occurred:-" + e . getMessage ( ) ) ; } return reader ; } \n', 0.33307862208693495)

('public static NBTTagCompound readCompressed ( File file ) throws IOException { FileInputStream fis = new FileInputStream ( file ) ; GZIPInputStream gis = new GZIPInputStream ( fis ) ; try { return read ( gis ) ; } finally { gis . close ( ) ; fis . close ( ) ; } } \n', 0.33287501607232095)

('public void readGZFile ( IndexWriter writer , String filename , String encoding ) { if ( encoding == null || encoding . equals ( "" ) ) encoding = "UTF-8" ; try { InputStream fileStream = new FileInputStream ( filename ) ; InputStream gzipStream = new GZIPInputStream ( fileStream ) ; Reader decoder = new InputStreamReader ( gzipStream , encoding ) ; BufferedReader br = new BufferedReader ( decoder ) ; String line ; int count = 0 ; while ( ( line = br . readLine ( ) ) != null ) { doc = new Document ( ) ; doc . add ( new TextField ( "title" , line + "-" , Field . Store . YES ) ) ; doc . add ( new IntField ( "len" , line . length ( ) , Field . Store . YES ) ) ; writer . addDocument ( doc ) ; System . out . println ( ++ count ) ; } } catch ( FileNotFoundException e ) { _log . error ( String . format ( "File-%s-not-found." , filename ) ) ; } catch ( IOException e ) { _log . error ( "Error-trying-to-read-GZ-file-with-Wikipedia-Titles." ) ; } } \n', 0.3321597396465735)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 49 #################################
('public static < T > Queue < T > priorityQueue ( ) { return new PriorityQueue < T > ( ) ; } \n', 0.47266666477079416)

('protected PriorityQueue ( boolean isMinQueue ) { this . isMinQueue = isMinQueue ; this . backer = new java . util . PriorityQueue < > ( ) ; } \n', 0.4685781063521681)

('public static < E > PriorityQueue < E > priorityQueue ( SortedSet < E > elements ) { return new PriorityQueue < E > ( elements ) ; } \n', 0.46639028129097665)

('private PriorityQueue < Double > priorityQueue ( int size ) { final PriorityQueue < Double > result = new PriorityQueue < > ( size < 1 ? 1 : size ) ; for ( int i = size ; i >= 0 ; i -- ) { result . add ( rng . nextDouble ( ) ) ; } return result ; } \n', 0.46051470365928926)

('private PriorityQueue < Elem > priorityQueueKeyed ( int size ) { final PriorityQueue < Elem > result = new PriorityQueue < > ( size < 1 ? 1 : size ) ; for ( int i = size ; i >= 0 ; i -- ) { result . add ( new Elem ( rng . nextDouble ( ) , value ) ) ; } return result ; } \n', 0.45976126251242044)

('PriorityQueueSet ( int initialCapacity , Comparator < ? super E > comparator ) { this . queue = new PriorityQueue < E > ( initialCapacity , comparator ) ; } \n', 0.44859728996860515)

('public PriorityQueue < T > toPriorityQueue ( ) { PriorityQueue < T > queue = new PriorityQueue < T > ( ) ; Iterator < T > i = this . iterator ( ) ; while ( i . hasNext ( ) ) { queue . add ( i . next ( ) ) ; } return queue ; } \n', 0.4485091470949431)

('public PriorityQueue < T > toPriorityQueue ( ) { PriorityQueue < T > priority = new PriorityQueue < T > ( ) ; Iterator < T > i = this . iterator ( ) ; while ( i . hasNext ( ) ) { priority . add ( i . next ( ) ) ; } return priority ; } \n', 0.4485091470949431)

('public < E extends Comparable < E >> Queue < E > getPriorityQueue ( ) { return new PriorityQueue < E > ( ) ; } \n', 0.4468974441026809)

('public void submitPriorityUpstream ( ShareEntry entry ) { if ( entry . ourResult ) { synchronized ( qs ) { synchronized ( priorityQueue ) { priorityQueue . offerLast ( entry ) ; } qs . notifyAll ( ) ; } } } \n', 0.4443616229687312)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 50 #################################
('public static Pair < Population , Double > clusterLocalSearch ( PostProcessMethod method , Population pop , AbstractOptimizationProblem problem , double sigmaCluster , int funCalls , double keepClusterRatio , InterfaceMutation mute ) { int evalsBefore = pop . getFunctionCalls ( ) ; Population clust = ( Population ) clusterBest ( pop , new ClusteringDensityBased ( sigmaCluster , 2 ) , keepClusterRatio , KEEP_LONERS , BEST_RAND ) . clone ( ) ; double [ ] meanFit = clust . getMeanFitness ( ) ; int evalsDone = processSingleCandidates ( method , clust , funCalls , sigmaCluster / 2. , problem , mute ) ; clust . setFunctionCalls ( evalsBefore + evalsDone ) ; double improvement = EuclideanMetric . euclideanDistance ( meanFit , clust . getMeanFitness ( ) ) ; return new Pair < > ( clust , improvement ) ; } \n', 0.33347163858650053)

('public double meanLocalClusterCoeff ( ) { double sumCoeff = 0.0 ; int n = nodes . size ( ) ; if ( n == 0 ) return 0 ; for ( SimpleNode node : nodes ) { sumCoeff += node . localClusterCoeff ( ) ; } double mean = sumCoeff / n ; assert mean >= 0.0 && mean <= 1.0 ; return mean ; } \n', 0.33067760263936946)

('public static com . stromberglabs . cluster . Cluster findClosestExternalClusterToFeatureVector ( float [ ] fv , com . stromberglabs . cluster . Cluster c , com . stromberglabs . cluster . Cluster [ ] featureVectorClusters ) throws Exception { com . stromberglabs . cluster . Cluster closestExternalCluster = null ; double minimumDistanceToExternalClusterCentroid = Double . POSITIVE_INFINITY ; for ( com . stromberglabs . cluster . Cluster externalCluster : featureVectorClusters ) { if ( ! c . equals ( externalCluster ) ) { double distanceToExternalClusterCentroid = FeatureVector . L2distanceFrom ( fv , externalCluster . getClusterMean ( ) ) ; if ( distanceToExternalClusterCentroid < minimumDistanceToExternalClusterCentroid ) { minimumDistanceToExternalClusterCentroid = distanceToExternalClusterCentroid ; closestExternalCluster = externalCluster ; } } } return closestExternalCluster ; } \n', 0.32802393863979784)

('public void calculateClusters ( ) { if ( conf . getModel ( ) == Configuration . Models . ANTCLASS1 || conf . getModel ( ) == Configuration . Models . ANTCLASS2 ) { this . partition = new Cluster [ heaps . size ( ) ] ; int j = 0 ; for ( Heap h : this . heaps ) { LinkedList < Item > list = h . getItems ( ) ; partition [ j ] = new Cluster ( list . toArray ( new Item [ 0 ] ) ) ; j ++ ; } } else { TreeMap < UUID , Double > map = new TreeMap < UUID , Double > ( ) ; for ( Item it : items . values ( ) ) map . put ( it . getID ( ) , this . densityRawAt ( it . getX ( ) , it . getinitY ( ) ) ) ; map = sortByValues ( map ) ; LinkedList < UUID > list = new LinkedList < UUID > ( ) ; int i = 0 ; for ( UUID k : map . keySet ( ) ) { list . add ( k ) ; i ++ ; if ( i == conf . getntypes ( ) ) break ; } KMeans km = new KMeans ( this . conf , this . items , 0 , list , 10 , 2500 , 2 ) ; km . compute ( ) ; this . centers = km . getCenters ( ) ; this . partition = km . getClusters ( ) ; } } \n', 0.3224977146306447)

('public static Pair < Population , Double > clusterLocalSearch ( PostProcessMethod method , Population pop , AbstractOptimizationProblem problem , double sigmaCluster , int funCalls , double keepClusterRatio , InterfaceMutation mute ) { int evalsBefore = pop . getFunctionCalls ( ) ; Population clust = ( Population ) clusterBest ( pop , new ClusteringDensityBased ( sigmaCluster , 2 ) , keepClusterRatio , KEEP_LONERS , BEST_RAND ) . clone ( ) ; double [ ] meanFit = clust . getMeanFitness ( ) ; if ( TRACE ) System . out . println ( "BEF:-funcalls-done:-" + pop . getFunctionCalls ( ) + ",-now-allowed:-" + funCalls ) ; int evalsDone = processSingleCandidates ( method , clust , funCalls , sigmaCluster / 2. , problem , mute ) ; clust . SetFunctionCalls ( evalsBefore + evalsDone ) ; double improvement = EuclideanMetric . euclideanDistance ( meanFit , clust . getMeanFitness ( ) ) ; if ( TRACE ) System . out . println ( "improvement-by-" + improvement + "-funcalls-done:-" + evalsDone ) ; return new Pair < Population , Double > ( clust , improvement ) ; } \n', 0.32085961951179987)

('private T getPointFromLargestVarianceCluster ( final Collection < CentroidCluster < T >> clusters ) throws ConvergenceException { double maxVariance = Double . NEGATIVE_INFINITY ; Cluster < T > selected = null ; for ( final CentroidCluster < T > cluster : clusters ) { if ( ! cluster . getPoints ( ) . isEmpty ( ) ) { final Clusterable center = cluster . getCenter ( ) ; final Variance stat = new Variance ( ) ; for ( final T point : cluster . getPoints ( ) ) { stat . increment ( distance ( point , center ) ) ; } final double variance = stat . getResult ( ) ; if ( variance > maxVariance ) { maxVariance = variance ; selected = cluster ; } } } if ( selected == null ) { throw new ConvergenceException ( LocalizedFormats . EMPTY_CLUSTER_IN_K_MEANS ) ; } final List < T > selectedPoints = selected . getPoints ( ) ; return selectedPoints . remove ( random . nextInt ( selectedPoints . size ( ) ) ) ; } \n', 0.31968305692673543)

('public HashMap < String , Object > clusterWSDLDocumentsForCluster ( List < URL > WSDLLocations , double threshold ) { List < List < Operation >> clusters = new LinkedList < List < Operation >> ( ) ; HashMap < String , String > mapFiles = new HashMap < String , String > ( ) ; List < Operation > operations = new LinkedList < Operation > ( ) ; operationsURLs = new HashMap < Operation , URL > ( ) ; System . out . println ( "URLS:" + operationsURLs ) ; for ( URL documentURL : WSDLLocations ) { Description description = readLocation ( documentURL ) ; InterfaceType portType = description . getInterfaces ( ) . get ( 0 ) ; for ( Operation operation : portType . getOperations ( ) ) { operations . add ( operation ) ; operationsURLs . put ( operation , documentURL ) ; String [ ] fileName = documentURL . getPath ( ) . split ( "/" ) ; mapFiles . put ( operation . getQName ( ) . getLocalPart ( ) , fileName [ fileName . length - 1 ] ) ; } } ClusteringStrategy clusterer = getClustererStrategy ( ) ; clusterer . setOperations ( operations ) ; clusterer . generateCluster ( ) ; List < DataTypeNode > nodes = clusterer . getMergedClusters ( ) ; for ( DataTypeNode node : nodes ) { clusters . add ( node . getRelatedOperations ( ) ) ; } HashMap < String , Object > clusterInfo = new HashMap < String , Object > ( ) ; clusterInfo . put ( "clusterOperations" , clusters ) ; clusterInfo . put ( "mapFiles" , mapFiles ) ; return clusterInfo ; } \n', 0.315863395644964)

('private T getPointFromLargestVarianceCluster ( final Collection < Cluster < T >> clusters ) throws ConvergenceException { double maxVariance = Double . NEGATIVE_INFINITY ; Cluster < T > selected = null ; for ( final Cluster < T > cluster : clusters ) { if ( ! cluster . getPoints ( ) . isEmpty ( ) ) { final T center = cluster . getCenter ( ) ; final Variance stat = new Variance ( ) ; for ( final T point : cluster . getPoints ( ) ) { stat . increment ( point . distanceFrom ( center ) ) ; } final double variance = stat . getResult ( ) ; if ( variance > maxVariance ) { maxVariance = variance ; selected = cluster ; } } } if ( selected == null ) { throw new ConvergenceException ( LocalizedFormats . EMPTY_CLUSTER_IN_K_MEANS ) ; } final List < T > selectedPoints = selected . getPoints ( ) ; return selectedPoints . remove ( random . nextInt ( selectedPoints . size ( ) ) ) ; } \n', 0.3098717413629819)

('public String printClusters ( int numAttributesToPrint ) { numAttributesToPrint = Math . min ( numAttributesToPrint , AttributesUsed . size ( ) ) ; String output = String . format ( "%32s-%10s" , "Attribute-Name" , "Power" ) ; for ( int i = 0 ; i < NClusters ; i ++ ) output += String . format ( "-%10s" , "Cluster-#" + i ) ; output += "-" ; for ( int a = 0 ; a < numAttributesToPrint ; a ++ ) { output += String . format ( "%32s-%10.4e" , AttributesUsed . get ( AttributeRanks [ a ] ) , AttributePower [ a ] ) ; for ( int c = 0 ; c < NClusters ; c ++ ) output += String . format ( "-%10.4e" , ClusterMean [ c ] [ AttributeRanks [ a ] ] ) ; output += "-" ; } return output ; } \n', 0.3089616197342845)

('protected List < List < Integer >> sort ( List < V > means , Database < V > database ) { List < List < Integer >> clusters = new ArrayList < List < Integer >> ( k ) ; for ( int i = 0 ; i < k ; i ++ ) { clusters . add ( new LinkedList < Integer > ( ) ) ; } for ( Integer id : database ) { List < D > distances = new ArrayList < D > ( k ) ; V fv = database . get ( id ) ; int minIndex = 0 ; for ( int d = 0 ; d < k ; d ++ ) { distances . add ( getDistanceFunction ( ) . distance ( fv , means . get ( d ) ) ) ; if ( distances . get ( d ) . compareTo ( distances . get ( minIndex ) ) < 0 ) { minIndex = d ; } } clusters . get ( minIndex ) . add ( id ) ; } for ( List < Integer > cluster : clusters ) { Collections . sort ( cluster ) ; } return clusters ; } \n', 0.3083439928299473)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 51 #################################
('public Process getProcessFromId ( int id ) { for ( Process process : this . processes ) { if ( process . getId ( ) == id ) { return process ; } } return null ; } \n', 0.40742493745892844)

('private Process getProcessById ( String id ) { for ( Iterator < Process > it = processes . iterator ( ) ; it . hasNext ( ) ; ) { Process p = it . next ( ) ; if ( p . getId ( ) . equals ( id ) ) return p ; } return null ; } \n', 0.4051697039287081)

('public static long getProcessId ( ) { RuntimeMXBean bean = ManagementFactory . getRuntimeMXBean ( ) ; String jvmName = bean . getName ( ) ; long processId = Long . valueOf ( jvmName . split ( "@" ) [ 0 ] ) ; return processId ; } \n', 0.3997955653596935)

('public static int getCurrentProcessId ( ) { final Integer processId = s_currentProcess_ID . get ( ) ; if ( processId == null ) { return 0 ; } return processId ; } \n', 0.3997167528215526)

('public int getProcessId ( ) throws NativeException { return process . getProcessId ( ) ; } \n', 0.396811459898392)

('@ Override public Process getProcess ( String processId ) { return processes . get ( processId ) ; } \n', 0.3950648886032732)

('public static long getProcessId ( ) { return Context . getCurrentContext ( ) . getProcessId ( ) ; } \n', 0.39412113969445123)

('private String getProcessId ( String externalId ) throws WorkflowException { StringTokenizer st = new StringTokenizer ( externalId , "__" ) ; if ( st . countTokens ( ) != 4 ) throw new WorkflowException ( "TaskManagerImpl.getProcessId" , "workflowEngine.EX_ERR_ILLEGAL_EXTERNALID" , "external-Id-:-" + externalId ) ; return st . nextToken ( ) ; } \n', 0.39317056920909255)

('public static Long getProcessId ( ) { return xsltHelper . get ( ) . getProcessId ( ) ; } \n', 0.39103156671022216)

('public WorkloadProcess getProcess ( String processId ) { WorkloadProcess result = processes . get ( processId ) ; for ( int i = 0 ; ( result == null ) && ( i < 1000 ) ; ++ i ) { try { Thread . sleep ( 60 ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } result = processes . get ( processId ) ; } if ( result == null ) { throw new RuntimeException ( "Problem-with-process-registration" ) ; } return result ; } \n', 0.3848958153905828)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 52 #################################
('private void sendEmptyDataStream ( HttpURLConnection con ) throws ConnectionFailedException { try { DataOutputStream sendData = new DataOutputStream ( con . getOutputStream ( ) ) ; sendData . writeBytes ( "" ) ; sendData . flush ( ) ; sendData . close ( ) ; } catch ( IOException e ) { throw new ConnectionFailedException ( ) ; } } \n', 0.35485089046004037)

('private void serverLongData ( int parameterIndex , BindValue longData ) throws SQLException { synchronized ( this . connection . getMutex ( ) ) { MysqlIO mysql = this . connection . getIO ( ) ; Buffer packet = mysql . getSharedSendPacket ( ) ; Object value = longData . value ; if ( value instanceof byte [ ] ) { packet . clear ( ) ; packet . writeByte ( ( byte ) MysqlDefs . COM_LONG_DATA ) ; packet . writeLong ( this . serverStatementId ) ; packet . writeInt ( ( parameterIndex ) ) ; packet . writeBytesNoNull ( ( byte [ ] ) longData . value ) ; mysql . sendCommand ( MysqlDefs . COM_LONG_DATA , null , packet , true , null , 0 ) ; } else if ( value instanceof InputStream ) { storeStream ( mysql , parameterIndex , packet , ( InputStream ) value ) ; } else if ( value instanceof java . sql . Blob ) { storeStream ( mysql , parameterIndex , packet , ( ( java . sql . Blob ) value ) . getBinaryStream ( ) ) ; } else if ( value instanceof Reader ) { storeReader ( mysql , parameterIndex , packet , ( Reader ) value ) ; } else { throw SQLError . createSQLException ( Messages . getString ( "ServerPreparedStatement.18" ) + value . getClass ( ) . getName ( ) + "\'" , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } } \n', 0.3467501470682214)

('public static InputStream sendFormDataOnConnection ( ArrayList < BasicNameValuePair > formData ) { InputStream content = null ; StringBuilder sb = new StringBuilder ( ) ; Iterator < BasicNameValuePair > it = formData . iterator ( ) ; sb . append ( "dummy=dummy" ) ; while ( it . hasNext ( ) ) { BasicNameValuePair pair = it . next ( ) ; sb . append ( "&" + pair . getName ( ) + "=" + pair . getValue ( ) ) ; } URL url ; try { url = new URL ( GPSService . url ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setDoOutput ( true ) ; conn . setRequestMethod ( "POST" ) ; OutputStreamWriter wr = new OutputStreamWriter ( conn . getOutputStream ( ) ) ; wr . write ( sb . toString ( ) ) ; wr . flush ( ) ; content = conn . getInputStream ( ) ; wr . close ( ) ; } catch ( Exception e ) { Log . d ( "SERVICE" , "error-on-`sendFormDataOnConnection`-:" + e . getMessage ( ) + "" ) ; } return content ; } \n', 0.33807591811389065)

('private static void writeBinaryCheckpoints ( TreeMap < Integer , StoredBlock > checkpoints , File file ) throws Exception { FileOutputStream fileOutputStream = null ; try { fileOutputStream = new FileOutputStream ( file , false ) ; MessageDigest digest = MessageDigest . getInstance ( "SHA-256" ) ; final DigestOutputStream digestOutputStream = new DigestOutputStream ( fileOutputStream , digest ) ; digestOutputStream . on ( false ) ; final DataOutputStream dataOutputStream = new DataOutputStream ( digestOutputStream ) ; dataOutputStream . writeBytes ( "CHECKPOINTS-1" ) ; dataOutputStream . writeInt ( 0 ) ; digestOutputStream . on ( true ) ; dataOutputStream . writeInt ( checkpoints . size ( ) ) ; ByteBuffer buffer = ByteBuffer . allocate ( StoredBlock . COMPACT_SERIALIZED_SIZE ) ; for ( StoredBlock block : checkpoints . values ( ) ) { block . serializeCompact ( buffer ) ; dataOutputStream . write ( buffer . array ( ) ) ; buffer . position ( 0 ) ; } dataOutputStream . close ( ) ; Sha256Hash checkpointsHash = new Sha256Hash ( digest . digest ( ) ) ; System . out . println ( "Hash-of-checkpoints-data-is-" + checkpointsHash ) ; digestOutputStream . close ( ) ; fileOutputStream . close ( ) ; System . out . println ( "Checkpoints-written-to-\'" + file . getCanonicalPath ( ) + "\'." ) ; } finally { if ( fileOutputStream != null ) { fileOutputStream . close ( ) ; } } } \n', 0.334265142977678)

('protected static byte [ ] downloadAndSendBinary ( String u , boolean saveOnDisk , File f ) throws IOException { URL url = new URL ( u ) ; Authenticator . setDefault ( new HTTPResourceAuthenticator ( ) ) ; HTTPResourceAuthenticator . addURL ( url ) ; LOGGER . debug ( "Retrieving-" + url . toString ( ) ) ; ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; URLConnection conn = url . openConnection ( ) ; conn . setRequestProperty ( "User-agent" , PropertiesUtil . getProjectProperties ( ) . get ( "project.name" ) + "-" + PMS . getVersion ( ) ) ; InputStream in = conn . getInputStream ( ) ; FileOutputStream fOUT = null ; if ( saveOnDisk && f != null ) { fOUT = new FileOutputStream ( f ) ; } byte buf [ ] = new byte [ 4096 ] ; int n = - 1 ; while ( ( n = in . read ( buf ) ) > - 1 ) { bytes . write ( buf , 0 , n ) ; if ( fOUT != null ) { fOUT . write ( buf , 0 , n ) ; } } in . close ( ) ; if ( fOUT != null ) { fOUT . close ( ) ; } return bytes . toByteArray ( ) ; } \n', 0.33260075707777303)

('private void sendData ( String data ) throws IOException { Socket dataConnection ; if ( isPassive ) dataConnection = dataSocket . accept ( ) ; else dataConnection = new Socket ( dataHost , dataPort ) ; OutputStream dout = new BufferedOutputStream ( dataConnection . getOutputStream ( ) ) ; PrintStream pdout = new PrintStream ( dout ) ; pdout . print ( data ) ; dout . flush ( ) ; dataConnection . close ( ) ; } \n', 0.3324947132350642)

('public boolean binaryTransferSend ( int oid ) { return useBinarySendForOids . contains ( oid ) ; } \n', 0.3304921012872788)

('public FileSendData ( URLConnection data , NameFactory f ) throws IOException { super ( false , new byte [ 128 * 1024 ] , f ) ; in = data . getInputStream ( ) ; filesize = data . getContentLength ( ) ; } \n', 0.329340810463816)

('protected byte [ ] downloadAndSendBinary ( String u , boolean saveOnDisk , File f ) throws IOException { URL url = new URL ( u ) ; PMS . info ( "Retrieving-" + url . toString ( ) ) ; ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; URLConnection conn = url . openConnection ( ) ; conn . setRequestProperty ( "User-agent" , "PS3-Media-Server-v" + PMS . VERSION ) ; InputStream in = conn . getInputStream ( ) ; FileOutputStream fOUT = null ; if ( saveOnDisk && f != null ) { fOUT = new FileOutputStream ( f ) ; } byte buf [ ] = new byte [ 4096 ] ; int n = - 1 ; while ( ( n = in . read ( buf ) ) > - 1 ) { bytes . write ( buf , 0 , n ) ; if ( fOUT != null ) fOUT . write ( buf , 0 , n ) ; } in . close ( ) ; if ( fOUT != null ) fOUT . close ( ) ; return bytes . toByteArray ( ) ; } \n', 0.3290050180706569)

('protected void sendPostData ( JSONObject jsonData ) { try { connection . setDoOutput ( true ) ; connection . setRequestMethod ( "POST" ) ; final byte [ ] postData = jsonData . toString ( ) . getBytes ( ) ; connection . getOutputStream ( ) . write ( postData ) ; } catch ( IOException e ) { return ; } } \n', 0.3288833575929494)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 53 #################################
('public void connect ( String username , String passwd , boolean autoCommit ) throws SQLException { if ( connection != null ) { throw new SQLException ( "connect:-Connection-to-database-\'" + databaseURL + "\'-already-exists!" ) ; } if ( username == null ) { connection = DriverManager . getConnection ( databaseURL ) ; } else { connection = DriverManager . getConnection ( databaseURL , username , passwd ) ; } connection . setAutoCommit ( autoCommit ) ; } \n', 0.36095931133290204)

('public final boolean connect ( ) throws Exception { if ( DBconnection == null ) { if ( ! checkDependency ( ) ) { return false ; } Class . forName ( "com.mysql.jdbc.Driver" ) . newInstance ( ) ; DBconnection = DriverManager . getConnection ( String . format ( "jdbc:mysql://%s:%s/%s?create=true,autoReconnect=true" , sql_hostName , sql_portNum , sql_database ) , sql_username , sql_password ) ; } else { if ( DBconnection . isClosed ( ) ) { DBconnection = DriverManager . getConnection ( String . format ( "jdbc:mysql://%s:%s/%s?create=true,autoReconnect=true" , sql_hostName , sql_portNum , sql_database ) , sql_username , sql_password ) ; } } return DBconnection != null && DBconnection . getCatalog ( ) != null ; } \n', 0.35873365640810106)

('public static void connectToSQLSerrver ( ) { try { Class . forName ( SQLSERVER_JDBC_DRIVER ) . newInstance ( ) ; conn = DriverManager . getConnection ( SQLSERVER_DB_URL ) ; if ( msgON ) { Utils . alertBox ( "layoutLeft" , "Base-dados-aberta" ) ; } } catch ( SQLException ex ) { Utils . alertBox ( "layoutLeft" , "Erro-na-ligao" ) ; } catch ( ClassNotFoundException ex ) { Utils . alertBox ( "layoutLeft" , "Erro-no-Driver" ) ; } catch ( Exception ex ) { Utils . alertBox ( "layoutLeft" , "Erro-genrico-na-ligao" ) ; ex . printStackTrace ( ) ; } finally { try { if ( conn != null ) { conn . close ( ) ; if ( msgON ) { Utils . alertBox ( "SQLSERVER" , "Base-dados-fechada" ) ; } } } catch ( SQLException ex ) { Utils . alertBox ( "layoutLeft" , "Erro-na-ligao" ) ; } } } \n', 0.35830659413601207)

('private void connect ( char [ ] passwd , Properties props , boolean autoCommit ) throws SQLException { if ( connection != null ) { throw new SQLException ( "Connection-to-database-\'" + databaseURL + "\'-already-exists!" ) ; } LogService . getRoot ( ) . log ( Level . CONFIG , "com.rapidminer.tools.jdbc.DatabaseHandler.connecting_to_database" , new Object [ ] { databaseURL , this . user } ) ; DriverManager . setLoginTimeout ( 30 ) ; props . put ( "SetBigStringTryClob" , "true" ) ; if ( this . user != null && ! user . isEmpty ( ) ) { props . put ( "user" , user ) ; props . put ( "password" , new String ( passwd ) ) ; } connection = DriverManager . getConnection ( databaseURL , props ) ; connection . setAutoCommit ( autoCommit ) ; statementCreator = new StatementCreator ( connection ) ; } \n', 0.35451225933449004)

('private void connectMySql ( String url , String user , String password ) throws SQLException { LOG . info ( "Connecting-to-database" ) ; con = DriverManager . getConnection ( url , user , password ) ; con . setAutoCommit ( true ) ; LOG . info ( "Successfully-connected-to-database" ) ; } \n', 0.3539978979021882)

('public Connection connectToMySQL ( ) throws SQLException { try { Class . forName ( "com.mysql.jdbc.Driver" ) ; } catch ( ClassNotFoundException e ) { log . severe ( e . getMessage ( ) ) ; } String url = "jdbc:mysql://" + config . getSQLURL ( ) + ":" + config . getSQLPort ( ) + "/" + config . getSQLDatabaseName ( ) ; return DriverManager . getConnection ( url , config . getSQLUserName ( ) , config . getSQLPassword ( ) ) ; } \n', 0.3539415964730787)

('public boolean connect ( ) throws Exception { if ( connection != null ) { return true ; } if ( currentType == null || currentType == Type . NONE ) { throw new Exception ( "Unknown-Connection-type" ) ; } String className = "" ; if ( currentType == Type . MySQL ) { className = "com.mysql.jdbc.Driver" ; } else { className = "org.sqlite.JDBC" ; } Driver driver ; driver = ( Driver ) Class . forName ( className ) . newInstance ( ) ; Properties properties = new Properties ( ) ; if ( currentType == Type . MySQL ) { properties . put ( "autoReconnect" , "true" ) ; properties . put ( "user" , username ) ; properties . put ( "password" , password ) ; } connection = driver . connect ( "jdbc:" + currentType . toString ( ) . toLowerCase ( ) + ":" + getDatabasePath ( ) , properties ) ; if ( connection == null ) { throw new NullPointerException ( "Connecting-to-database-failed:-unknown-error---using-jdbc:" + currentType . toString ( ) . toLowerCase ( ) + ":" + getDatabasePath ( ) ) ; } connected = true ; return true ; } \n', 0.3494255423967468)

('public boolean connect ( ) throws Exception { if ( connection != null ) return true ; if ( currentType == null || currentType == Type . NONE ) throw new Exception ( "Unknown-Connection-type" ) ; String className = "" ; if ( currentType == Type . MySQL ) { className = "com.mysql.jdbc.Driver" ; } else { className = "org.sqlite.JDBC" ; } Driver driver ; driver = ( Driver ) Class . forName ( className ) . newInstance ( ) ; Properties properties = new Properties ( ) ; if ( currentType == Type . MySQL ) { properties . put ( "autoReconnect" , "true" ) ; properties . put ( "user" , username ) ; properties . put ( "password" , password ) ; } connection = driver . connect ( "jdbc:" + currentType . toString ( ) . toLowerCase ( ) + ":" + getDatabasePath ( ) , properties ) ; if ( connection == null ) throw new NullPointerException ( "Connecting-to-database-failed:-unknown-error---using-jdbc:" + currentType . toString ( ) . toLowerCase ( ) + ":" + getDatabasePath ( ) ) ; connected = true ; return true ; } \n', 0.3494255423967468)

('private void connect ( ) throws SQLException { for ( ; ; ) { try { db = DriverManager . getConnection ( "jdbc:mysql://" + host + ":" + port + "/" + schema , username , password ) ; break ; } catch ( SQLException ex ) { if ( autoCreate && isConnectionIssue ( ex ) && checkSchema ( ) ) { continue ; } throw ex ; } } stmtUpdate = db . createStatement ( ) ; stmtQuery = db . createStatement ( ResultSet . TYPE_FORWARD_ONLY , ResultSet . CONCUR_READ_ONLY ) ; stmtUpdate . execute ( "USE-`" + schema + "`" ) ; stmtQuery . execute ( "USE-`" + schema + "`" ) ; } \n', 0.3468239938478878)

('public void connect ( ) throws IOException { if ( connected ) return ; PreparedStatement stmt = null ; ResultSet rs = null ; try { stmt = SQLUtils . getDefaultConnection ( ) . prepareStatement ( "SELECT-entryName,-entryImage-FROM-sqlj.jar_entry-WHERE-entryId-=-?" ) ; stmt . setInt ( 1 , m_entryId ) ; rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { m_entryName = rs . getString ( 1 ) ; m_image = rs . getBytes ( 2 ) ; connected = true ; } else throw new FileNotFoundException ( "jarId-=-" + m_entryId ) ; } catch ( SQLException e ) { throw new IOException ( e . getMessage ( ) ) ; } finally { SQLUtils . close ( rs ) ; SQLUtils . close ( stmt ) ; } } \n', 0.3428209720501336)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 54 #################################
('public Map < String , TabletMapFile > saveToDisk ( TabletInfo tabletInfo , String fileId ) throws IOException { Map < String , TabletMapFile > result = new HashMap < String , TabletMapFile > ( 10 ) ; for ( Map . Entry < String , ColumnCollection > entry : compactingColumnCollections . entrySet ( ) ) { String columnName = entry . getKey ( ) ; TabletMapFile mapFile = entry . getValue ( ) . saveToDisk ( tabletInfo , columnName , fileId , numOfVersion ) ; if ( mapFile != null ) { result . put ( columnName , mapFile ) ; } } return result ; } \n', 0.3139814107699549)

('private Map < String , TabletMapFile > saveMemoryToDisk ( ) throws IOException { if ( columnCollections == null || columnCollections . isEmpty ( ) ) { return null ; } Map < String , TabletMapFile > savedMapFiles = new HashMap < String , TabletMapFile > ( ) ; for ( Map . Entry < String , ColumnCollection > entry : columnCollections . entrySet ( ) ) { String columnName = entry . getKey ( ) ; TabletMapFile mapFile = entry . getValue ( ) . saveToLocalDisk ( CloudataFileSystem . get ( conf , "local" ) , tabletInfo , columnName , IdGenerator . getId ( ) , uploadActionId , numOfVersion ) ; if ( mapFile != null ) { savedMapFiles . put ( columnName , mapFile ) ; } else { LOG . info ( "saveMemoryToDisk:-mapFile-is-null:columnName=" + columnName ) ; } } return savedMapFiles ; } \n', 0.31079939724373884)

('private TabletMapFile saveToDisk ( CloudataFileSystem fs , TabletInfo tabletInfo , String columnName , GPath parentPath , String fileId , int numOfVersion ) throws IOException { mapLock . readLock ( ) . lock ( ) ; try { if ( columnCollectionMap . isEmpty ( ) ) { return null ; } TabletMapFile tabletMapFile = new TabletMapFile ( conf , fs , tabletInfo , columnName , fileId , parentPath , numOfVersion ) ; MapFileWriter mapFileWriter = tabletMapFile . getMapFileWriter ( ) ; try { for ( Map . Entry < Row . Key , SortedMap < Cell . Key , ValueCollection >> entry : columnCollectionMap . entrySet ( ) ) { for ( Map . Entry < Cell . Key , ValueCollection > eachEntry : entry . getValue ( ) . entrySet ( ) ) { mapFileWriter . write ( eachEntry . getValue ( ) ) ; } } } finally { mapFileWriter . close ( ) ; } return tabletMapFile ; } finally { mapLock . readLock ( ) . unlock ( ) ; } } \n', 0.3096892117284172)

('private void saveUsernameToDisk ( Bridge bridge ) throws JSONException { try { String content = bridge . bridgeToJson ( ) . toString ( ) ; File file = new File ( BRIDGEFILE ) ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } FileWriter fw = new FileWriter ( file . getAbsoluteFile ( ) ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( content ) ; bw . close ( ) ; System . out . println ( "Bridge-saved-to-Disk" ) ; } catch ( IOException e ) { logger . error ( "IOException-when-saving-hue-bridge-info-to-disk" , e ) ; } } \n', 0.3077777762679492)

('private void saveFileEntry ( String prefix , int position , String filename , int syntax , int language , boolean skip , boolean noReasoner , boolean onDisk , String tdbDir , boolean persistent ) { appPrefs . put ( prefix + PREF_RECENT_FILENAME + position , filename ) ; appPrefs . putInt ( prefix + PREF_RECENT_SYNTAX + position , syntax ) ; appPrefs . putInt ( prefix + PREF_RECENT_LANGUAGE + position , language ) ; appPrefs . putBoolean ( prefix + PREF_RECENT_SKIP + position , skip ) ; appPrefs . putBoolean ( prefix + PREF_RECENT_REASONER + position , noReasoner ) ; appPrefs . putBoolean ( prefix + PREF_RECENT_ONDISK + position , onDisk ) ; appPrefs . put ( prefix + PREF_RECENT_ONDISKDIRECTORY + position , tdbDir ) ; appPrefs . putBoolean ( prefix + PREF_RECENT_ONDISKPERSISTENT + position , persistent ) ; } \n', 0.3070762063446757)

('public static void storeMetadataToDisk ( List < MetadataEntry > metadata , File destinationDir ) { try { for ( MetadataEntry m : metadata ) { File mFile = new File ( destinationDir , UUID . randomUUID ( ) . toString ( ) + ".ser" ) ; FileOutputStream fos = new FileOutputStream ( mFile ) ; ObjectOutputStream out = new ObjectOutputStream ( fos ) ; out . writeObject ( m ) ; fos . close ( ) ; } } catch ( IOException e ) { throw new IOFailure ( "Unable-to-store-metadata-temporarily-in-directory-\'-" + destinationDir . getAbsolutePath ( ) + "\'" , e ) ; } } \n', 0.3048485866988435)

('protected List saveDataToLocalDisk ( String prefix , Object loadId , boolean changeLinks ) throws Exception { List newFiles = super . saveDataToLocalDisk ( prefix , loadId , changeLinks ) ; if ( newFiles == null ) { return newFiles ; } for ( int i = 0 ; i < newFiles . size ( ) ; i ++ ) { try { RandomAccessFile to = new RandomAccessFile ( ( String ) newFiles . get ( i ) , "rw" ) ; to . seek ( 0 ) ; to . writeInt ( 0 ) ; to . close ( ) ; } catch ( Exception e ) { System . out . println ( "unable-to-set-first-word-to-0" ) ; } } return newFiles ; } \n', 0.3045342341469458)

('public static Map < Guid , List < DiskImage >> buildStorageToDiskMap ( Collection < DiskImage > images , Map < Guid , DiskImage > diskInfoDestinationMap ) { Map < Guid , List < DiskImage >> storageToDisksMap = new HashMap < > ( ) ; for ( DiskImage disk : images ) { DiskImage diskImage = diskInfoDestinationMap . get ( disk . getId ( ) ) ; Guid storageDomainId = diskImage . getStorageIds ( ) . get ( 0 ) ; List < DiskImage > diskList = storageToDisksMap . get ( storageDomainId ) ; if ( diskList == null ) { diskList = new ArrayList < > ( ) ; storageToDisksMap . put ( storageDomainId , diskList ) ; } diskList . add ( disk ) ; } return storageToDisksMap ; } \n', 0.30412821529863754)

('private static void copyMemoryStoreToDiskStore ( LocalStore store ) { if ( store != null ) { Map < Object , Object > snapshot = store . memoryStore . snapshot ( ) ; Set < Map . Entry < Object , Object >> entries = snapshot . entrySet ( ) ; for ( Map . Entry < Object , Object > entry : entries ) { FileOutputStream fileOutputStream = null ; String fileName ; try { String key = entry . getKey ( ) . toString ( ) ; fileName = URLEncoder . encode ( key , Charset . defaultCharset ( ) . name ( ) ) ; File file = new File ( store . diskStore , fileName ) ; String json = JsonParser . toJson ( entry . getValue ( ) ) ; fileOutputStream = new FileOutputStream ( file ) ; fileOutputStream . write ( json . getBytes ( ) ) ; } catch ( UnsupportedEncodingException e ) { break ; } catch ( FileNotFoundException e ) { } catch ( IOException e ) { } finally { Utils . closeSilently ( fileOutputStream ) ; } } } } \n', 0.3039754281807723)

('private void updateDiskSnapshotsMap ( ) { if ( snapshots . getItems ( ) == null ) { return ; } for ( SnapshotModel snapshotModel : ( List < SnapshotModel > ) snapshots . getItems ( ) ) { for ( DiskImage diskImage : snapshotModel . getEntity ( ) . getDiskImages ( ) ) { ListModel disksListModel ; if ( diskSnapshotsMap . containsKey ( diskImage . getId ( ) ) ) { disksListModel = diskSnapshotsMap . get ( diskImage . getId ( ) ) ; ( ( ArrayList < DiskImage > ) disksListModel . getItems ( ) ) . add ( diskImage ) ; } else { disksListModel = new ListModel ( ) ; disksListModel . setItems ( new ArrayList < DiskImage > ( Arrays . asList ( diskImage ) ) ) ; } diskSnapshotsMap . put ( diskImage . getId ( ) , disksListModel ) ; } } } \n', 0.30323131864539)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 55 #################################
('public static String caseInsensitiveSubstring ( String value , String regularExpression ) throws SQLException { try { Pattern p = Pattern . compile ( regularExpression , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( ( value == null ) ? "" : value ) ; if ( m . find ( ) ) return m . group ( 1 ) ; return "" ; } catch ( IndexOutOfBoundsException e ) { return value ; } catch ( PatternSyntaxException e ) { throw new SQLException ( "Pattern-syntax-exception:-" + e . getMessage ( ) ) ; } } \n', 0.36188210027456286)

('private Pattern getWordPattern ( final WordSearchQueryImpl searchQuery ) { final Set < Character > usedLetters = searchQuery . getUsedLetters ( ) ; final StringBuilder usedLettersRegexBuilder = new StringBuilder ( ) ; final String usedLettersRegex ; final StringBuilder regexStringBuilder = new StringBuilder ( ) ; if ( usedLetters . isEmpty ( ) ) { usedLettersRegexBuilder . append ( "." ) ; } else { usedLettersRegexBuilder . append ( "[^" ) ; for ( final char usedLetter : usedLetters ) { usedLettersRegexBuilder . append ( usedLetter ) ; } usedLettersRegexBuilder . append ( "]" ) ; } usedLettersRegex = usedLettersRegexBuilder . toString ( ) ; for ( int charIdx = 0 ; charIdx < searchQuery . getWordLength ( ) ; charIdx ++ ) { final Character knownLetter = searchQuery . getKnownLetters ( ) . get ( charIdx ) ; regexStringBuilder . append ( knownLetter != null ? knownLetter : usedLettersRegex ) ; } return Pattern . compile ( regexStringBuilder . toString ( ) , Pattern . CASE_INSENSITIVE ) ; } \n', 0.3503134772038529)

('public static Pattern caseInsensitive ( String pattern ) { return Pattern . compile ( pattern , Pattern . CASE_INSENSITIVE ) ; } \n', 0.34838204171411646)

('public Pattern getFilenamePattern ( ) { if ( filenamePattern == null && filename != null && filename . length ( ) > 0 ) { int flags = 0 ; String pattern = filename ; if ( ! filenameRegex ) { pattern = Utils . escapeRegexMetaChar ( pattern ) ; } flags |= filenameMatch ? flags : Pattern . CASE_INSENSITIVE ; filenamePattern = Pattern . compile ( pattern , flags ) ; } return filenamePattern ; } \n', 0.34571233854169936)

('CaseInsensitivePartialStringComparisionMatcher ( String textToMatch ) { this . textToMatch = textToMatch ; this . pattern = Pattern . compile ( Pattern . quote ( textToMatch ) , Pattern . CASE_INSENSITIVE ) ; } \n', 0.34352824198139376)

('private static Pattern toRegex ( String key ) { Pattern pattern ; String patternKey ; if ( isRegex || key . startsWith ( "re:" ) ) { if ( key . startsWith ( "re:" ) ) { patternKey = key . substring ( 3 , key . length ( ) ) ; } else { patternKey = key ; } if ( ! isFuzzy && ! patternKey . startsWith ( "^" ) ) { pattern = Pattern . compile ( "^" + patternKey , Pattern . CASE_INSENSITIVE ) ; } else { pattern = Pattern . compile ( patternKey , Pattern . CASE_INSENSITIVE ) ; } } else { patternKey = key . replace ( "|" , "|u005C" ) . replace ( "." , "|u002E" ) . replace ( "$" , "|u0024" ) . replace ( "^" , "|u005E" ) . replace ( "{" , "|u007B" ) . replace ( "[" , "|u005B" ) . replace ( "(" , "|u0028" ) . replace ( ")" , "|u0029" ) . replace ( "+" , "|u002B" ) . replace ( "*" , "[|s|S]*" ) . replace ( "?" , "[|s|S]" ) ; if ( isFuzzy ) { pattern = Pattern . compile ( patternKey , Pattern . CASE_INSENSITIVE ) ; } else { pattern = Pattern . compile ( "^" + patternKey , Pattern . CASE_INSENSITIVE ) ; } } return pattern ; } \n', 0.3430348002412614)

('private static boolean caseInsensitiveFind ( String subString , String longString ) { if ( TextUtils . isEmpty ( subString ) || TextUtils . isEmpty ( longString ) ) { return false ; } Pattern pattern = Pattern . compile ( "(|W|^)" + subString + "(|W|$)" , Pattern . CASE_INSENSITIVE ) ; return pattern . matcher ( longString ) . find ( ) ; } \n', 0.34112347497764095)

('public static boolean caseInsensitiveFind ( String subString , String longString ) { if ( TextUtils . isEmpty ( subString ) || TextUtils . isEmpty ( longString ) ) { return false ; } Pattern pattern = Pattern . compile ( "(|W|^)" + subString + "(|W|$)" , Pattern . CASE_INSENSITIVE ) ; return pattern . matcher ( longString ) . find ( ) ; } \n', 0.34112347497764095)

('CaseInsensitiveTextStrategy ( final int field , final Calendar definingCalendar , final Locale locale ) { this . field = field ; this . locale = locale ; StringBuilder regex = new StringBuilder ( ) ; regex . append ( "((?iu)" ) ; appendDisplayNames ( definingCalendar , locale , field , regex , lKeyValues ) ; regex . setLength ( regex . length ( ) - 1 ) ; regex . append ( ")" ) ; createPattern ( regex ) ; } \n', 0.34094054701361576)

('private int getPatternCompileFlags ( String regex ) { for ( char c : regex . toCharArray ( ) ) { if ( Character . isUpperCase ( c ) ) { return 0 ; } } return Pattern . CASE_INSENSITIVE ; } \n', 0.340915559503321)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 56 #################################
('private Node selectMedian ( Graph g ) { int index = 0 ; double [ ] tempArr = new double [ nvl . length ] ; for ( int i = 0 ; i < nvl . length ; i ++ ) { tempArr [ i ] = nvl [ i ] ; } Arrays . sort ( tempArr ) ; double median = tempArr [ nvl . length / 2 ] ; for ( int i = 0 ; i < nvl . length ; i ++ ) { if ( nvl [ i ] == median ) { index = i ; break ; } } return g . getNode ( index ) ; } \n', 0.36502362156533763)

('private List < T > selectMedian ( List < T > list , int dim , int pos ) { if ( list . size ( ) == 1 ) { return list ; } int pivotIndex = ( int ) ( Math . random ( ) * list . size ( ) ) ; double pivot = list . get ( pivotIndex ) . getDimension ( dim ) ; ArrayList < T > SL = new ArrayList < T > ( ) ; ArrayList < T > SV = new ArrayList < T > ( ) ; ArrayList < T > SR = new ArrayList < T > ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( list . get ( i ) . getDimension ( dim ) < pivot ) { SL . add ( list . get ( i ) ) ; } else if ( list . get ( i ) . getDimension ( dim ) > pivot ) { SR . add ( list . get ( i ) ) ; } else { SV . add ( list . get ( i ) ) ; } } if ( pos < SL . size ( ) ) { return selectMedian ( SL , dim , pos ) ; } else if ( pos >= SL . size ( ) + SV . size ( ) ) { return selectMedian ( SR , dim , pos - SL . size ( ) - SV . size ( ) ) ; } else { return SV ; } } \n', 0.3499892140925923)

('public static double [ ] getColumnMedians ( final RealMatrix m ) { Utils . nonNull ( m , "Cannot-calculate-medians-on-a-null-matrix." ) ; final Median medianCalculator = new Median ( ) ; return IntStream . range ( 0 , m . getColumnDimension ( ) ) . boxed ( ) . mapToDouble ( i -> medianCalculator . evaluate ( m . getColumn ( i ) ) ) . toArray ( ) ; } \n', 0.33734742459301736)

('public LinkedHashMap < Bytes , List < CounterColumn >> getCounterColumnsFromRows ( String columnFamily , List < Bytes > rowKeys , boolean reversed , ConsistencyLevel cLevel ) throws PelopsException { return getCounterColumnsFromRows ( newColumnParent ( columnFamily ) , rowKeys , columnsPredicateAll ( reversed ) , cLevel ) ; } \n', 0.3358289202131195)

('public LinkedHashMap < String , List < CounterColumn >> getCounterColumnsFromRowsUtf8Keys ( String columnFamily , List < String > rowKeys , boolean reversed , ConsistencyLevel cLevel ) throws PelopsException { return getCounterColumnsFromRowsUtf8Keys ( newColumnParent ( columnFamily ) , rowKeys , columnsPredicateAll ( reversed ) , cLevel ) ; } \n', 0.33461790588308127)

('private double Median ( Hashtable < SensorType , ArrayList < Double >> data , SensorType sensor , ObjectSegmentation index ) { double median = 0 ; ArrayList < Double > d = new ArrayList < Double > ( ) ; for ( int i = index . start ; i <= index . finish ; i ++ ) if ( ! Double . isNaN ( data . get ( sensor ) . get ( i ) ) ) d . add ( data . get ( sensor ) . get ( i ) ) ; Collections . sort ( d ) ; if ( d . size ( ) % 2 == 0 ) median = ( d . get ( d . size ( ) / 2 ) + d . get ( ( d . size ( ) / 2 ) - 1 ) ) / 2 ; else median = d . get ( d . size ( ) / 2 ) ; return median ; } \n', 0.3325986515741872)

('public LinkedHashMap < String , List < CounterColumn >> getSubCounterColumnsFromRowsUtf8Keys ( String columnFamily , List < String > rowKeys , String superColName , boolean reversed , ConsistencyLevel cLevel ) throws PelopsException { return getCounterColumnsFromRowsUtf8Keys ( newColumnParent ( columnFamily , superColName ) , rowKeys , columnsPredicateAll ( reversed ) , cLevel ) ; } \n', 0.33225175819404773)

('private LinkedHashMap < Bytes , List < Column >> getColumnsFromRows ( final ColumnParent colParent , final KeyRange keyRange , final SlicePredicate colPredicate , final ConsistencyLevel cLevel ) throws PelopsException { return transformKeySlices ( getKeySlices ( colParent , keyRange , colPredicate , cLevel ) , COLUMN ) ; } \n', 0.3301554722841743)

('private static Object findMedian ( List list ) { if ( list . size ( ) < 1 ) { return null ; } Object median ; Collections . sort ( list ) ; int index = - 1 ; index = ( int ) list . size ( ) / 2 ; if ( ( list . size ( ) % 2 ) == 0 ) { Object input1 = list . get ( index - 1 ) ; Object input2 = list . get ( index ) ; if ( ( input1 instanceof Number ) && ( input2 instanceof Number ) ) { Number num1 = ( Number ) input1 ; Number num2 = ( Number ) input2 ; Number [ ] numbers = new Number [ 2 ] ; numbers [ 0 ] = num1 ; numbers [ 1 ] = num2 ; median = CalcUtil . average ( numbers ) ; } else { List newList = new ArrayList ( ) ; newList . add ( input1 ) ; newList . add ( input2 ) ; median = newList ; } } else { median = list . get ( index ) ; } return median ; } \n', 0.3297661068141715)

('public Map < Bytes , List < CounterColumn >> getSubCounterColumnsFromRows ( String columnFamily , List < Bytes > rowKeys , String superColName , boolean reversed , ConsistencyLevel cLevel ) throws PelopsException { return getCounterColumnsFromRows ( newColumnParent ( columnFamily , superColName ) , rowKeys , columnsPredicateAll ( reversed ) , cLevel ) ; } \n', 0.32934466163771076)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 57 #################################
('private byte [ ] filter ( byte [ ] unfiltered , FilterType filterType ) throws InvalidFormatException { ByteHolder filtered = new ByteHolder ( unfiltered . length + 1 ) ; switch ( filterMethod ) { case ADAPTIVE : filtered . add ( ( byte ) filterType . dataValue ( ) ) ; filtered . add ( filterType . filter ( unfiltered , lastData , getBpp ( ) ) ) ; break ; default : throw new InvalidFormatException ( "Bad-filter-method!" , "png" ) ; } lastData = unfiltered ; return filtered . toArray ( ) ; } \n', 0.3764645501302265)

('public static Object [ ] filterArray ( Object [ ] array ) { ArrayList < Object > list = new ArrayList < > ( array . length ) ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( ! filterItem ( array [ i ] ) ) { list . add ( array [ i ] ) ; } } return list . toArray ( ( Object [ ] ) Array . newInstance ( array . getClass ( ) . getComponentType ( ) , list . size ( ) ) ) ; } \n', 0.3757407422281108)

('public static Object [ ] filterArray ( Object [ ] array ) { ArrayList list = new ArrayList ( array . length ) ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( ! filterItem ( array [ i ] ) ) { list . add ( array [ i ] ) ; } } return list . toArray ( ( Object [ ] ) Array . newInstance ( array . getClass ( ) . getComponentType ( ) , array . length ) ) ; } \n', 0.37256239287363657)

('public static < T > Object [ ] filter ( T [ ] elems , Filter < T > filter ) { List < T > filtered = new ArrayList < T > ( ) ; for ( int i = 0 ; i < elems . length ; i ++ ) { if ( filter . accept ( elems [ i ] ) ) { filtered . add ( elems [ i ] ) ; } } return ( filtered . toArray ( ( Object [ ] ) Array . newInstance ( elems . getClass ( ) . getComponentType ( ) , filtered . size ( ) ) ) ) ; } \n', 0.37039968787237343)

('public static Object [ ] filterArray ( Object [ ] array ) { org . simonme . tracer . logger . Tracer . traceMethodInvoke ( array ) ; ArrayList list = new ArrayList ( array . length ) ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( ! filterItem ( array [ i ] ) ) { list . add ( array [ i ] ) ; } } return list . toArray ( ( Object [ ] ) Array . newInstance ( array . getClass ( ) . getComponentType ( ) , list . size ( ) ) ) ; } \n', 0.36652928446084077)

('protected Object [ ] filter ( ViewerFilter [ ] filters , Object [ ] elements ) { if ( filters != null ) { ArrayList filtered = new ArrayList ( elements . length ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { boolean add = true ; for ( int j = 0 ; j < filters . length ; j ++ ) { add = filters [ j ] . select ( null , null , elements [ i ] ) ; if ( ! add ) break ; } if ( add ) filtered . add ( elements [ i ] ) ; } return filtered . toArray ( ) ; } return elements ; } \n', 0.36435890097828266)

('public final Object [ ] filter ( final Object [ ] objects ) { final Collection filtered = filter ( Arrays . asList ( objects ) ) ; try { return filtered . toArray ( ( Object [ ] ) Array . newInstance ( objects . getClass ( ) , filtered . size ( ) ) ) ; } catch ( ArrayStoreException ase ) { Log log = LogFactory . getLog ( Filter . class ) ; log . warn ( "Error-converting-to-array---using-default-approach" , ase ) ; } return filtered . toArray ( ) ; } \n', 0.35595333592804146)

('protected Object [ ] filter ( Object [ ] elements ) { if ( filters != null ) { ArrayList filtered = new ArrayList ( elements . length ) ; Object root = getRoot ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { boolean add = true ; for ( int j = 0 ; j < filters . size ( ) ; j ++ ) { add = ( ( ViewerFilter ) filters . get ( j ) ) . select ( this , root , elements [ i ] ) ; if ( ! add ) { break ; } } if ( add ) { filtered . add ( elements [ i ] ) ; } } return filtered . toArray ( ) ; } return elements ; } \n', 0.35531489327755744)

('public static Parameter [ ] filter ( final Parameter [ ] parameters , final Set < InjectableParameter > filters ) { if ( filters != null && ! filters . isEmpty ( ) ) { boolean firstMethodFiltered = false ; final List < Parameter > filterList = new ArrayList < > ( parameters . length ) ; for ( final Parameter parameter : parameters ) { boolean omit = false ; for ( final InjectableParameter injectableParameter : filters ) { omit = canInject ( parameter , injectableParameter ) ; switch ( injectableParameter ) { case CURRENT_TEST_METHOD : if ( omit && ! firstMethodFiltered ) { firstMethodFiltered = true ; } else { omit = false ; } break ; default : break ; } if ( omit ) { break ; } } if ( ! omit ) { filterList . add ( parameter ) ; } } final Parameter [ ] filteredArray = new Parameter [ filterList . size ( ) ] ; return filterList . toArray ( filteredArray ) ; } else { return parameters ; } } \n', 0.35206271455992644)

('public static < E > Object [ ] filter ( E [ ] elems , Filter < E > filter ) { List < E > filtered = new ArrayList < E > ( ) ; for ( E elem : elems ) { if ( filter . accept ( elem ) ) { filtered . add ( elem ) ; } } return ( filtered . toArray ( ( Object [ ] ) Array . newInstance ( elems . getClass ( ) . getComponentType ( ) , filtered . size ( ) ) ) ) ; } \n', 0.35087673133606845)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 58 #################################
('public static < T > T selectRandomlyFromList ( List < T > l ) { int index = r . nextInt ( l . size ( ) ) ; return l . get ( index ) ; } \n', 0.39454476282713663)

('public static < T > T selectRandomlyFromList ( List < T > l ) { return l . get ( _r . nextInt ( l . size ( ) ) ) ; } \n', 0.38869513463214045)

('private < T > T pickRandomlyFromList ( final List < T > list ) { return list . get ( random . nextInt ( list . size ( ) ) ) ; } \n', 0.36857932441765784)

('public static < E > List < E > pickRandomly ( List < E > from , List < E > to , int howMany ) { Assert . Arg . notNull ( from , "from" ) ; Assert . Arg . notNull ( to , "to" ) ; howMany = Math . min ( howMany , from . size ( ) ) ; TreeSet < Integer > pickedIndexes = new TreeSet < Integer > ( ) ; Random random = new Random ( ) ; for ( int i = 0 ; i < howMany ; i ++ ) { int picked = Utils . getRandomWithExclusion ( random , howMany , pickedIndexes ) ; pickedIndexes . add ( picked ) ; to . add ( from . get ( picked ) ) ; } return to ; } \n', 0.3354175245958198)

('public Sequence extractItem ( String s ) { Sequence extractSeq = this . copySeqence ( ) ; ItemSet itemSet ; ArrayList < String > items ; ArrayList < ItemSet > deleteItemSets = new ArrayList < > ( ) ; ArrayList < String > tempItems = new ArrayList < > ( ) ; for ( int k = 0 ; k < extractSeq . itemSetList . size ( ) ; k ++ ) { itemSet = extractSeq . itemSetList . get ( k ) ; items = itemSet . getItems ( ) ; if ( items . size ( ) == 1 && items . get ( 0 ) . equals ( s ) ) { extractSeq . itemSetList . remove ( k ) ; break ; } else if ( items . size ( ) > 1 && ! items . get ( 0 ) . equals ( "_" ) ) { if ( items . contains ( s ) ) { int index = items . indexOf ( s ) ; for ( int j = index ; j < items . size ( ) ; j ++ ) { tempItems . add ( items . get ( j ) ) ; } tempItems . set ( 0 , "_" ) ; if ( tempItems . size ( ) == 1 ) { deleteItemSets . add ( itemSet ) ; } else { extractSeq . itemSetList . set ( k , new ItemSet ( tempItems ) ) ; } break ; } else { deleteItemSets . add ( itemSet ) ; } } else { deleteItemSets . add ( itemSet ) ; } } extractSeq . itemSetList . removeAll ( deleteItemSets ) ; return extractSeq ; } \n', 0.33331571838016594)

('protected List < PromotableOrderItemPriceDetail > buildPriceDetailListFromOrderItems ( List < PromotableOrderItem > items ) { List < PromotableOrderItemPriceDetail > itemPriceDetails = new ArrayList < PromotableOrderItemPriceDetail > ( ) ; for ( PromotableOrderItem item : items ) { for ( PromotableOrderItemPriceDetail detail : item . getPromotableOrderItemPriceDetails ( ) ) { itemPriceDetails . add ( detail ) ; } } return itemPriceDetails ; } \n', 0.3230774010987178)

('private Collection < String > extractItemsFromList ( final String s ) { final Collection < String > results = new ArrayList < String > ( ) ; for ( final String item : s . split ( "," ) ) { results . add ( item . trim ( ) ) ; } return results ; } \n', 0.3113652803382277)

('public static < T > List < T > extractFirst ( int pNumToExtract , Collection < T > pCol ) { Iterator < T > objects = pCol . iterator ( ) ; ArrayList < T > result = new ArrayList < T > ( pNumToExtract ) ; int numExtracted = 0 ; while ( objects . hasNext ( ) && numExtracted < pNumToExtract ) { result . add ( objects . next ( ) ) ; numExtracted ++ ; } return result ; } \n', 0.30954967763577)

('private Collection < String > extractItemsFromList ( final String notifiersDefined ) { Collection < String > results = new ArrayList < String > ( ) ; for ( String item : notifiersDefined . split ( "," ) ) { results . add ( item . trim ( ) ) ; } return results ; } \n', 0.30257488911000086)

('private List < Cake2DataflowWrapperObject > extractDataItems ( List < Cake2DataReferenceObject > dataRefs ) { List < Cake2DataflowWrapperObject > dataItems = new LinkedList < Cake2DataflowWrapperObject > ( ) ; for ( Cake2DataReferenceObject curRef : dataRefs ) { dataItems . add ( curRef . getDataItem ( ) ) ; } return dataItems ; } \n', 0.3020271384783399)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 59 #################################
('public static String encryptPasswordWithSymmetricEncryption ( String password , String passPhrase ) throws Exception { Cipher aes = Cipher . getInstance ( ALGORITHM_MODE_PADDING ) ; MessageDigest digest = MessageDigest . getInstance ( SHA1_ALGORITHM ) ; digest . update ( passPhrase . getBytes ( ENCODING ) ) ; byte [ ] key = Arrays . copyOf ( digest . digest ( ) , 16 ) ; SecretKeySpec secretKeySpec = new SecretKeySpec ( key , ALGORITHM ) ; aes . init ( Cipher . ENCRYPT_MODE , secretKeySpec , DEFAULT_IV_SPEC ) ; byte [ ] b = aes . doFinal ( password . getBytes ( ENCODING ) ) ; return Base64 . encodeBase64String ( b ) ; } \n', 0.3641564435089455)

('public static String encryptByAes ( String text ) throws NubeException { try { return new String ( Base64 . getEncoder ( ) . encode ( aesCipherForEncrypt . doFinal ( text . getBytes ( ) ) ) ) ; } catch ( Exception e ) { throw new NubeException ( 603 , "encryption_error" , e ) ; } } \n', 0.3589272870927365)

('private static String encryptString ( String message , String passcode ) { String encryptedMessage = "" ; try { byte [ ] encryptMessage = DESEncryptionHelper . encryptMessage ( passcode . getBytes ( ) , message . getBytes ( ) ) ; encryptedMessage = Utilities . getBase64EncodedString ( encryptMessage ) ; } catch ( Exception e ) { } return encryptedMessage ; } \n', 0.3586979737600001)

('public static String aes256Decrypt ( String encrypted , String encryptionKey ) { String decrypted = "" ; try { decrypted = AES . decrypt ( HexTobyte ( encrypted ) , encryptionKey ) ; } catch ( Exception e ) { LOGGER . pushErrors ( e , "Decryption-failed." ) ; } return decrypted . split ( "~" ) [ 0 ] ; } \n', 0.34866146634843953)

('public void encryptStream ( InputStream clearInputStream , OutputStream encryptedOutputStream ) throws IOException , MissingParameterException { byte [ ] clearBytes = IOUtils . toByteArray ( clearInputStream ) ; byte [ ] cipherBytes = encryptionProvider . encrypt ( clearBytes ) ; encryptedOutputStream . write ( cipherBytes ) ; encryptedOutputStream . flush ( ) ; encryptedOutputStream . close ( ) ; } \n', 0.3433673032853409)

('private void encryptOuputStream ( ) throws IOException { socketOutputStream . flush ( ) ; isOutputEncrypted = true ; socketOutputStream = new DataOutputStream ( new BufferedOutputStream ( CryptManager . encryptOuputStream ( sharedKeyForEncryption , networkSocket . getOutputStream ( ) ) , 5120 ) ) ; } \n', 0.34102376460605954)

('public synchronized String encryptPassword ( String password ) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; CipherOutputStream cos = new CipherOutputStream ( baos , encryptCipherAES ) ; ObjectOutputStream oos = new ObjectOutputStream ( cos ) ; oos . writeObject ( password ) ; oos . flush ( ) ; oos . close ( ) ; return Helper . buildHexStringFromBytes ( baos . toByteArray ( ) ) ; } catch ( Exception e ) { throw ValidationException . errorEncryptingPassword ( e ) ; } } \n', 0.33762260382690046)

('private String doAESEncryption ( SecretKey key ) throws Exception { Cipher cipher = Cipher . getInstance ( SYMMETRICENCRYPTIONALGORITHM ) ; IvParameterSpec iv = getInitialisationVector ( ) ; cipher . init ( Cipher . ENCRYPT_MODE , key , iv ) ; byte [ ] c = cipher . doFinal ( payloadBody . getBytes ( "UTF-8" ) ) ; Base64 b64 = new Base64 ( ) ; byte [ ] content = b64 . encode ( c ) ; StringBuilder sb = new StringBuilder ( "<xenc:CipherData><xenc:CipherValue>" ) ; sb . append ( new String ( content ) ) ; sb . append ( "</xenc:CipherValue></xenc:CipherData>" ) ; return sb . toString ( ) ; } \n', 0.33186625072867115)

('public static String v0EncryptAndEncodeKey ( byte [ ] key , byte [ ] iv , byte [ ] masterKey , byte [ ] masterIV ) { ByteArrayOutputStream cryptOut = new ByteArrayOutputStream ( ) ; try ( InputStream is = new SequenceInputStream ( new ByteArrayInputStream ( key ) , new ByteArrayInputStream ( iv ) ) ) { StreamingBouncyCastleAESWithSIC . encrypt ( is , cryptOut , masterKey , masterIV ) ; StringBuilder result = new StringBuilder ( new String ( Base64 . encode ( cryptOut . toByteArray ( ) ) , StreamingBouncyCastleAESWithSIC . ASCII ) ) ; result . append ( \'$\' ) ; result . append ( Integer . toString ( key . length ) ) ; return result . toString ( ) ; } catch ( InvalidCipherTextException | IOException e ) { throw new IllegalArgumentException ( "Cannot-encrypt-provided-key-and-initialization-vector" , e ) ; } } \n', 0.33167855747788777)

('public int importKeysAndEncrypt ( final List < ECKey > keys , KeyParameter aesKey ) { lock . lock ( ) ; try { return keychain . importKeysAndEncrypt ( keys , aesKey ) ; } finally { lock . unlock ( ) ; } } \n', 0.33099110531475373)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 60 #################################
('public void removeUnique ( int i ) { synchronized ( monitor ( ) ) { check_orphaned ( ) ; get_store ( ) . remove_element ( UNIQUE$4 , i ) ; } } \n', 0.3511213448555555)

('@ Override public String getUniqueElementId ( HttpServletRequest request , String namespace , String elementId ) { String uniqueElementId = elementId ; Set < String > uniqueElementIds = ( Set < String > ) request . getAttribute ( WebKeys . UNIQUE_ELEMENT_IDS ) ; if ( uniqueElementIds == null ) { uniqueElementIds = new ConcurrentHashSet < > ( ) ; request . setAttribute ( WebKeys . UNIQUE_ELEMENT_IDS , uniqueElementIds ) ; } else { int i = 1 ; while ( uniqueElementIds . contains ( namespace . concat ( uniqueElementId ) ) ) { if ( Validator . isNull ( elementId ) || elementId . endsWith ( StringPool . UNDERLINE ) ) { uniqueElementId = elementId . concat ( String . valueOf ( i ) ) ; } else { uniqueElementId = elementId . concat ( StringPool . UNDERLINE ) . concat ( String . valueOf ( i ) ) ; } i ++ ; } } uniqueElementIds . add ( namespace . concat ( uniqueElementId ) ) ; return uniqueElementId ; } \n', 0.3425084308880108)

('static Object uniqueElement ( List list ) throws NonUniqueResultException { int size = list . size ( ) ; if ( size == 0 ) { return null ; } Object first = list . get ( 0 ) ; for ( int i = 1 ; i < size ; i ++ ) { if ( list . get ( i ) != first ) { throw new NonUniqueResultException ( list . size ( ) ) ; } } return first ; } \n', 0.34185787368663567)

('public static Object uniqueElement ( List list ) throws NonUniqueResultException { int size = list . size ( ) ; if ( size == 0 ) return null ; Object first = list . get ( 0 ) ; for ( int i = 1 ; i < size ; i ++ ) { if ( list . get ( i ) != first ) { throw new NonUniqueResultException ( list . size ( ) ) ; } } return first ; } \n', 0.33576616880834353)

('private static void setUniqueIdReferences ( final Node node , final String id , final String fixedId ) { final NamedNodeMap attributes = node . getAttributes ( ) ; if ( attributes != null ) { for ( int i = 0 ; i < attributes . getLength ( ) ; ++ i ) { final String attibuteValue = attributes . item ( i ) . getNodeValue ( ) ; if ( attibuteValue . equals ( id ) ) { attributes . item ( i ) . setNodeValue ( fixedId ) ; } } } final NodeList elements = node . getChildNodes ( ) ; for ( int i = 0 ; i < elements . getLength ( ) ; ++ i ) { setUniqueIdReferences ( elements . item ( i ) , id , fixedId ) ; } } \n', 0.3284028107643321)

('public static HashSet < Integer > getUniqueElements ( int [ ] values ) { HashSet < Integer > unique = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < values . length ; i ++ ) unique . add ( values [ i ] ) ; return unique ; } \n', 0.3249926138021823)

('protected Tag getUniqueTag ( ItemBase item ) throws OpsException { for ( Tag tag : item . getTags ( ) ) { if ( tag . getKey ( ) . equals ( Tag . UNIQUE_ID ) ) { return tag ; } } throw new OpsException ( "Cannot-find-unique-tag-for-item:-" + item ) ; } \n', 0.32198387166842546)

('private static Set getUniqueElementsAncestry ( Set elementSet ) { Iterator it = elementSet . iterator ( ) ; EObject container = null ; while ( it . hasNext ( ) ) { container = ( ( EObject ) it . next ( ) ) . eContainer ( ) ; while ( container != null ) { if ( elementSet . contains ( container ) ) { it . remove ( ) ; break ; } container = container . eContainer ( ) ; } } return elementSet ; } \n', 0.3196462764911048)

('public static Set getUniqueElementsAncestry ( Set elementSet ) { assert elementSet != null ; Iterator it = elementSet . iterator ( ) ; EObject container = null ; while ( it . hasNext ( ) ) { container = ( ( EObject ) it . next ( ) ) . eContainer ( ) ; while ( container != null ) { if ( elementSet . contains ( container ) ) { it . remove ( ) ; break ; } container = container . eContainer ( ) ; } } return elementSet ; } \n', 0.3196462764911048)

('private static void addUniqueOid ( Vector v , Oid anOid ) { for ( Enumeration e = v . elements ( ) ; e . hasMoreElements ( ) ; ) { if ( ( ( Oid ) e . nextElement ( ) ) . equals ( anOid ) ) return ; } v . addElement ( anOid ) ; } \n', 0.319537526167086)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 61 #################################
('public double [ ] [ ] confusionMatrix ( ) { double [ ] [ ] newMatrix = new double [ m_ConfusionMatrix . length ] [ 0 ] ; for ( int i = 0 ; i < m_ConfusionMatrix . length ; i ++ ) { newMatrix [ i ] = new double [ m_ConfusionMatrix [ i ] . length ] ; System . arraycopy ( m_ConfusionMatrix [ i ] , 0 , newMatrix [ i ] , 0 , m_ConfusionMatrix [ i ] . length ) ; } return newMatrix ; } \n', 0.3778165088808644)

('public double [ ] [ ] confusionMatrix ( ) { double [ ] [ ] newMatrix = new double [ m_ConfusionMatrix . length ] [ 0 ] ; for ( int i = 0 ; i < m_ConfusionMatrix . length ; i ++ ) { newMatrix [ i ] = new double [ m_ConfusionMatrix [ i ] . length ] ; System . arraycopy ( m_ConfusionMatrix [ i ] , 0 , newMatrix [ i ] , 0 , m_ConfusionMatrix [ i ] . length ) ; } return newMatrix ; } \n', 0.3625981696735191)

('public int getConfusionMatrixValue ( String actualLabel , String predictedLabel ) { return confusionMatrix . get ( actualLabel ) . get ( predictedLabel ) ; } \n', 0.3576767205715519)

('public double [ ] [ ] confusionMatrix ( ) { return m_delegate . confusionMatrix ( ) ; } \n', 0.34859315729873985)

('public Matrix confusionMatrix ( ) { if ( cachedConfusionMatrix != null ) return cachedConfusionMatrix ; String [ ] classes = getClasses ( ) ; double [ ] [ ] confused = new double [ classes . length ] [ classes . length ] ; for ( int i = 0 ; i < entryList . size ( ) ; i ++ ) { Entry e = getEntry ( i ) ; confused [ classIndexOf ( e . actual ) ] [ classIndexOf ( e . predicted ) ] ++ ; } cachedConfusionMatrix = new Matrix ( confused ) ; return cachedConfusionMatrix ; } \n', 0.33268638713126464)

('public double [ ] [ ] confusionMatrix ( ) { return Utils . clone ( m_ConfusionMatrix ) ; } \n', 0.3306698443106207)

('public static final Map < String , Map < String , Double >> calculateConfusionMatrix ( List < String > observationClasses , Map < String , double [ ] > predictions , Set < Integer > observationsToUse ) { Map < String , Map < String , Double >> confusionMatrix = new HashMap < String , Map < String , Double >> ( ) ; for ( String s : predictions . keySet ( ) ) { Map < String , Double > classPredictions = new HashMap < String , Double > ( ) ; classPredictions . put ( "Correct" , 0.0 ) ; classPredictions . put ( "Incorrect" , 0.0 ) ; confusionMatrix . put ( s , classPredictions ) ; } for ( int i : observationsToUse ) { String obsClass = observationClasses . get ( i ) ; String predictedClass = "" ; double maxPredictedWeightForObs = 0.0 ; for ( Map . Entry < String , double [ ] > entry : predictions . entrySet ( ) ) { String classOfPrediction = entry . getKey ( ) ; double predictedClassWeight = entry . getValue ( ) [ i ] ; if ( predictedClassWeight > maxPredictedWeightForObs ) { predictedClass = classOfPrediction ; maxPredictedWeightForObs = predictedClassWeight ; } } if ( obsClass . equals ( predictedClass ) ) { Double oldCount = confusionMatrix . get ( obsClass ) . get ( "Correct" ) ; confusionMatrix . get ( obsClass ) . put ( "Correct" , oldCount + 1.0 ) ; } else { Double oldCount = confusionMatrix . get ( predictedClass ) . get ( "Incorrect" ) ; confusionMatrix . get ( predictedClass ) . put ( "Incorrect" , oldCount + 1.0 ) ; } } return confusionMatrix ; } \n', 0.3197261338431233)

('public Map < Type , Map < Type , Integer >> getConfusionMatrix ( Classifier classifier , Set < Individual > individuals ) { Map < Type , Map < Type , Integer >> matrix = new HashMap < Type , Map < Type , Integer >> ( ) ; for ( Type realType : Type . values ( ) ) { matrix . put ( realType , new HashMap < Type , Integer > ( ) ) ; matrix . get ( realType ) . put ( null , 0 ) ; for ( Type inferredType : Type . values ( ) ) { matrix . get ( realType ) . put ( inferredType , 0 ) ; } } for ( Individual individual : individuals ) { Type inferredType = classifier . classify ( individual ) ; Map < Type , Integer > row = matrix . get ( individual . type ) ; row . put ( inferredType , row . get ( inferredType ) + 1 ) ; } return matrix ; } \n', 0.31603133792104965)

('public static ConfusionMatrix createCumulativeMatrix ( ConfusionMatrix ... matrices ) { ConfusionMatrix result = new ConfusionMatrix ( ) ; for ( ConfusionMatrix matrix : matrices ) { for ( Map . Entry < String , Map < String , Integer > > gold : matrix . map . entrySet ( ) ) { for ( Map . Entry < String , Integer > actual : gold . getValue ( ) . entrySet ( ) ) { result . increaseValue ( gold . getKey ( ) , actual . getKey ( ) , actual . getValue ( ) ) ; } } } return result ; }\n', 0.30397298437631215)

('public void getModel ( ) throws Exception { Evaluation eTest = new Evaluation ( trainingData ) ; eTest . evaluateModel ( classifier , trainingData ) ; String strSummary = eTest . toSummaryString ( ) ; System . out . println ( strSummary ) ; double [ ] [ ] cmMatrix = eTest . confusionMatrix ( ) ; for ( int row_i = 0 ; row_i < cmMatrix . length ; row_i ++ ) { for ( int col_i = 0 ; col_i < cmMatrix . length ; col_i ++ ) { System . out . print ( cmMatrix [ row_i ] [ col_i ] ) ; System . out . print ( "|" ) ; } System . out . println ( ) ; } } \n', 0.28179905202580635)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 62 #################################
('public static String htmlEscapeAllowEntities ( String text ) { StringBuilder escaped = new StringBuilder ( ) ; boolean firstSegment = true ; for ( String segment : text . split ( "&" , - 1 ) ) { if ( firstSegment ) { firstSegment = false ; escaped . append ( htmlEscape ( segment ) ) ; continue ; } int entityEnd = segment . indexOf ( \';\' ) ; if ( entityEnd > 0 && segment . substring ( 0 , entityEnd ) . matches ( HTML_ENTITY_REGEX ) ) { escaped . append ( "&" ) . append ( segment . substring ( 0 , entityEnd + 1 ) ) ; escaped . append ( htmlEscape ( segment . substring ( entityEnd + 1 ) ) ) ; } else { escaped . append ( "&amp;" ) . append ( htmlEscape ( segment ) ) ; } } return escaped . toString ( ) ; } \n', 0.42727888843847994)

('public static String htmlEscapeAllowEntities ( String text ) { StringBuilder escaped = new StringBuilder ( ) ; boolean firstSegment = true ; for ( String segment : text . split ( "&" , - 1 ) ) { if ( firstSegment ) { firstSegment = false ; escaped . append ( htmlEscape ( segment ) ) ; continue ; } int entityEnd = segment . indexOf ( \';\' ) ; if ( entityEnd > 0 && segment . substring ( 0 , entityEnd ) . matches ( HTML_ENTITY_REGEX ) ) { escaped . append ( "&" ) . append ( segment . substring ( 0 , entityEnd + 1 ) ) ; escaped . append ( htmlEscape ( segment . substring ( entityEnd + 1 ) ) ) ; } else { escaped . append ( "&amp;" ) . append ( htmlEscape ( segment ) ) ; } } return escaped . toString ( ) ; } \n', 0.40953367441935956)

('protected String escapeHtmlEntities ( CharSequence orig ) { StringBuffer buff = new StringBuffer ( orig ) ; EntityTable defaultEntityTable = EntityTable . getDefaultEntityTable ( ) ; Matcher matcher = Pattern . compile ( "|&|w+|;" ) . matcher ( orig ) ; int delta = 0 ; while ( matcher . find ( ) ) { String name = matcher . group ( ) . substring ( 0 , matcher . group ( ) . length ( ) - 1 ) ; int code = defaultEntityTable . entityCode ( name ) ; if ( 0 != code ) { String replacement = "&#" + code + ";" ; buff . replace ( matcher . start ( ) - delta , matcher . end ( ) - delta , replacement ) ; delta = delta + matcher . group ( ) . length ( ) - replacement . length ( ) ; } } return buff . toString ( ) ; } \n', 0.40569205517143747)

('public static String escapeHtmlEntities ( final String toBeEscaped ) { return toBeEscaped . replaceAll ( "<" , "&lt;" ) . replaceAll ( ">" , "&gt;" ) ; } \n', 0.4032694824187883)

('public String normalizeStringFromHTML ( String str ) { for ( SpecialHTMLCharacter specChar : characterTable ) { str = str . replaceAll ( specChar . htmlCode , specChar . character ) ; str = str . replaceAll ( specChar . htmlEntity , specChar . character ) ; } return str ; } \n', 0.40295822576447665)

('public static String replaceHTMLEntities ( String s ) { if ( s == null ) { return null ; } else { if ( s != null ) { for ( int i = 0 ; i < HTML_ENTITIES . length ; i ++ ) { s = s . replace ( HTML_ENTITIES [ i ] [ 1 ] , HTML_ENTITIES [ i ] [ 0 ] ) ; } } return s ; } } \n', 0.40287934249499124)

('private static String fixHtmlEntities ( String input ) { return input . replace ( "&amp;" , "&" ) . replace ( "&lt;" , "<" ) . replace ( "&gt;" , ">" ) ; } \n', 0.4009545145291146)

('public static String unescapeHTML ( String str ) { StringBuilder rtn = new StringBuilder ( ) ; int posStart = - 1 ; int posFinish = - 1 ; while ( ( posStart = str . indexOf ( \'&\' , posStart ) ) != - 1 ) { int last = posFinish + 1 ; posFinish = str . indexOf ( \';\' , posStart ) ; if ( posFinish == - 1 ) break ; rtn . append ( str . substring ( last , posStart ) ) ; if ( posStart + 1 < posFinish ) { rtn . append ( unescapeHTMLEntity ( str . substring ( posStart + 1 , posFinish ) ) ) ; } else { rtn . append ( "&;" ) ; } posStart = posFinish + 1 ; } rtn . append ( str . substring ( posFinish + 1 ) ) ; return rtn . toString ( ) ; } \n', 0.4004434456967965)

("private String unHtmlEntities ( String string ) { StringBuilder buf = new StringBuilder ( ) ; for ( int i = 0 ; i < string . length ( ) ; ++ i ) { char ch = string . charAt ( i ) ; if ( ch == '&' ) { int semi = string . indexOf ( ';' , i + 1 ) ; if ( ( semi == - 1 ) || ( ( semi - i ) > 7 ) ) { buf . append ( ch ) ; continue ; } String entity = string . substring ( i , semi + 1 ) ; Integer iso ; if ( entity . charAt ( 1 ) == '-' ) { buf . append ( ch ) ; continue ; } if ( entity . charAt ( 1 ) == '#' ) { if ( entity . charAt ( 2 ) == 'x' ) { iso = Integer . parseInt ( entity . substring ( 3 , entity . length ( ) - 1 ) , 16 ) ; } else { iso = Integer . valueOf ( entity . substring ( 2 , entity . length ( ) - 1 ) ) ; } } else { iso = HTML_ENTITIES . get ( entity ) ; } if ( iso == null ) { buf . append ( entity ) ; } else { buf . append ( ( char ) ( iso . intValue ( ) ) ) ; } i = semi ; } else { buf . append ( ch ) ; } } return buf . toString ( ) ; } \n", 0.40014803861175785)

("public static String replaceHtmlEntities ( final String s ) { final StringBuilder t = new StringBuilder ( ) ; for ( int i = 0 , n = s . length ( ) ; i < n ; i ++ ) { final char c = s . charAt ( i ) ; if ( c == '&' ) { final int j = s . indexOf ( ';' , i ) ; if ( j >= 0 ) { final Character unicode = HTML_ENTITY_TO_UNICODE_MAP . get ( s . substring ( i + 1 , j ) ) ; if ( unicode != null ) { t . append ( ( char ) unicode ) ; i = j ; continue ; } } } t . append ( c ) ; } return t . toString ( ) ; } \n", 0.39985434532512487)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 63 #################################
('public static String convertJSONToXML ( String rawJSON , String rootName , String encoding ) { XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( rawJSON ) ; serializer . setRootName ( rootName ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json , encoding ) ; return xml ; } \n', 0.4520262156989096)

('public static String convertAmeticJSONToXML ( String rawJSON , String encoding ) { String jsonData = fixDateFormats ( rawJSON ) ; XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( jsonData ) ; serializer . setRootName ( "AmeticEvent" ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json , encoding ) ; return xml ; } \n', 0.44469413235706723)

('public static String jsonToXml ( String xmlString , String rootElement ) throws Exception { try { JSONObject jso = new JSONObject ( xmlString ) ; rootElement = Val . chkStr ( rootElement ) ; if ( "" . equals ( rootElement ) ) { rootElement = "gptJsonXml" ; } String xml = XML . toString ( jso , "gptJsonXml" ) ; StreamSource source = new StreamSource ( new StringReader ( xml ) ) ; StringWriter writer = new StringWriter ( ) ; StreamResult result = new StreamResult ( writer ) ; Transformer transformer = TransformerFactory . newInstance ( ) . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . ENCODING , "UTF-8" ) ; transformer . setOutputProperty ( OutputKeys . INDENT , "yes" ) ; transformer . transform ( source , result ) ; return Val . chkStr ( writer . toString ( ) ) ; } catch ( Exception e ) { throw e ; } } \n', 0.44160544192714646)

('public static JSONObject xmlToJSON ( String xml ) { return ( ( JSONObject ) new XMLSerializer ( ) . read ( xml ) ) ; } \n', 0.4410089235442416)

('private JSON xmlToJson ( String xml ) throws JSONException { XMLSerializer xmlSerializer = new XMLSerializer ( ) ; xmlSerializer . setRemoveNamespacePrefixFromElements ( true ) ; xmlSerializer . setSkipNamespaces ( true ) ; return xmlSerializer . read ( xml ) ; } \n', 0.4357251399372226)

('@ Deprecated public String ConvertToXML ( String jsonData ) { XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( jsonData ) ; serializer . setRootName ( "xmlOutput" ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json ) ; return xml ; } \n', 0.43323196962330557)

('@ Deprecated private String ConvertToXML ( String jsonData ) { XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( jsonData ) ; serializer . setRootName ( "xmlOutput" ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json ) ; return xml ; } \n', 0.43323196962330557)

('public static JsonObject xmlToJson ( @ NotNull String xml ) throws TransformerException { StringWriter out = new StringWriter ( xml . length ( ) ) ; Transformer transformer = TRANSFORMER_FACTORY . newTransformer ( new StreamSource ( new StringReader ( XSLT ) ) ) ; transformer . transform ( new StreamSource ( new StringReader ( xml ) ) , new StreamResult ( out ) ) ; return new JsonObject ( out . toString ( ) ) ; } \n', 0.4210437901093837)

('public String toXML ( Object obj ) { JSON json = _toJson ( obj ) ; XMLSerializer xmlSerializer = new XMLSerializer ( ) ; return xmlSerializer . write ( json ) ; } \n', 0.41990094262009964)

('public static String serializeToXML ( Object object ) { JSONObject obj = serializeToJSON ( object ) ; StringWriter sw = new StringWriter ( ) ; XMLStreamWriter xw = null ; try { xw = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( sw ) ; xw . writeStartDocument ( Consts . UTF_8 . name ( ) , "1.0" ) ; xw . writeStartElement ( "xml" ) ; for ( String key : obj . keySet ( ) ) { if ( StringUtil . isBlank ( obj . getString ( key ) ) ) { continue ; } xw . writeStartElement ( key ) ; xw . writeCData ( obj . getString ( key ) ) ; xw . writeEndElement ( ) ; } xw . writeEndElement ( ) ; xw . writeEndDocument ( ) ; } catch ( XMLStreamException e ) { e . printStackTrace ( ) ; } finally { if ( xw != null ) { try { xw . close ( ) ; } catch ( XMLStreamException e ) { ; } } try { sw . close ( ) ; } catch ( IOException e ) { ; } } return sw . getBuffer ( ) . toString ( ) ; } \n', 0.4074263373038371)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 64 #################################
('public static String urlEncode ( String value ) { if ( value == null ) { return "" ; } try { return URLEncoder . encode ( value , CharEncoding . UTF_8 ) ; } catch ( UnsupportedEncodingException ex ) { throw new RuntimeException ( ex ) ; } } \n', 0.44189882521155727)

('public static String urlEncode ( String s , String format ) { String encodedString = s ; if ( s != null ) { try { encodedString = URLEncoder . encode ( s , format ) ; } catch ( UnsupportedEncodingException e ) { encodedString = s ; } } return encodedString ; } \n', 0.4418923042367976)

('protected String urlEncode ( String url ) { try { url = URLEncoder . encode ( url , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { LOGGER . error ( "url-encode-error:{}" , e ) ; } return url ; } \n', 0.4406274573118434)

('private static String urlEncode ( String param ) { if ( param == null ) return "" ; try { return URLEncoder . encode ( param , "UTF-8" ) ; } catch ( UnsupportedEncodingException exception ) { LOG . debug ( "unable-to-encode-param:-{}" , param , exception ) ; return null ; } } \n', 0.4393120923890211)

('public static String urlEncode ( String token ) { if ( token == null ) { throw new IllegalArgumentException ( THE_TOKEN_CANNOT_BE_NULL_MSG ) ; } String encodedToken = token ; try { encodedToken = URLEncoder . encode ( token , UTF_8 ) ; } catch ( UnsupportedEncodingException uee ) { logger . warn ( INVALID_TOKEN_WARNING ) ; } return encodedToken ; } \n', 0.43916610815151336)

('private String urlEncode ( String value ) { try { return URLEncoder . encode ( value , URL . ENCODING ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalArgumentException ( URL . ENCODING + URL . ENCODING_ERROR , e ) ; } } \n', 0.4374697071133812)

('public static String urlEncode ( String value ) { try { return URLEncoder . encode ( value , defaultEncoding ) ; } catch ( UnsupportedEncodingException e ) { throw ExUtil . wrapRuntimeException ( e ) ; } } \n', 0.43740435121145615)

('public static String urlEncode ( String s ) { if ( s == null ) { return "" ; } String encoded = null ; try { encoded = URLEncoder . encode ( s , Constants . UTF8_NAME ) ; } catch ( UnsupportedEncodingException e ) { } return encoded ; } \n', 0.4371310840686521)

('public static String URLEncode ( String unencodedString ) throws UIException { if ( unencodedString == null ) return "" ; try { return URLEncoder . encode ( unencodedString , Constants . DEFAULT_ENCODING ) ; } catch ( UnsupportedEncodingException uee ) { throw new UIException ( uee ) ; } } \n', 0.43688531014695586)

('public String urlEncodeUrl ( @ Nullable String content ) { if ( content == null ) { return null ; } try { return URLEncoder . encode ( content , charset . name ( ) ) ; } catch ( UnsupportedEncodingException ex ) { throw new IllegalStateException ( "Charset-became-invalid-out-of-a-sudden." ) ; } } \n', 0.43668538758088704)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 65 #################################
('public static final Point getShowcasePointFromView ( View view , ShowcaseView . ConfigOptions options ) { Point result = new Point ( ) ; if ( options . insert == ShowcaseView . INSERT_TO_VIEW ) { result . x = view . getLeft ( ) + view . getWidth ( ) / 2 ; result . y = view . getTop ( ) + view . getHeight ( ) / 2 ; } else { int [ ] coordinates = new int [ 2 ] ; view . getLocationInWindow ( coordinates ) ; result . x = coordinates [ 0 ] + view . getWidth ( ) / 2 ; result . y = coordinates [ 1 ] + view . getHeight ( ) / 2 ; } return result ; } \n', 0.33490662284549555)

('public static Point2D fromYXtoWorldFieldCoordinates ( int y , int x ) { return new Point2D ( x , y + 1 ) ; } \n', 0.33476985860052266)

('static Location deriveLocationFromExons ( List exons ) { final int nExons = exons . size ( ) ; Location loc = ( ( Exon ) exons . get ( 0 ) ) . getLocation ( ) ; if ( nExons == 1 ) return loc ; int start = Integer . MAX_VALUE ; int end = 0 ; for ( int i = 0 ; i < nExons ; ++ i ) { Exon exon = ( Exon ) exons . get ( i ) ; for ( Location l = exon . getLocation ( ) ; l != null ; l = l . next ( ) ) { int s = l . getStart ( ) ; int e = l . getEnd ( ) ; if ( s < start ) start = s ; if ( e > end ) end = e ; } } loc = new Location ( loc . getCoordinateSystem ( ) , loc . getSeqRegionName ( ) , start , end , loc . getStrand ( ) ) ; return loc ; } \n', 0.3334772222717274)

('static private Point offsetFromRelativeCoordinate ( IFigure label , Rectangle bounds , PointList points , Point ref ) { Rectangle rect = new Rectangle ( bounds ) ; rect . translate ( rect . width / 2 , rect . height / 2 ) ; Point normalPoint = normalizeRelativePointToPointOnLine ( points , ref , new Point ( rect . x - ref . x , rect . y - ref . y ) ) ; return normalPoint ; } \n', 0.33092488327028413)

('static public Point offsetFromRelativeCoordinate ( IFigure label , Rectangle bounds , PointList points , Point ref ) { Rectangle rect = new Rectangle ( bounds ) ; rect . translate ( rect . width / 2 , rect . height / 2 ) ; Point normalPoint = normalizeRelativePointToPointOnLine ( points , ref , new Point ( rect . x - ref . x , rect . y - ref . y ) ) ; return normalPoint ; } \n', 0.33092488327028413)

('private Coordinate displaceFromCornerAwayFromArms ( Coordinate nearPt , Coordinate p1 , Coordinate p2 , double dist ) { Coordinate [ ] corner = orientCorner ( nearPt , p1 , p2 ) ; boolean isInsideCorner = isInsideCorner ( vertexPt , nearPt , corner [ 0 ] , corner [ 1 ] ) ; Vector2D u1 = Vector2D . create ( nearPt , corner [ 0 ] ) . normalize ( ) ; Vector2D u2 = Vector2D . create ( nearPt , corner [ 1 ] ) . normalize ( ) ; double cornerAng = u1 . angle ( u2 ) ; double maxAngToBisec = maxAngleToBisector ( cornerAng ) ; Vector2D bisec = u2 . rotate ( cornerAng / 2 ) ; if ( ! isInsideCorner ) { bisec = bisec . multiply ( - 1 ) ; double outerAng = 2 * Math . PI - cornerAng ; maxAngToBisec = maxAngleToBisector ( outerAng ) ; } Vector2D pointwiseDisplacement = Vector2D . create ( nearPt , vertexPt ) . normalize ( ) ; double stretchAng = pointwiseDisplacement . angleTo ( bisec ) ; double stretchAngClamp = MathUtil . clamp ( stretchAng , - maxAngToBisec , maxAngToBisec ) ; Vector2D cornerDisplacement = bisec . rotate ( - stretchAngClamp ) . multiply ( dist ) ; return cornerDisplacement . translate ( vertexPt ) ; } \n', 0.3219687602258792)

('public int [ ] calculateOffsetCoordinates ( int ... coordinates ) { return calculateOffsetCoordinates ( coordinateOffset , coordinates ) ; } \n', 0.32111453836459225)

('public Point addToCoordinates ( final double longitude , final double latitude ) { this . getCoordinates ( ) . add ( new Coordinate ( longitude , latitude ) ) ; return this ; } \n', 0.3200740154715396)

('public static RegionCoordinates fromPosition ( Position position ) { return new RegionCoordinates ( position . getTopLeftRegionX ( ) , position . getTopLeftRegionY ( ) ) ; } \n', 0.3195258080813394)

('Double fromCurve ( Curve curve , boolean close ) { Double line = new Double ( ) ; ICRS crs = curve . getCoordinateSystem ( ) ; curve = linearizer . linearize ( curve , new NumPointsCriterion ( 100 ) ) ; curve . setCoordinateSystem ( crs ) ; Points points = curve . getControlPoints ( ) ; Iterator < Point > iter = points . iterator ( ) ; Point p = iter . next ( ) ; double x = p . get0 ( ) , y = p . get1 ( ) ; line . moveTo ( x , y ) ; while ( iter . hasNext ( ) ) { p = iter . next ( ) ; if ( iter . hasNext ( ) ) { line . lineTo ( p . get0 ( ) , p . get1 ( ) ) ; } else { if ( close && isZero ( x - p . get0 ( ) ) && isZero ( y - p . get1 ( ) ) ) { line . closePath ( ) ; } else { line . lineTo ( p . get0 ( ) , p . get1 ( ) ) ; } } } line . transform ( worldToScreen ) ; return line ; } \n', 0.3168728254038889)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 66 #################################
('public void sortLargeFile ( final String from , final long memoryLimit , final boolean makeCopy ) throws IOException { LOG . info ( "Sort-Large-File-start,-fromFile-{},-memoryLimit-{},-make-a-copy-{}" , new Object [ ] { from , memoryLimit , makeCopy } ) ; long start = System . currentTimeMillis ( ) ; if ( from == null || from . trim ( ) . length ( ) == 0 || memoryLimit <= 0 ) { LOG . error ( "Sort-Large-File-stop,-input-parameter-can-not-be-null-or-empty." ) ; return ; } File file = new File ( from ) ; if ( file . exists ( ) && file . isFile ( ) ) { splitFile ( file , memoryLimit ) ; sortSplitFile ( file . getParent ( ) ) ; mergeFiles ( from , makeCopy ) ; LOG . info ( "Sort-Large-File-end,-whole-time-is-{}ms." , System . currentTimeMillis ( ) - start ) ; } else { LOG . error ( "Sort-stop,-file-not-exist-or-not-a-normal-file,-please-check-your-input-parameter." ) ; } } \n', 0.2906262053216252)

('private boolean saveLargeFileDataToTempFileInInternalStorage ( List < MemorySlot > pData , String pFileName ) { try { int lTotalSaved = 0 ; FileOutputStream lFile = mContext . openFileOutput ( getTempFileName ( pFileName ) , Context . MODE_APPEND ) ; for ( int i = 0 ; i < pData . size ( ) ; i ++ ) { lFile . write ( pData . get ( i ) . getData ( ) , 0 , pData . get ( i ) . getUsedAmount ( ) ) ; lTotalSaved += pData . get ( i ) . getUsedAmount ( ) ; } Log . v ( TAG , "Saved-" + lTotalSaved + "-new-bytes-to-temporary-file-" + getTempFileName ( pFileName ) ) ; lFile . close ( ) ; return true ; } catch ( Exception e ) { Log . e ( TAG , "Error-saving-temp-file-for-" + pFileName , e ) ; return false ; } } \n', 0.28617370547747767)

('@ NotNull public Collection < PsiFile > getLargeFiles ( ) { return myLargeFiles == null ? Collections . < PsiFile > emptyList ( ) : myLargeFiles ; } \n', 0.27841383304089334)

('protected void validateNoFilesOnLargeDir ( final int expect ) throws Exception { File largeMessagesFileDir = new File ( getLargeMessagesDir ( ) ) ; for ( int i = 0 ; i < 100 ; i ++ ) { if ( largeMessagesFileDir . listFiles ( ) . length != expect ) { Thread . sleep ( 10 ) ; } else { break ; } } Assert . assertEquals ( expect , largeMessagesFileDir . listFiles ( ) . length ) ; } \n', 0.27657988296276864)

('@ NotNull public Collection < VirtualFile > getLargeFiles ( ) { return myLargeFiles == null ? Collections . < VirtualFile > emptyList ( ) : myLargeFiles ; } \n', 0.27322354590049147)

('public static File [ ] unzipTempJars ( File srcZip ) throws IOException { if ( zipToTempJars . containsKey ( srcZip ) ) { return zipToTempJars . get ( srcZip ) ; } IZipEntryFilter filter = new IZipEntryFilter ( ) { public boolean accept ( ZipEntry entry ) { return entry . getName ( ) . toLowerCase ( ) . endsWith ( JAR_FILE_EXT ) ; } } ; ZipFile archive = new ZipFile ( srcZip ) ; Enumeration < ? extends ZipEntry > e = archive . entries ( ) ; List < File > extractedFiles = new ArrayList < File > ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry entry = e . nextElement ( ) ; if ( filter . accept ( entry ) ) { if ( ! entry . isDirectory ( ) ) { String prefix = entry . getName ( ) . substring ( entry . getName ( ) . lastIndexOf ( "/" ) + 1 , entry . getName ( ) . toLowerCase ( ) . lastIndexOf ( JAR_FILE_EXT ) ) ; File file = File . createTempFile ( StringUtils . rightPad ( prefix , 3 ) , JAR_FILE_EXT ) ; extractedFiles . add ( file ) ; file . deleteOnExit ( ) ; unzipFile ( archive , file , entry ) ; } } } File [ ] files = extractedFiles . toArray ( new File [ extractedFiles . size ( ) ] ) ; zipToTempJars . put ( srcZip , files ) ; return files ; } \n', 0.2640004644848604)

('public static void unzipFile ( File zip , File output , ExtractRules extractRules , DownloadListener listener ) throws IOException { if ( ! zip . exists ( ) ) { Utils . getLogger ( ) . log ( Level . SEVERE , "File-to-unzip-does-not-exist:-" + zip . getAbsolutePath ( ) ) ; return ; } if ( ! output . exists ( ) ) { output . mkdirs ( ) ; } ZipFile zipFile = new ZipFile ( zip ) ; int size = zipFile . size ( ) + 1 ; int progress = 1 ; try { Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = null ; try { entry = entries . nextElement ( ) ; } catch ( IllegalArgumentException ex ) { throw new ZipException ( "IllegalArgumentException-while-parsing-next-element." ) ; } if ( ( extractRules == null || extractRules . shouldExtract ( entry . getName ( ) ) ) && ! entry . getName ( ) . contains ( "../" ) ) { File outputFile = new File ( output , entry . getName ( ) ) ; if ( outputFile . getParentFile ( ) != null ) { outputFile . getParentFile ( ) . mkdirs ( ) ; } if ( ! entry . isDirectory ( ) ) { unzipEntry ( zipFile , entry , outputFile ) ; } } if ( listener != null ) { float totalProgress = ( float ) progress / ( float ) size ; listener . stateChanged ( "Extracting-" + entry . getName ( ) + "..." , totalProgress * 100.0f ) ; } progress ++ ; } } finally { zipFile . close ( ) ; } } \n', 0.26339272087865584)

('public static synchronized void unzipArchiveIfModified ( final File zipArchive , final File unzipRootFolder ) throws IOException { unzipArchive ( zipArchive . toURI ( ) . toURL ( ) , unzipRootFolder ) ; } \n', 0.26308661014112567)

('protected List < String > getFilesToUnzip ( boolean all ) { if ( ! all ) { List < String > result = new ArrayList < String > ( ) ; for ( String fileName : m_filesToUnzip ) { if ( m_filesToUpload . keySet ( ) . contains ( fileName ) ) { result . add ( fileName ) ; } } return result ; } return m_filesToUnzip ; } \n', 0.2629158610070659)

('private void unzipFile ( ZipEntry entry , String zipfilename ) throws IOException { String name = entry . getName ( ) ; String foldername = zipfilename . substring ( 0 , zipfilename . length ( ) - 4 ) ; String fullfilename = path + File . separator + foldername + File . separator + name ; File file = new File ( fullfilename ) ; if ( file . exists ( ) ) { return ; } this . writefile ( entry , file ) ; } \n', 0.2620288861463521)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 67 #################################
('public static long convertAlldayUtcToLocal ( Time recycle , long utcTime , String tz ) { if ( recycle == null ) { recycle = new Time ( ) ; } recycle . timezone = Time . TIMEZONE_UTC ; recycle . set ( utcTime ) ; recycle . timezone = tz ; return recycle . normalize ( true ) ; } \n', 0.4081797321872943)

('private static long convertAlldayUtcToLocal ( Time recycle , long utcTime , String tz ) { if ( recycle == null ) { recycle = new Time ( ) ; } recycle . timezone = Time . TIMEZONE_UTC ; recycle . set ( utcTime ) ; recycle . timezone = tz ; return recycle . normalize ( true ) ; } \n', 0.4081797321872943)

('public static long convertAlldayLocalToUTC ( Time recycle , long localTime , String tz ) { if ( recycle == null ) { recycle = new Time ( ) ; } recycle . timezone = tz ; recycle . set ( localTime ) ; recycle . timezone = Time . TIMEZONE_UTC ; return recycle . normalize ( true ) ; } \n', 0.4012596620758244)

('public static Date convertTimeFromSystemTimezoneToUTC ( long timeInMillis ) { DateTime dt = new DateTime ( ) ; dt = dt . withMillis ( - DateTimeZone . getDefault ( ) . getOffset ( timeInMillis ) + timeInMillis ) ; dt = dt . withZone ( utcZone ) ; return dt . toDate ( ) ; } \n', 0.3915847915675757)

('public static DateTime convertSFTimeToDateTime ( XMLGregorianCalendar soapTime ) { return new DateTime ( soapTime . getYear ( ) , soapTime . getMonth ( ) , soapTime . getDay ( ) , soapTime . getHour ( ) , soapTime . getMinute ( ) , soapTime . getSecond ( ) , soapTime . getMillisecond ( ) , DateTimeZone . UTC ) ; } \n', 0.38831936157506997)

('public long convertUTCto ( TimeZone timeZoneToConvertTo , long timeToConvert ) { int millisecondsFromUTC = timeZoneToConvertTo . getRawOffset ( ) ; return timeToConvert + millisecondsFromUTC ; } \n', 0.3838242434455176)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 68 #################################
('public Set < ObservedPulseValues > getObservedPulseValues ( ) { if ( observedPulseValues == null ) { observedPulseValues = new HashSet < > ( ) ; } return this . observedPulseValues ; } \n', 0.25031941942390795)

('@ NonNull public Observable < Float > getAzimuthObservable ( ) { AzimuthObserver observer = azimuthProvider . get ( ) ; observer . setSensorDelay ( SensorManager . SENSOR_DELAY_UI ) ; return Observable . create ( observer ) ; } \n', 0.24294673901761174)

('public Set < ObservedLobeValues > getObservedLobeValues ( ) { if ( observedLobeValues == null ) { observedLobeValues = new HashSet < > ( ) ; } return this . observedLobeValues ; } \n', 0.23222126229289736)

('public Set < ObservedERPValues > getObservedERPValues ( ) { if ( observedERPValues == null ) { observedERPValues = new HashSet < > ( ) ; } return this . observedERPValues ; } \n', 0.23222126229289736)

('public Set < ObservedPolarisationValues > getObservedPolarisationValues ( ) { if ( observedPolarisationValues == null ) { observedPolarisationValues = new HashSet < > ( ) ; } return this . observedPolarisationValues ; } \n', 0.23222126229289736)

('protected Observable < RespBean > getObservableUsersPagedNet ( final int page ) { return apiService . getObservableUsersPaged ( page ) . doOnNext ( new Action1 < RespBean > ( ) { @ Override public void call ( RespBean respBean ) { respBean . timestamp = System . currentTimeMillis ( ) ; respBean . cached = false ; cachedMap . put ( page , respBean ) ; } } ) ; } \n', 0.22992361595392646)

('public Set < ObservedScanValues > getObservedScanValues ( ) { if ( observedScanValues == null ) { observedScanValues = new HashSet < > ( ) ; } return this . observedScanValues ; } \n', 0.22951919679807453)

('public List < ObservedValue > getObservedValuesByTargetAndFeature ( Database db , int targetId , Measurement measurement , List < Integer > investigationIds , int investigationToBeAddedToId ) throws DatabaseException , ParseException { List < Measurement > measurementList = new ArrayList < Measurement > ( ) ; measurementList . add ( measurement ) ; return getObservedValuesByTargetAndFeatures ( db , targetId , measurementList , investigationIds , investigationToBeAddedToId ) ; } \n', 0.219574879265494)

('private static void flatMapWindowedExampleAsync ( ) { Observable . range ( 0 , 5000 ) . window ( 500 ) . flatMap ( work -> { return work . observeOn ( Schedulers . computation ( ) ) . map ( item -> { try { Thread . sleep ( 1 ) ; } catch ( Exception e ) { } return item + "-processed-" + Thread . currentThread ( ) ; } ) ; } ) . toBlocking ( ) . forEach ( System . out :: println ) ; } \n', 0.21721636548538462)

('public ObservableDoubleValue getLatestObservationObservable ( T type ) { return data . get ( type ) . getObservableLastObservation ( ) ; } \n', 0.21000044845798024)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 69 #################################
('public void printTestAPIComponentsSummary ( ClassDoc [ ] testAPIComponents ) { mOut . println ( "<P>" ) ; mOut . println ( "<TABLE-BORDER="1"-WIDTH="100%"-CELLPADDING="3"-CELLSPACING="0"-SUMMARY="">" ) ; mOut . println ( "<TR-BGCOLOR="#CCCCFF"><TH-ALIGN="left"-COLSPAN="2"><FONT-SIZE="+2"><B>Components-Summary</B></FONT></TH></TR>" ) ; for ( int c = 0 ; c < testAPIComponents . length ; c ++ ) { ClassDoc classDoc = testAPIComponents [ c ] ; String componentName = classDoc . name ( ) ; mOut . print ( "<TR><TD-WIDTH="1%"><CODE><B><A-HREF="components/" + componentName + ".html">" + componentName + "</A></B></CODE></TD><TD>" ) ; printInlineTags ( classDoc . firstSentenceTags ( ) , classDoc ) ; mOut . println ( "</TD>" ) ; } mOut . println ( "</TABLE>" ) ; } \n', 0.3891342518266092)

('private void printModelElements ( Configuration config , String comment ) { LOGGER . debug ( "-------------------" ) ; LOGGER . debug ( comment ) ; for ( IDecisionVariable variable : config ) { printModelElement ( variable ) ; } } \n', 0.3833187258629118)

('private void printDataSummary ( ) { StringBuilder str = new StringBuilder ( "Generated-HBase-data-summary-" ) ; str . append ( "Generated-" + SplitRowKeyGenerator . NUM_EXCHANGE + "-Exchanges-..-" ) ; str . append ( "Generated-" + SplitRowKeyGenerator . NUM_EXCHANGE * SplitRowKeyGenerator . NUM_TOPICS + "-Topics-..-" ) ; str . append ( "Generated-" + SplitRowKeyGenerator . NUM_EXCHANGE * SplitRowKeyGenerator . NUM_TOPICS * SplitRowKeyGenerator . NUM_KEYS_PER_ET + "-Keys-..-" ) ; str . append ( "Data-File-sgdata/" + HISTORY_FILE_NAME + "-" ) ; String summary = str . toString ( ) ; System . out . println ( summary ) ; MyLogger . mylogger . info ( summary ) ; } \n', 0.37794962665018705)

('void printUserSummary ( PrintStream out ) throws AdeUsageException , AdeInternalException { if ( ! Double . isNaN ( m_meanInfo ) ) { out . printf ( "Mean-information-in-similary-matrix:-%f%n" , m_model . m_meanInfo ) ; } out . printf ( "Runs:%n" ) ; if ( m_runsSummary == null ) { out . println ( "No-data" ) ; } else { for ( int i = 0 ; i < m_runsSummary . size ( ) ; ++ i ) { out . printf ( "-run-%d:-%s%n" , i , m_runsSummary . get ( i ) ) ; } } out . printf ( "Resulting-clusters:-%d%n" , m_clustersBeforeFiltering ) ; out . printf ( "Remaining-after-filtering-clusters:-%d%n" , m_actualClusters ) ; out . printf ( "Total-intervals-scanned:-%d%n" , m_totalIntervalCount ) ; out . printf ( "Total-msg-ids-found:-%d%n" , m_seenMsgIds . size ( ) ) ; out . printf ( "Total-msg-ids-above-min-appear-threshold-%d:-%d%n" , m_msgAppearThreshold , m_msgCountAboveThreshold ) ; out . printf ( "Total-msg-ids-clustered:-%d%n" , m_clusteredMsgCount ) ; out . printf ( "Converged:-%s%n" , String . valueOf ( m_converged ) ) ; } \n', 0.3697503013699579)

('public static String printModel ( Node root ) { final StringBuilder builder = new StringBuilder ( ) ; printModel ( builder , root ) ; return builder . toString ( ) ; } \n', 0.3692760377840447)

('private static void printOverallSummaryHeadings ( Writer overallsummary ) { try { overallsummary . write ( "==================-" ) ; overallsummary . write ( "Test-Summary-" ) ; overallsummary . write ( "==================-" ) ; overallsummary . write ( "Scenario-" + "Pass" + "-" + "Fail" + "-" + "Total-" ) ; overallsummary . flush ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } \n', 0.3621442182595307)

('public void printSummary ( PrintWriter out , int numWords ) throws IOException { Formatter buffer = new Formatter ( ) ; ArrayList < TreeSet < IDSorter >> topicSortedWords = model . getSortedWords ( ) ; buffer . format ( "[" ) ; for ( int topic = 0 ; topic < model . numTopics ; topic ++ ) { TreeSet < IDSorter > sortedWords = topicSortedWords . get ( topic ) ; int word = 0 ; Iterator < IDSorter > iterator = sortedWords . iterator ( ) ; buffer . format ( "{"topic":%d,-"smoothing":%f,-"words":{" , topic , model . alpha [ topic ] ) ; while ( iterator . hasNext ( ) && word < numWords ) { IDSorter info = iterator . next ( ) ; buffer . format ( ""%s":-%f" , model . alphabet . lookupObject ( info . getID ( ) ) , info . getWeight ( ) ) ; if ( iterator . hasNext ( ) && word < numWords - 1 ) { buffer . format ( "," ) ; } word ++ ; } buffer . format ( "}}" ) ; if ( topic < model . numTopics - 1 ) { buffer . format ( "," ) ; } } buffer . format ( "]" ) ; out . println ( buffer ) ; } \n', 0.36028248291606924)

('public static String printSummary ( ) { GregorianCalendar d = new GregorianCalendar ( ) ; String sDate = d . getTime ( ) . toString ( ) ; String sSummary = "" ; String s , u ; TaskTime T ; Iterator < TaskTime > i = lTaskTime . iterator ( ) ; while ( i . hasNext ( ) ) { T = i . next ( ) ; s = T . getTaskName ( ) ; u = T . convertToHourMinSec ( ) ; sSummary = sSummary + sDate + "-" + s + "-" + u + "-" ; } return sSummary ; } \n', 0.3602501024989133)

('protected void printSummary ( int sepcnt ) { System . out . println ( ) ; String seperator = "--------------------------------------" ; System . out . println ( seperator ) ; System . out . println ( "-Reads-Writes-Allocs-Pinned" ) ; int size = counts . size ( ) ; for ( int i = 1 ; i < size ; i += 2 ) { if ( i % ( sepcnt * 2 ) == 1 ) { System . out . println ( seperator ) ; } CountData before = counts . get ( i - 1 ) ; CountData after = counts . get ( i ) ; System . out . print ( after . desc ) ; System . out . print ( "-" + ( after . reads - before . reads ) ) ; System . out . print ( "-" + ( after . writes - before . writes ) ) ; System . out . print ( "-" + ( after . allocs - before . allocs ) ) ; System . out . print ( "-" + ( after . pinned - before . pinned ) ) ; System . out . println ( ) ; } System . out . println ( seperator ) ; } \n', 0.3600237873466348)

('private static String printSummary ( ) { StringBuffer mSummary = new StringBuffer ( ) ; mSummary . append ( ManifestTesterMessages . getString ( "ManifestTester.0" ) + "-" ) ; mSummary . append ( ManifestTesterMessages . getString ( "ManifestTester.24" , Integer . toString ( mNumTested ) ) + "-" ) ; mSummary . append ( ManifestTesterMessages . getString ( "ManifestTester.25" , Integer . toString ( mNumTested - mNumOfFailures ) ) + "-" ) ; mSummary . append ( ManifestTesterMessages . getString ( "ManifestTester.26" , Integer . toString ( mNumOfFailures ) ) + "-" ) ; mSummary . append ( ManifestTesterMessages . getString ( "ManifestTester.0" ) + "-" ) ; return mSummary . toString ( ) ; } \n', 0.359441129274007)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 70 #################################
('public double extractSlopeOfDemandFromRegression ( ) { double [ ] coefficients = regression . getResultMatrix ( ) ; double alpha = coefficients [ 1 ] ; double gamma = coefficients [ 2 ] ; if ( alpha != 0 && gamma != 0 ) return - gamma / alpha ; else return 0 ; } \n', 0.33131805804278325)

('public AnalysisResult logisticRegressionRandomAnalysis ( Instances dataInstances , Analysis analysis ) { double ridge = getRandomParameterRidge ( MIN_RIDGE , MAX_RIDGE * 5 ) ; Evaluation trained = logisticRegression ( dataInstances , ridge , LogisticRegressionResult . ITERATE_UNTIL_CONVERGENCE ) ; if ( trained != null ) { double rmse = trained . rootMeanSquaredError ( ) ; double meanAbsoluteError = trained . meanAbsoluteError ( ) ; int correct = ( int ) trained . correct ( ) ; int incorrect = ( int ) trained . incorrect ( ) ; String summary = trained . toSummaryString ( ) ; AnalysisResult res = new LogisticRegressionResult ( analysis . getId ( ) , rmse , meanAbsoluteError , correct , incorrect , summary , ridge , LogisticRegressionResult . ITERATE_UNTIL_CONVERGENCE ) ; return res ; } return null ; } \n', 0.32112756318063973)

('public double extractInterceptOfDemandFromRegression ( ) { double [ ] coefficients = regression . getResultMatrix ( ) ; double alpha = coefficients [ 1 ] ; double beta = coefficients [ 0 ] ; if ( alpha != 0 && beta != 0 ) return - beta / alpha ; else return 0 ; } \n', 0.3101810808762723)

('private static List < LinearFilterRepresentation > getLinearRepList ( HashMap < SIRStream , LinearFilterRepresentation > kidMap , List < SIRStream > kidList ) { List < LinearFilterRepresentation > repList = new LinkedList < LinearFilterRepresentation > ( ) ; Iterator < SIRStream > kidIter = kidList . iterator ( ) ; while ( kidIter . hasNext ( ) ) { repList . add ( kidMap . get ( kidIter . next ( ) ) ) ; } return repList ; } \n', 0.3098637138764637)

('public String getRegression ( ) { String msg = "" ; String [ ] titles = activity . getResources ( ) . getStringArray ( R . array . stat_sections ) ; msg += titles [ 0 ] + "-(a-+-bx)-" ; int count = workingSeries . getCount ( ) ; double [ ] x = workingSeries . getXSet ( ) ; double [ ] y = workingSeries . getYSet ( ) ; if ( count >= 3 ) { SimpleRegression regression = new SimpleRegression ( true ) ; for ( int index = 0 ; index < count ; index ++ ) { regression . addData ( x [ index ] , y [ index ] ) ; } regression . regress ( ) ; msg += "r:-" + regression . getR ( ) + "-" ; msg += "r-squared:-" + regression . getRSquare ( ) + "-" ; msg += "a:-" + regression . getIntercept ( ) + "-" ; msg += "b:-" + regression . getSlope ( ) ; } return msg ; } \n', 0.301359341453871)

('protected List < Double > getCorrelationCoefficients ( final double [ ] [ ] data ) { int n = data . length ; int m = data [ 0 ] . length ; List < Double > correlationCoefficients = new LinkedList < Double > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { double [ ] [ ] x = new double [ n - 1 ] [ m ] ; int k = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) { x [ k ++ ] = data [ j ] ; } } double [ ] [ ] xT = new Array2DRowRealMatrix ( x ) . transpose ( ) . getData ( ) ; correlationCoefficients . add ( MathUtil . createLinearRegression ( xT , data [ i ] ) . calculateRSquared ( ) ) ; } return correlationCoefficients ; } \n', 0.30068454349374457)

('public LinearGaussian ( Gaussian dist ) throws Exception { this . basemu = dist . getExpectedValue ( ) ; this . coefficients = DoubleFactory2D . dense . make ( 1 , 0 ) ; this . gaussian = ( Gaussian ) dist . copy ( ) ; this . stateLayout = new int [ 1 ] ; for ( int i = 0 ; i < stateLayout . length ; i ++ ) { stateLayout [ i ] = - 1 ; } this . numberDimensions = dist . numberDimensions ; this . numberDiscreteParentDimensions = dist . numberDiscreteParentDimensions ; this . numberDiscreteParentStates = dist . numberDiscreteParentStates ; this . numberStates = dist . numberStates ; this . numberContinuousParentDimensions = dist . numberContinuousParentDimensions ; } \n', 0.2971431149757252)

('public double getRegressionSumSquares ( ) { return getRegressionSumSquares ( getSlope ( ) ) ; } \n', 0.2966990891594209)

('private void computeClassLinearExt ( Class c , List < Class > parentLinExt ) { HashSet < Class > currentLinExt = new HashSet < Class > ( ) ; currentLinExt . addAll ( parentLinExt ) ; for ( Class p : c . getParents ( ) ) { currentLinExt . add ( p ) ; } List < Class > orderedLinExt = new ArrayList < Class > ( ) ; orderedLinExt . addAll ( currentLinExt ) ; Collections . sort ( orderedLinExt ) ; this . linearExts . put ( c , orderedLinExt ) ; for ( Class child : c . getSubClasses ( ) ) { computeClassLinearExt ( child , orderedLinExt ) ; } } \n', 0.2876039438864193)

('public static double [ ] logisticRegression ( double [ ] xs , double [ ] ys , double maxValue ) { if ( maxValue <= 0.0 || Double . isInfinite ( maxValue ) || Double . isNaN ( maxValue ) ) { String msg = "Require-finite-max-value->-0." + "-Found-maxValue=" + maxValue ; throw new IllegalArgumentException ( msg ) ; } double [ ] logisticYs = new double [ ys . length ] ; for ( int i = 0 ; i < ys . length ; ++ i ) logisticYs [ i ] = java . lang . Math . log ( ( maxValue - ys [ i ] ) / ys [ i ] ) ; return linearRegression ( xs , logisticYs ) ; } \n', 0.28696524702036774)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 71 #################################
('public static String convertHtmlToXhtml ( String html ) { PrintStream errStream = System . err ; System . setErr ( new PrintStream ( new OutputStream ( ) { @ Override public void write ( int b ) throws IOException { } } ) ) ; Tidy tidy = new Tidy ( ) ; tidy . setXHTML ( true ) ; tidy . setCharEncoding ( Configuration . UTF8 ) ; ByteArrayInputStream inputStream = new ByteArrayInputStream ( html . getBytes ( StandardCharsets . UTF_8 ) ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; tidy . parseDOM ( inputStream , outputStream ) ; System . setErr ( errStream ) ; try { return outputStream . toString ( StandardCharsets . UTF_8 . toString ( ) ) ; } catch ( UnsupportedEncodingException e ) { return html ; } } \n', 0.3929163083544746)

('public static String convertFormattedHtmlTextToExcelPlaintext ( String htmlText ) { if ( htmlText == null ) return "" ; htmlText = htmlText . replaceAll ( "<p>" , "" ) ; htmlText = htmlText . replaceAll ( "-" , "" ) ; htmlText = htmlText . replaceAll ( "</p>" , BreakMark ) ; htmlText = htmlText . replaceAll ( "<p-/>" , BreakMark ) ; htmlText = htmlText . replaceAll ( "<br-/>" , BreakMark ) ; htmlText = FormattedText . convertFormattedTextToPlaintext ( htmlText ) ; StringBuilder sb = new StringBuilder ( ) ; int begin_pos = 0 ; int find_pos = 0 ; while ( find_pos > - 1 && find_pos < htmlText . length ( ) ) { find_pos = htmlText . indexOf ( BreakMark , begin_pos ) ; if ( find_pos > - 1 ) { sb . append ( htmlText . subSequence ( begin_pos , find_pos ) ) ; sb . append ( LINEBREAK_EXCEL ) ; find_pos += BreakMark . length ( ) ; begin_pos = find_pos ; } } if ( begin_pos < htmlText . length ( ) ) { sb . append ( htmlText . subSequence ( begin_pos , htmlText . length ( ) - 1 ) ) ; } htmlText = htmlText . replaceAll ( BreakMark , LINEBREAK_EXCEL ) ; return htmlText ; } \n', 0.36534099759716676)

('public static String convertToHtml ( String source , boolean permitUnicode , boolean enableHyperLink , boolean enableAnchorLink , String bbs , Integer key ) { source = HtmlUtils . htmlEscape ( source ) ; StringBuilder stb = new StringBuilder ( ) ; for ( String str : source . replaceAll ( "-" , "-" ) . replaceAll ( "-" , "-" ) . split ( "-" ) ) { if ( permitUnicode ) { str = UnicodeHelper . unescapeUnicode ( str ) ; } if ( enableAnchorLink ) { Matcher anchorMatcher = anchorPattern . matcher ( str ) ; while ( anchorMatcher . find ( ) ) { String anchor = anchorMatcher . group ( ) ; str = str . replace ( anchor , String . format ( "<a-href="/test/read.cgi/%s/%s/%s"-target="_blank">%s</a>" , bbs , key , anchor . substring ( 8 ) , anchor ) ) ; } } if ( enableHyperLink ) { Matcher hyperLinkMatcher = hyperLinkPattern . matcher ( str ) ; if ( hyperLinkMatcher . find ( ) ) { str = hyperLinkMatcher . replaceAll ( "<a-href="$0"-target="_blank">$0</a>" ) ; } } stb . append ( str ) ; stb . append ( "<br>" ) ; } return stb . substring ( 0 , stb . length ( ) - 4 ) ; } \n', 0.3626736471121296)

('public static Stream < String > convertHTMLToText ( ArrayList < String > paragraphTags ) { Pattern pattern = Pattern . compile ( ">[^<>]+<" ) ; return paragraphTags . stream ( ) . map ( ( line ) -> pattern . matcher ( line ) ) . map ( ( matcher ) -> { StringBuilder lineWithoutHTMLBuilder = new StringBuilder ( ) ; while ( matcher . find ( ) ) { if ( ! matcher . group ( ) . equals ( ">&nbsp;<" ) ) { lineWithoutHTMLBuilder . append ( matcher . group ( ) . substring ( 1 , matcher . group ( ) . length ( ) - 1 ) ) ; } } return lineWithoutHTMLBuilder . toString ( ) ; } ) ; } \n', 0.36109442957916016)

('public static String convertHTMLTagsToXHTML ( String htmlText ) { StringBuffer sb = new StringBuffer ( htmlText ) ; int i = 0 ; boolean inTag = false ; String tag = null ; while ( i < sb . length ( ) ) { char c = sb . charAt ( i ) ; if ( inTag ) { if ( c == \'>\' ) { if ( Comments . isMinimizedTag ( tag ) && htmlText . indexOf ( "</" + tag + ">" , i ) == - 1 ) sb . insert ( i , "/" ) ; inTag = false ; } else { tag += c ; } } if ( c == \'<\' ) { inTag = true ; tag = "" ; } if ( c == \'-\' && i > 0 && sb . charAt ( i - 1 ) == \'-\' ) { if ( ! ( i > 1 && sb . charAt ( i - 2 ) == \'!\' ) ) { sb . setCharAt ( i , \'&\' ) ; sb . insert ( i + 1 , "#045;" ) ; i += 5 ; } } i ++ ; } if ( inTag ) { sb . insert ( i , ">" ) ; } return sb . toString ( ) ; } \n', 0.3579878354891909)

('private void convertDivToParagraph ( Document docToClean , String tag ) { logger . debug ( "Starting-to-replace-bad-divs" ) ; Elements divElements = docToClean . getElementsByTag ( tag ) ; for ( Element divElement : divElements ) { boolean hasBlock = false ; for ( Element divChild : divElement . getAllElements ( ) ) { if ( divChild != divElement ) { if ( Patterns . DIV_TO_P_ELEMENTS . contains ( divChild . tagName ( ) ) ) { hasBlock = true ; } } } if ( ! hasBlock ) { Element newElement = changeElementTag ( divElement , "p" ) ; } else { for ( int i = 0 ; i < divElement . childNodes ( ) . size ( ) ; i ++ ) { Node childNode = divElement . childNodes ( ) . get ( i ) ; if ( childNode instanceof TextNode ) { Element p = docToClean . createElement ( "p" ) ; p . html ( ( ( TextNode ) childNode ) . text ( ) ) ; childNode . replaceWith ( p ) ; } } } } } \n', 0.35610171723881756)

('public static String convertTweetsToHTML ( ) { String content = "<html><head></head><body><table-border=1>" ; int limit ; if ( PageRankGUI . actTweetsRetrieved . size ( ) < Integer . parseInt ( PageRankGUI . maxDocumentsLoad ) ) limit = PageRankGUI . actTweetsRetrieved . size ( ) ; else limit = Integer . parseInt ( PageRankGUI . maxDocumentsLoad ) ; for ( int i = 0 ; i < limit ; i ++ ) content += PageRankGUI . actTweetsRetrieved . get ( i ) . converToHTML ( ) ; content += "</table></body></html>" ; return content ; } \n', 0.3558755680952718)

('public String convertSWFToHTML ( InputStream in ) throws Exception { StringWriter out1 = new StringWriter ( ) ; output = new PrintWriter ( out1 ) ; TagParser parser = new TagParser ( this ) ; SWFReader reader = new SWFReader ( parser , in ) ; reader . readFile ( ) ; in . close ( ) ; sizeCount = reader . size ; final String ret = "<html>" + ( headerstr . isEmpty ( ) ? "<body>" : "<header>" + headerstr + "</header><body>" ) + out1 . toString ( ) + "</body></html>" ; return ret ; } \n', 0.3523894391694895)

('public static String convertContentsToHTML ( ArrayList < Contentlet > contents ) { StringBuffer buffy = new StringBuffer ( ) ; for ( Contentlet contentlet : contents ) { } return buffy . toString ( ) ; } \n', 0.35194431184322644)

('private String convertToHtml ( String rawString ) { if ( debug ) { System . out . println ( "TooltipFormatter.convertToHtml:rawString=" + rawString ) ; } StringBuffer buffer = new StringBuffer ( rawString ) ; int index = rawString . length ( ) ; HtmlMask htmlMask = new HtmlMask ( ) ; htmlMask . mask ( rawString ) ; while ( index >= 0 ) { index = Math . max ( buffer . lastIndexOf ( "<" , index - 1 ) , buffer . lastIndexOf ( ">" , index - 1 ) ) ; if ( index != - 1 && ! htmlMask . isMasked ( index ) ) { char c = buffer . charAt ( index ) ; buffer . deleteCharAt ( index ) ; if ( c == \'<\' ) { buffer . insert ( index , "<html>&lt" ) ; } else if ( c == \'>\' ) { buffer . insert ( index , "<html>&gt" ) ; } } } if ( debug ) { System . out . println ( "TooltipFormatter.convertToHtml:buffer.toString()=" + buffer . toString ( ) ) ; } return buffer . toString ( ) ; } \n', 0.34782448111235287)

FRank:   | P@1:   | P@5:   | P@10: 

Mean sims: 0.374