########################## 1 #################################
('public String createAndStoreCookie ( AuthenticationContext context , long expires , String ipAddr ) { String encodedCookieValue = encodeCookieValue ( context , expires , ipAddr ) ; UUID uuid = UUID . randomUUID ( ) ; COOKIE_CACHE . put ( uuid . toString ( ) , encodedCookieValue ) ; return uuid . toString ( ) ; } \n', 0.43058113089070693)

('public static Cookie createCookie ( String cookieName , @ Sensitive String cookieValue , HttpServletRequest req ) { return createCookie ( cookieName , cookieValue , - 1 , req ) ; }\n', 0.4225020510805666)

('private static char [ ] makeCookieSafe ( byte [ ] bytes ) throws UnsupportedEncodingException { char [ ] chars = new String ( bytes , "ISO-8859-1" ) . toCharArray ( ) ; int BOT = 48 ; int TOP = 125 ; for ( int x = 0 ; x < chars . length ; x ++ ) { while ( chars [ x ] < BOT || chars [ x ] > TOP ) { if ( chars [ x ] < BOT ) chars [ x ] += BOT ; else if ( chars [ x ] > TOP ) chars [ x ] -= TOP ; } if ( chars [ x ] == \';\' ) { chars [ x ] = ( char ) BOT ; } } return chars ; } \n', 0.40956438993703875)

('private static String createCookieHeader ( URLConnection cnx ) { String host = cnx . getURL ( ) . getHost ( ) ; StringBuilder cookiesHeader = new StringBuilder ( ) ; for ( Map . Entry < String , Map < String , String >> domainCookies : cookies . entrySet ( ) ) { if ( host . endsWith ( domainCookies . getKey ( ) ) ) { for ( Map . Entry < String , String > cookie : domainCookies . getValue ( ) . entrySet ( ) ) { cookiesHeader . append ( cookie . getKey ( ) ) ; cookiesHeader . append ( "=" ) ; cookiesHeader . append ( cookie . getValue ( ) ) ; cookiesHeader . append ( ";" ) ; } } } if ( cookiesHeader . length ( ) > 0 ) { cookiesHeader . deleteCharAt ( cookiesHeader . length ( ) - 1 ) ; } return cookiesHeader . toString ( ) ; } \n', 0.3979840222255352)

('@ SuppressWarnings ( "unused" ) private PortalCookieImpl ( ) { this . internalPortalCookieId = - 1 ; this . entityVersion = - 1 ; this . created = new Date ( ) ; this . expires = null ; this . value = null ; this . portletCookies = new HashSet < IPortletCookie > ( ) ; } \n', 0.3972550197315188)

('protected String getSessionCookie ( Request request ) { Cookie [ ] cookies = request . getCookies ( ) ; log . trace ( "Cookies:" + cookies ) ; int numCookies = cookies != null ? cookies . length : 0 ; String ids = "" ; try { ids = this . getSessionCookieId ( ) ; log . trace ( "Session-Cookie-Ids=" + ids ) ; } catch ( JMException e ) { if ( trace ) log . trace ( "checkSessionCookie-exception" , e ) ; } if ( ids == null || ids . length ( ) == 0 ) throw new IllegalStateException ( "Session-cookies-configuration-in-tomcat-service-missing" ) ; StringTokenizer st = new StringTokenizer ( ids , "," ) ; while ( st . hasMoreTokens ( ) ) { String cookieToken = st . nextToken ( ) ; String val = getCookieValue ( cookies , numCookies , cookieToken ) ; if ( val != null ) return val ; } if ( trace ) log . trace ( "Session-Cookie-not-found" ) ; return null ; } \n', 0.39357389083177374)

('protected org . apache . http . client . CookieStore createProxyClientCookieStore ( final Page . Request pageRequest ) throws WWWEEEPortal . Exception { org . apache . http . client . CookieStore proxyClientCookieStore = PROXY_CLIENT_COOKIE_STORE_HOOK . value ( plugins , null , pageRequest ) ; if ( proxyClientCookieStore == null ) { proxyClientCookieStore = new BasicCookieStore ( ) ; } proxyClientCookieStore = PROXY_CLIENT_COOKIE_STORE_HOOK . requireFilteredResult ( PROXY_CLIENT_COOKIE_STORE_HOOK . filter ( plugins , null , pageRequest , proxyClientCookieStore ) ) ; return proxyClientCookieStore ; } \n', 0.3892450381155468)

('public Future < CreateLBCookieStickinessPolicyResult > createLBCookieStickinessPolicyAsync ( final CreateLBCookieStickinessPolicyRequest createLBCookieStickinessPolicyRequest , final AsyncHandler < CreateLBCookieStickinessPolicyRequest , CreateLBCookieStickinessPolicyResult > asyncHandler ) throws AmazonServiceException , AmazonClientException { return executorService . submit ( new Callable < CreateLBCookieStickinessPolicyResult > ( ) { public CreateLBCookieStickinessPolicyResult call ( ) throws Exception { CreateLBCookieStickinessPolicyResult result ; try { result = createLBCookieStickinessPolicy ( createLBCookieStickinessPolicyRequest ) ; } catch ( Exception ex ) { asyncHandler . onError ( ex ) ; throw ex ; } asyncHandler . onSuccess ( createLBCookieStickinessPolicyRequest , result ) ; return result ; } } ) ; } \n', 0.388831371881475)

('public Future < CreateAppCookieStickinessPolicyResult > createAppCookieStickinessPolicyAsync ( final CreateAppCookieStickinessPolicyRequest createAppCookieStickinessPolicyRequest , final AsyncHandler < CreateAppCookieStickinessPolicyRequest , CreateAppCookieStickinessPolicyResult > asyncHandler ) throws AmazonServiceException , AmazonClientException { return executorService . submit ( new Callable < CreateAppCookieStickinessPolicyResult > ( ) { public CreateAppCookieStickinessPolicyResult call ( ) throws Exception { CreateAppCookieStickinessPolicyResult result ; try { result = createAppCookieStickinessPolicy ( createAppCookieStickinessPolicyRequest ) ; } catch ( Exception ex ) { asyncHandler . onError ( ex ) ; throw ex ; } asyncHandler . onSuccess ( createAppCookieStickinessPolicyRequest , result ) ; return result ; } } ) ; } \n', 0.38659079081666486)

('private SessionMapEntry createNewSidAndCookie ( ) { String alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ; String newSid = "" ; for ( int i = 0 ; i < 20 ; i ++ ) { newSid += alphabet . charAt ( sessionRandom . nextInt ( alphabet . length ( ) ) ) ; } int validUntil = ( int ) ( new Date ( ) . getTime ( ) / 1000 ) + sessionTimeout ; SessionMapEntry entry = new SessionMapEntry ( newSid , validUntil ) ; sessions . put ( newSid , entry ) ; outputCookies . add ( new RCCookie ( "sid" , newSid , sessionTimeout , address , "/" ) ) ; return entry ; } \n', 0.3841599254563476)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 2 #################################
('public static Properties readPropertiesFromFile ( File file ) throws IOException { try ( FileInputStream fis = new FileInputStream ( file ) ) { Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } }\n', 0.479946652211277)

('public static Properties readPropertiesFile ( File file ) { Properties prop = null ; InputStream is = null ; try { is = new FileInputStream ( file ) ; prop = new Properties ( ) ; prop . load ( is ) ; } catch ( Exception e ) { prop = null ; } finally { try { if ( is != null ) is . close ( ) ; } catch ( IOException e ) { } } return prop ; } \n', 0.469608291345612)

('ExtendedProperties readPropertiesFromFile ( String fileName ) throws FileNotFoundException , IOException { ExtendedProperties p = new ExtendedProperties ( ) ; FileInputStream in = new FileInputStream ( fileName ) ; p . load ( in ) ; in . close ( ) ; return p ; } \n', 0.4690757293540833)

('public static void readPropertiesFromFile ( String fileName ) { if ( fileName == null ) { fileName = CONFIG_FILE_LOCATION ; } constructDefaultProperties ( ) ; File configFile = new File ( fileName ) ; if ( configFile . exists ( ) && configFile . canRead ( ) ) { try { InputStream inputStream = new FileInputStream ( configFile ) ; if ( fileName . substring ( fileName . length ( ) - 4 ) . equalsIgnoreCase ( ".xml" ) ) { m_properties . loadFromXML ( inputStream ) ; } else { m_properties . load ( inputStream ) ; } } catch ( Exception e ) { System . err . println ( "Cannot-load-Ladder-properties-from-file:-" + fileName ) ; e . printStackTrace ( ) ; } } else { System . err . println ( "Cannot-read-file:-" + fileName ) ; } } \n', 0.4670143213104635)

('private Properties readFileProperties ( ) { Properties props = null ; FileInputStream fis = null ; try { props = new Properties ( ) ; fis = new FileInputStream ( fileProperties ) ; props . load ( fis ) ; } catch ( Exception e ) { logger . error ( "ERROR:-GetProperties().readFileProperties()" , e ) ; } if ( props == null ) { logger . error ( "ERROR:-GetProperties().getProperties()-readFileProperties-null" ) ; } return props ; } \n', 0.46263376059243605)

('private static void readPropertiesFromFile ( WMSLogger logger , String vHostRootDir ) { try { properties = new Properties ( ) ; File propertyFile = new File ( vHostRootDir + "/" + propertyFilePath ) ; logger . info ( "Loading-properties-from-file:" + propertyFile . getAbsoluteFile ( ) ) ; properties . load ( new FileInputStream ( propertyFile ) ) ; } catch ( IOException e ) { throw new RuntimeException ( "Could-not-read-properties." , e ) ; } } \n', 0.46253681601993113)

('public static Properties readPropertiesFile ( String canonicalFilename ) throws IOException { Properties properties = new Properties ( ) ; properties . load ( new FileInputStream ( canonicalFilename ) ) ; return properties ; } \n', 0.46252315676615896)

('public static void readPropertiesFile ( Context context ) { String propertiesPath = context . getFilesDir ( ) . getPath ( ) . toString ( ) + File . separatorChar + FILE_CONFIG_PROPERTIES ; if ( new File ( propertiesPath ) . exists ( ) ) { Properties properties = new Properties ( ) ; try { FileInputStream input = new FileInputStream ( propertiesPath ) ; properties . load ( input ) ; LINK_UPLOAD_ACTIVITYLOGS = properties . getProperty ( AppKey . CONFIG_LINK_SERVER_LOCAL . getKey ( ) ) ; } catch ( IOException e ) { } } } \n', 0.4619229827845097)

('public static Map < String , String > readPropertiesFile ( String propertiesFile ) throws NotificationServiceException { FileInputStream inStream = null ; Properties properties = new Properties ( ) ; try { inStream = new FileInputStream ( propertiesFile ) ; properties . load ( inStream ) ; } catch ( IOException e ) { throw new NotificationServiceException ( "Failed-to-read-configuration-file-" + propertiesFile , e ) ; } finally { if ( inStream != null ) { try { inStream . close ( ) ; } catch ( Exception e ) { throw new NotificationServiceException ( "Failed-to-close-configuration-file-stream" , e ) ; } } } return fillPropertiesMap ( properties ) ; } \n', 0.4614393255685419)

('private Properties ReadFileProperties ( ) { Properties props = null ; FileInputStream file = null ; File f = null ; try { InputStream inputStream = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( "/WebSniffer.properties" ) ; f = new File ( this . fileProperties ) ; props = new Properties ( ) ; file = new FileInputStream ( f . getAbsolutePath ( ) ) ; props . load ( inputStream ) ; try { file . close ( ) ; } finally { file = null ; f = null ; } } catch ( IOException ex ) { logger . error ( "ERROR:-ReadFileProperties()-" , ex ) ; } catch ( Exception e ) { logger . error ( "ERROR:-ReadFileProperties()-" , e ) ; } return props ; } \n', 0.46122102683368194)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 3 #################################
('protected File getExecutableFromPath ( String name ) throws IOException { if ( SystemUtils . IS_OS_WINDOWS ) { name = name + ".exe" ; } String systemPath = System . getenv ( "PATH" ) ; if ( systemPath == null ) { systemPath = System . getenv ( "path" ) ; } if ( systemPath == null ) { throw new IOException ( "Path-is-not-set,-cannot-locate-" + name ) ; } String [ ] paths = systemPath . split ( File . pathSeparator ) ; for ( String pathDir : paths ) { File file = new File ( pathDir , name ) ; if ( file . exists ( ) && file . isFile ( ) && file . canExecute ( ) ) { return file ; } } throw new IOException ( "Could-not-locate-executable-(or-could-locate,-but-does-not-have-execution-rights):-" + name ) ; } \n', 0.40266258349057465)

('private String getFullExecutablePath ( ) { StringBuffer pathBuf = new StringBuffer ( ) ; String optionalExecutablePath = getServerProps ( ) . getProperty ( EXECUTABLE_PATH_KEY ) ; if ( optionalExecutablePath == null ) { String basedir = getServerProps ( ) . getProperty ( BASEDIR_KEY ) ; pathBuf . append ( basedir ) ; if ( ! basedir . endsWith ( File . separator ) ) { pathBuf . append ( File . separatorChar ) ; } if ( runningOnWindows ( ) ) { pathBuf . append ( "bin" ) ; } else { pathBuf . append ( "libexec" ) ; } pathBuf . append ( File . separatorChar ) ; } else { pathBuf . append ( optionalExecutablePath ) ; if ( ! optionalExecutablePath . endsWith ( File . separator ) ) { pathBuf . append ( File . separatorChar ) ; } } String executableName = getServerProps ( ) . getProperty ( EXECUTABLE_NAME_KEY , "mysqld" ) ; pathBuf . append ( executableName ) ; return pathBuf . toString ( ) ; } \n', 0.3935444546000719)

('public static String getExecutablePath ( String executable , ToolchainManager toolchainManager , MavenSession session ) { File execFile = new File ( executable ) ; if ( execFile . exists ( ) ) { return execFile . getAbsolutePath ( ) ; } else { Toolchain tc = toolchainManager . getToolchainFromBuildContext ( "jdk" , session ) ; if ( tc != null ) { executable = tc . findTool ( executable ) ; } } return executable ; } \n', 0.36794144900912956)

('public static File [ ] getPathFromEnvironment ( String envVariable , String delim ) { if ( System . getProperty ( "os.name" ) . equals ( "OS/400" ) ) return new File [ ] { } ; Vector osEnv = Execute . getProcEnvironment ( ) ; String match = envVariable . concat ( "=" ) ; for ( Enumeration e = osEnv . elements ( ) ; e . hasMoreElements ( ) ; ) { String entry = ( ( String ) e . nextElement ( ) ) . trim ( ) ; if ( entry . length ( ) > match . length ( ) ) { String entryFrag = entry . substring ( 0 , match . length ( ) ) ; if ( entryFrag . equalsIgnoreCase ( match ) ) { String path = entry . substring ( match . length ( ) ) ; return parsePath ( path , delim ) ; } } } File [ ] noPath = new File [ 0 ] ; return noPath ; } \n', 0.35377609789180575)

('protected String getJavaExecutablePath ( ) { String executableName = isWindows ( ) ? "bin/java.exe" : "bin/java" ; return PROPERTIES . getJavaHome ( ) . resolve ( executableName ) . toAbsolutePath ( ) . toString ( ) ; }\n', 0.34590798244270005)

('public static String getExecutableAbsolutePath ( String exe ) { if ( exe == null ) { return exe ; } if ( exe . indexOf ( File . separatorChar ) >= 0 ) { File f = new File ( exe ) ; if ( f . exists ( ) ) { return f . getAbsolutePath ( ) ; } File fexe = new File ( exe + ".exe" ) ; if ( fexe . exists ( ) ) { return fexe . getAbsolutePath ( ) ; } return exe ; } else { String path = EnvVars . masterEnvVars . get ( "PATH" ) ; String tokenizedPath = "" ; String delimiter = null ; if ( path != null ) { for ( String _dir : Util . tokenize ( path . replace ( "|" , "||" ) , File . pathSeparator ) ) { if ( delimiter == null ) { delimiter = ",-" ; } else { tokenizedPath += delimiter ; } tokenizedPath += _dir . replace ( \'|\' , \'/\' ) ; File dir = new File ( _dir ) ; File f = new File ( dir , exe ) ; if ( f . exists ( ) ) { return f . getAbsolutePath ( ) ; } File fexe = new File ( dir , exe + ".exe" ) ; if ( fexe . exists ( ) ) { return fexe . getAbsolutePath ( ) ; } } tokenizedPath += "." ; } } return exe ; } \n', 0.3390817277373716)

('@ Deprecated public static final String getPathSeparator ( ) { if ( pathSeparator == null ) { pathSeparator = AccessController . doPrivileged ( new PrivilegedAction < String > ( ) { public String run ( ) { return System . getProperty ( "path.separator" ) ; } } ) ; } return pathSeparator ; } \n', 0.3385104129844919)

("public static String [ ] getPathStrings ( String commaSeparatedPaths ) { int length = commaSeparatedPaths . length ( ) ; int curlyOpen = 0 ; int pathStart = 0 ; boolean globPattern = false ; List < String > pathStrings = new ArrayList < String > ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char ch = commaSeparatedPaths . charAt ( i ) ; switch ( ch ) { case '{' : { curlyOpen ++ ; if ( ! globPattern ) { globPattern = true ; } break ; } case '}' : { curlyOpen -- ; if ( curlyOpen == 0 && globPattern ) { globPattern = false ; } break ; } case ',' : { if ( ! globPattern ) { pathStrings . add ( commaSeparatedPaths . substring ( pathStart , i ) ) ; pathStart = i + 1 ; } break ; } } } pathStrings . add ( commaSeparatedPaths . substring ( pathStart , length ) ) ; return pathStrings . toArray ( new String [ 0 ] ) ; } \n", 0.3098855197253669)

('private String doCreateFullPathForRedirectFromLocalPath ( HttpServletRequest request , SiteKey siteKey , String localPath ) { StringBuffer s = new StringBuffer ( ) ; s . append ( request . getContextPath ( ) ) ; s . append ( resolveLocalSitePathPrefix ( request , siteKey , true ) ) ; if ( ! localPath . startsWith ( "/" ) && ! localPath . equals ( "" ) ) { localPath = "/" + localPath ; } s . append ( encodePath ( localPath , siteKey ) ) ; return s . toString ( ) ; } \n', 0.3080173960058391)

('private static List getTomcatPaths ( ) { String tomcatPath = System . getProperty ( "catalina.home" ) ; if ( tomcatPath == null ) { return null ; } String commonClasspath = System . getProperty ( "common.loader" ) ; if ( commonClasspath == null ) { return null ; } StringBuffer buffer = new StringBuffer ( commonClasspath ) ; String pathDeclaration = "${catalina.home}" ; int length = pathDeclaration . length ( ) ; boolean doneReplace = false ; do { int start = commonClasspath . indexOf ( pathDeclaration ) ; if ( start >= 0 ) { buffer . replace ( start , ( start + length ) , tomcatPath ) ; commonClasspath = buffer . toString ( ) ; } else { doneReplace = true ; } } while ( ! doneReplace ) ; String [ ] paths = commonClasspath . split ( "," ) ; List pathList = new ArrayList ( paths . length ) ; for ( int i = 0 ; i < paths . length ; i ++ ) { String path = paths [ i ] ; pathList . add ( getCanonicalPath ( path ) ) ; } return pathList ; } \n', 0.30670453024589295)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 4 #################################
('private void generatAllPermutation ( Startup source , List < Startup > newlist , List < Startup > startupList ) { if ( startupList . size ( ) == 0 ) { newlist . add ( 0 , source ) ; graph . add ( newlist ) ; return ; } for ( int i = 0 ; i < startupList . size ( ) ; i ++ ) { List < Startup > tempList2 = new ArrayList < Startup > ( newlist ) ; tempList2 . add ( startupList . get ( i ) ) ; List < Startup > tempList = new ArrayList < Startup > ( startupList ) ; tempList . remove ( i ) ; generatAllPermutation ( source , tempList2 , tempList ) ; } } \n', 0.410642952921933)

('public static List < Integer > randPermutation ( final int size ) { positiveCheck ( size ) ; final List < Integer > permutation = new ArrayList < > ( ) ; for ( int i = 1 ; i < size + 1 ; ++ i ) permutation . add ( i ) ; Collections . shuffle ( permutation ) ; return permutation ; } \n', 0.37461130247001817)

('public List < T > nextPermutationAsList ( List < T > destination ) { generateNextPermutationIndices ( ) ; destination . clear ( ) ; for ( int i : permutationIndices ) { destination . add ( elements [ i ] ) ; } return destination ; } \n', 0.3740559039025473)

('private void checkPermutation ( Integer [ ] permutation ) throws PermutationException { int n = permutation . length ; ArrayList < Integer > check = new ArrayList < Integer > ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( check . contains ( permutation [ i ] ) ) ) check . add ( permutation [ i ] ) ; } if ( check . size ( ) != n ) throw new PermutationException ( "Permutation-does-not-make-sense!" ) ; Integer [ ] sorted = new Integer [ n ] ; check . toArray ( sorted ) ; Arrays . sort ( sorted ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( sorted [ i ] != ( i + 1 ) ) throw new PermutationException ( "Permutation-does-not-make-sense!" ) ; } } \n', 0.37120477735143154)

('private static void permute ( List < List < Integer >> result , List < Integer > temp , List < Integer > remaining ) { if ( remaining . isEmpty ( ) ) { result . add ( temp ) ; return ; } Set < Integer > dedup = new HashSet < Integer > ( ) ; Iterator < Integer > iter = remaining . iterator ( ) ; while ( iter . hasNext ( ) ) { Integer i = iter . next ( ) ; if ( dedup . contains ( i ) ) { continue ; } dedup . add ( i ) ; List < Integer > t = new ArrayList < Integer > ( temp ) ; List < Integer > r = new ArrayList < Integer > ( remaining ) ; t . add ( i ) ; r . remove ( i ) ; permute ( result , t , r ) ; } } \n', 0.3636869289715382)

('public static List < Integer > getAllPartitions ( AdminClient adminClient ) { List < Integer > partIds = Lists . newArrayList ( ) ; partIds = Lists . newArrayList ( ) ; for ( Node node : adminClient . getAdminClientCluster ( ) . getNodes ( ) ) { partIds . addAll ( node . getPartitionIds ( ) ) ; } return partIds ; } \n', 0.35988654421931143)

('private void nextTokensPermutation ( ) { Matrix . Column . Row [ ] rowsPermutation ; rowsPermutation = ( Matrix . Column . Row [ ] ) permutations . next ( ) ; List currentPermutationRows = new ArrayList ( ) ; List currentPermuationTokens = new ArrayList ( ) ; for ( int i = 0 ; i < rowsPermutation . length ; i ++ ) { Matrix . Column . Row row = rowsPermutation [ i ] ; for ( Iterator iterator = row . getTokens ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { currentPermuationTokens . add ( iterator . next ( ) ) ; currentPermutationRows . add ( row ) ; } } this . currentPermuationTokens = currentPermuationTokens ; this . currentPermutationRows = currentPermutationRows ; currentPermutationTokensStartOffset = 0 ; currentShingleLength = minimumShingleSize - 1 ; } \n', 0.35785553963653316)

('public static List < String > allAbbreviationsOfPieces ( ) { List < String > allAbbreviations = new ArrayList < String > ( ) ; for ( Piece pc : EnumSet . allOf ( Piece . class ) ) { allAbbreviations . add ( pc . getPieceAbbreviation ( ) ) ; } return allAbbreviations ; } \n', 0.3567417134316745)

('public void generateAllPermutationIteratively ( Startup source , List < Startup > list ) { int i = 0 ; int N = list . size ( ) ; List < Startup > newList = new ArrayList < Startup > ( ) ; newList . add ( source ) ; newList . addAll ( list ) ; graph . add ( newList ) ; int p [ ] = new int [ N ] ; for ( i = 0 ; i < N ; i ++ ) { p [ i ] = 0 ; } i = 1 ; while ( i < N ) { if ( p [ i ] < i ) { int j = i % 2 * p [ i ] ; Startup tmp = list . get ( j ) ; list . set ( j , list . get ( i ) ) ; list . set ( i , tmp ) ; newList = new ArrayList < Startup > ( ) ; newList . add ( source ) ; newList . addAll ( list ) ; graph . add ( newList ) ; p [ i ] ++ ; i = 1 ; } else { p [ i ] = 0 ; i ++ ; } } } \n', 0.35615898405931584)

('public static < C extends RingElem < C >> List < GenPolynomial < GenPolynomial < C >>> permutationOnCoefficients ( List < Integer > P , GenPolynomialRing < GenPolynomial < C >> R , List < GenPolynomial < GenPolynomial < C >>> L ) { if ( L == null || L . size ( ) == 0 ) { return L ; } List < GenPolynomial < GenPolynomial < C >>> K = new ArrayList < GenPolynomial < GenPolynomial < C >>> ( L . size ( ) ) ; for ( GenPolynomial < GenPolynomial < C >> a : L ) { GenPolynomial < GenPolynomial < C >> b = permutationOnCoefficients ( P , R , a ) ; K . add ( b ) ; } return K ; } \n', 0.35327994615876573)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 5 #################################
('protected static String formatDateString ( Date d ) { String dateFormat = "yyyyMMddHHmm" ; java . text . SimpleDateFormat sdf = new java . text . SimpleDateFormat ( dateFormat ) ; sdf . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; return sdf . format ( d ) ; } \n', 0.3707525660482928)

('private static boolean isDateString ( String string ) { try { Date date = dateFormat . parse ( string ) ; if ( ! string . equals ( dateFormat . format ( date ) ) ) throw new ParseException ( "Incorrect-Date" , 0 ) ; return true ; } catch ( Exception e ) { return false ; } } \n', 0.37051086704723524)

('public static int compareDateString ( String dateString1 , String dateString2 ) { Date date1 = getDateFromString ( dateString1 ) ; Date date2 = getDateFromString ( dateString2 ) ; int yyyymmdd1 = date1 . getYear ( ) * 10000 + date1 . getMonth ( ) * 100 + date1 . getDate ( ) ; int yyyymmdd2 = date2 . getYear ( ) * 10000 + date2 . getMonth ( ) * 100 + date2 . getDate ( ) ; if ( yyyymmdd1 > yyyymmdd2 ) return 1 ; else if ( yyyymmdd1 == yyyymmdd2 ) return 0 ; return - 1 ; } \n', 0.36634836882867144)

('public static boolean sameDateStrings ( String compDateStr , String baseDateStr ) throws ParseException { SimpleDateFormat baseFormat = new SimpleDateFormat ( "M/d/yyyy" ) ; Date baseDate = baseFormat . parse ( baseDateStr ) ; SimpleDateFormat localFormat = new SimpleDateFormat ( DateRangePanel . DATE_PATTERN , Locale . getDefault ( ) ) ; Date compDate = localFormat . parse ( compDateStr ) ; return baseDate . equals ( compDate ) ; } \n', 0.3647936397830185)

('public static long compareDateStrings ( String startDateTime , String endDateTime ) throws ParseException { Date start = timeAndDateFormatter . parse ( startDateTime ) ; Date end = timeAndDateFormatter . parse ( endDateTime ) ; return end . getTime ( ) - start . getTime ( ) ; } \n', 0.36467638331659047)

('private void checkDateToString ( ) { int COUNT = COUNT_SLOW ; Date dt = new Date ( ) ; for ( int i = 0 ; i < AVERAGE ; i ++ ) { start ( "Date" , "toString" ) ; for ( int j = 0 ; j < COUNT ; j ++ ) { SimpleDateFormat sdf = new SimpleDateFormat ( "dd-MMM-yyyy" ) ; String str = sdf . format ( dt ) ; if ( str == null ) { System . out . println ( "Anti-optimise" ) ; } } end ( COUNT ) ; } } \n', 0.3637038677245125)

('@ Override public String getFormattedDateString ( long timeMillis ) { DateTime dt = new DateTime ( timeMillis ) ; if ( dt . monthOfYear ( ) . get ( ) == 12 && dt . weekOfWeekyear ( ) . get ( ) < 3 ) { return dt . getYearOfCentury ( ) + "53" ; } return Integer . toString ( dt . getYearOfCentury ( ) ) + String . format ( "%02d" , dt . weekOfWeekyear ( ) . get ( ) ) ; } \n', 0.36337303762875633)

('public DateTime validateDateString ( String dateString , String format ) throws ParamValidationException { SimpleDateFormat dateFormat = new SimpleDateFormat ( format ) ; try { return new DateTime ( dateFormat . parse ( dateString ) ) ; } catch ( ParseException e ) { throw new ParamValidationException ( ErrorMessage . INVALID_DATE_STRING + "in-format-" + format ) ; } } \n', 0.36249090512975984)

('public String expiryDateAsString ( ) { return String . format ( "%02d/%02d" , expiryDate . getMonthOfYear ( ) , expiryDate . getYearOfCentury ( ) ) ; } \n', 0.3607308061655038)

('public static Date fromISO8601DateString ( String iso8601FormattedDate ) throws InvalidFormatException { SimpleDateFormat iso8601Format = new SimpleDateFormat ( "yyyy-MM-dd\'T\'HH:mm:ss" ) ; try { return iso8601Format . parse ( iso8601FormattedDate ) ; } catch ( ParseException e ) { throw new InvalidFormatException ( "Error-parsing-as-date" , iso8601FormattedDate , Date . class ) ; } } \n', 0.3602477446400424)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 6 #################################
('private void setupVariableCheckboxToolTip ( ) { if ( variableCheckbox != null ) { if ( variableCheckbox . getSelection ( ) ) variableCheckbox . setToolTipText ( IDEWorkbenchMessages . ImportTypeDialog_importElementsAsTooltipSet ) ; else variableCheckbox . setToolTipText ( IDEWorkbenchMessages . ImportTypeDialog_importElementsAsTooltip ) ; } } \n', 0.4018512555822971)

('private void noneCheckboxSelected ( boolean state ) { editButton . setEnabled ( ! state ) ; showPasswordCheckbox . setEnabled ( ! state ) ; } \n', 0.3965265495204018)

('public InputDialogWithCheckbox ( String message , @ Nls ( capitalization = Nls . Capitalization . Title ) String title , String checkboxText , boolean checked , boolean checkboxEnabled , @ Nullable Icon icon , @ Nullable String initialValue , @ Nullable InputValidator validator ) { super ( message , title , icon , initialValue , validator ) ; myCheckBox . setText ( checkboxText ) ; myCheckBox . setSelected ( checked ) ; myCheckBox . setEnabled ( checkboxEnabled ) ; } \n', 0.3901640840621118)

('public static JCheckBox checkbox ( String text , final PropertyChangeBean bean , final String property ) { final JCheckBox checkbox = new JCheckBox ( text ) ; bean . addPropertyChangeListener ( property , new PropertyChangeListener ( ) { @ Override public void propertyChange ( PropertyChangeEvent evt ) { checkbox . setSelected ( ( boolean ) evt . getNewValue ( ) ) ; } } ) ; checkbox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { ReflectionUtils . setValue ( bean , property , checkbox . isSelected ( ) ) ; } } ) ; return checkbox ; } \n', 0.3811776042016062)

('private void levelAbsoluteCheckboxActionPerformed ( java . awt . event . ActionEvent evt ) { updateLevelToolParams ( ) ; levelAbsoluteHeightField . setEnabled ( levelAbsoluteCheckbox . isEnabled ( ) ) ; } \n', 0.3701771759279804)

('private Button createCheckButton ( Composite parent , String text , String property ) { final Button button = new Button ( parent , SWT . CHECK ) ; GridData groupGridData = new GridData ( GridData . FILL_HORIZONTAL ) ; groupGridData . horizontalSpan = 3 ; button . setLayoutData ( groupGridData ) ; button . setText ( text ) ; button . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent e ) { boolean isChecked = button . getSelection ( ) ; if ( tableNameText != null ) { tableNameText . setEnabled ( ! isChecked ) ; } } } ) ; synchHelper . synchCheckbox ( button , property , null ) ; return button ; } \n', 0.36840381854572657)

('public Checkbox ( String label , CheckboxGroup group , boolean state ) throws HeadlessException { this ( label , state , group ) ; } \n', 0.36825350151874675)

('public void registerControlCheckbox ( final JCheckBox controlCheckBox ) throws Exception { if ( registeredAlready ) { throw new IllegalStateException ( "Error-when-registering-" + controlCheckBox + "-for-" + this + ".-Already-registered." ) ; } this . addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { controlCheckBox . setSelected ( false ) ; } } ) ; this . controlCheckBox = controlCheckBox ; controlCheckBox . addActionListener ( this ) ; } \n', 0.3676160133525304)

('private Button createTableNameCheckButton ( Composite parent , String text , String property ) { final Button button = new Button ( parent , SWT . CHECK ) ; GridData groupGridData = new GridData ( GridData . FILL_HORIZONTAL ) ; groupGridData . horizontalSpan = 3 ; button . setLayoutData ( groupGridData ) ; button . setText ( text ) ; button . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent e ) { boolean isChecked = button . getSelection ( ) ; if ( tableNameText != null ) { tableNameText . setEnabled ( ! isChecked ) ; } } } ) ; synchHelper . synchCheckbox ( button , property , null ) ; return button ; } \n', 0.3673758646090689)

('private void onInvocationControlEnabledCheckboxSelected ( ) { final Button checkbox = invocationControlEnabledCheckbox ; for ( Control c : checkbox . getParent ( ) . getChildren ( ) ) { if ( ! c . equals ( invocationControlEnabledCheckbox ) ) { c . setEnabled ( isInvocationControlEnabled ( ) ) ; } } } \n', 0.3646079035798141)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 7 #################################
('public static < T extends Comparable < ? super T > > int [ ] sort ( T [ ] arr ) { int [ ] order = new int [ arr . length ] ; for ( int i = 0 ; i < order . length ; i ++ ) { order [ i ] = i ; } sort ( arr , order ) ; return order ; }\n', 0.4509236000661915)

('public Builder sortOrder ( Comparator < Release > value ) { this . sortOrder = Objects . requireNonNull ( value ) ; return this ; } \n', 0.44750857622652496)

('public static int [ ] sortOrder ( double [ ] values ) { SortOrder [ ] array = new SortOrder [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { array [ i ] = new SortOrder < Double > ( values [ i ] , i ) ; } Collections . shuffle ( Arrays . asList ( array ) , getRandomGenerator ( ) ) ; Arrays . sort ( array ) ; int [ ] order = new int [ values . length ] ; for ( int i = 0 ; i < order . length ; i ++ ) { order [ i ] = array [ i ] . getIndex ( ) ; } return order ; } \n', 0.4355141284507751)

('public static int [ ] sort ( double [ ] arr ) { int [ ] order = new int [ arr . length ] ; for ( int i = 0 ; i < order . length ; i ++ ) { order [ i ] = i ; } sort ( arr , order ) ; return order ; }\n', 0.43289642033415104)

('public java . lang . Integer getSortOrder ( ) { return sortOrder == null ? Integer . valueOf ( 0 ) : sortOrder ; } \n', 0.4267682882276318)

('public int getSortOrderAsNumber ( ) { return sortOrder . equals ( SortOrder . ASC ) ? 1 : - 1 ; } \n', 0.4266663709629463)

('public static int [ ] sortOrder ( int [ ] values ) { SortOrder [ ] array = new SortOrder [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { array [ i ] = new SortOrder < Integer > ( values [ i ] , i ) ; } Collections . shuffle ( Arrays . asList ( array ) , getRandomGenerator ( ) ) ; Arrays . sort ( array ) ; int [ ] order = new int [ values . length ] ; for ( int i = 0 ; i < order . length ; i ++ ) { order [ i ] = array [ i ] . getIndex ( ) ; } return order ; } \n', 0.42600939803346727)

('public DescribeMLModelsRequest withSortOrder ( SortOrder sortOrder ) { this . sortOrder = sortOrder . toString ( ) ; return this ; } \n', 0.4247552040432865)

('public DescribeDataSourcesRequest withSortOrder ( SortOrder sortOrder ) { this . sortOrder = sortOrder . toString ( ) ; return this ; } \n', 0.4247552040432865)

('public DescribeBatchPredictionsRequest withSortOrder ( SortOrder sortOrder ) { this . sortOrder = sortOrder . toString ( ) ; return this ; } \n', 0.4247552040432865)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 8 #################################
('public static String formatDate ( Date date , String format ) { if ( date == null ) return "" ; else { DateFormatter dateFormatter = new DateFormatter ( ) ; dateFormatter . setFormat ( format ) ; dateFormatter . setDate ( date ) ; return dateFormatter . getFormattedDate ( ) ; } } \n', 0.4164182879557735)

('private String formatDate ( long date ) { DateFormat dateFormat = new SimpleDateFormat ( DATE_FORMATS [ 0 ] , Locale . US ) ; dateFormat . setTimeZone ( GMT ) ; return dateFormat . format ( new Date ( date ) ) ; } \n', 0.4141397734516934)

('public static String formatDate ( Date date , String pattern ) { if ( date == null ) throw new IllegalArgumentException ( "date-is-null" ) ; if ( pattern == null ) throw new IllegalArgumentException ( "pattern-is-null" ) ; SimpleDateFormat formatter = new SimpleDateFormat ( pattern , Locale . US ) ; formatter . setTimeZone ( GMT ) ; return formatter . format ( date ) ; } \n', 0.41351179011415085)

('public static String formatDate ( String dateFormat , String date , String toFormat , Locale fromLocale , Locale toLocale ) { String formatted = "" ; DateFormat formatter = fromLocale == null ? new SimpleDateFormat ( dateFormat ) : new SimpleDateFormat ( dateFormat , Locale . getDefault ( ) ) ; try { Date dateStr = formatter . parse ( date ) ; formatted = formatter . format ( dateStr ) ; Date formatDate = formatter . parse ( formatted ) ; formatter = toLocale == null ? new SimpleDateFormat ( toFormat , Locale . getDefault ( ) ) : new SimpleDateFormat ( toFormat , toLocale ) ; formatted = formatter . format ( formatDate ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return formatted ; } \n', 0.41215517468244756)

('public static String formatDateRfc822 ( Date date ) { if ( date != null ) { SimpleDateFormat dateFormater = new SimpleDateFormat ( "EEE,-dd-MMM-yyyy-HH:mm:ss-\'GMT\'" , Locale . US ) ; dateFormater . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; return dateFormater . format ( date ) ; } return null ; } \n', 0.4116746841045593)

('private static String formatDateText ( final Date dt ) { final DateFormat df = DateFormat . getDateInstance ( DateFormat . LONG ) ; final StringBuffer mm = new StringBuffer ( ) ; final StringBuffer yy = new StringBuffer ( ) ; final FieldPosition mmfp = new FieldPosition ( DateFormat . MONTH_FIELD ) ; final FieldPosition yyfp = new FieldPosition ( DateFormat . YEAR_FIELD ) ; df . format ( dt , mm , mmfp ) ; df . format ( dt , yy , yyfp ) ; return ( mm . toString ( ) . substring ( mmfp . getBeginIndex ( ) , mmfp . getEndIndex ( ) ) + "-" + yy . toString ( ) . substring ( yyfp . getBeginIndex ( ) , yyfp . getEndIndex ( ) ) ) ; } \n', 0.4106303110983879)

('public static int toSynergyFormat ( Date date , TimeQualifier qualifier ) { DateFormat dateFormat = new SimpleDateFormat ( qualifier . getPattern ( ) ) ; dateFormat . setTimeZone ( TimeZone . getTimeZone ( "UTC" ) ) ; String formatted = dateFormat . format ( date ) ; return Integer . valueOf ( formatted ) ; } \n', 0.4104969762906862)

('public String formatDate ( java . util . Date date , String pattern , Locale locale ) { try { if ( locale == null ) { return new SimpleDateFormat ( pattern ) . format ( date ) ; } else { return new SimpleDateFormat ( pattern , locale ) . format ( date ) ; } } catch ( Exception e ) { return date == null ? null : date . toString ( ) ; } } \n', 0.41012467804588026)

('public static String formatDate ( java . util . Date date , String formatPattern ) { if ( date == null ) { return "" ; } java . text . SimpleDateFormat formatter = new java . text . SimpleDateFormat ( formatPattern , new java . util . Locale ( "en" , "US" ) ) ; return ( formatter . format ( date ) ) ; } \n', 0.40878257101586546)

('private String formatDate ( String format ) { return new SimpleDateFormat ( format ) . format ( new Date ( ) ) ; } \n', 0.40853636508423585)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 9 #################################
('public static Date currentDate ( ) { return instance . currentClockDate ( ) ; } \n', 0.38097598357095946)

('public String getCurrentDate ( ) { return this . getCurrentDate ( SHORT_FORMAT ) ; } \n', 0.37570775791795535)

('public static String getCurrentDate ( int nDelta ) throws RemoteException { java . util . Date currentDate = new java . util . Date ( ) ; currentDate . setDate ( currentDate . getDate ( ) + nDelta ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( "MM/dd/yy" ) ; String dateString = dateFormat . format ( currentDate ) ; return dateString ; } \n', 0.3712414400539603)

('public String getCurrentDate ( ) throws TaskFailedException { return new SimpleDateFormat ( "dd/MM/yyyy" ) . format ( new Date ( ) ) ; } \n', 0.3683584257158175)

('public final static String getCurrentDate ( ) { return DateTime . getCurrentDateTimeWithFormat ( "MMM-dd,-yyyy" ) ; } \n', 0.368079131797291)

('public String getCurrentDueDate ( ) { return new SimpleDateFormat ( DATE_FORMAT ) . format ( currentTodo . getDueDate ( ) ) ; } \n', 0.3675091174817768)

('@ Override public LocalDateTime getCurrentDateTime ( ) { LocalDateTime currentTime = LocalDateTime . now ( ) ; LOGGER . debug ( "Returning-current-datetime:-{}" , currentTime ) ; return currentTime ; } \n', 0.3662182816286441)

('public static Date getCurrentDate ( ) throws Exception { return new GregorianCalendar ( enLocale ) . getTime ( ) ; } \n', 0.3661878203261305)

('private static Long getCurrentTime ( ) { Date currentDate = new Date ( ) ; currentDate . getDate ( ) ; Calendar calDateCurrent = Calendar . getInstance ( ) ; calDateCurrent . setTime ( currentDate ) ; return calDateCurrent . getTimeInMillis ( ) ; } \n', 0.3660863316109341)

('public static java . util . Date getCurrentDate ( ) { java . util . Date currentDate = new java . util . Date ( ) ; return currentDate ; } \n', 0.36598253111781465)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 10 #################################
('private static ContentItem [ ] pickRandomDocs ( ContentItem [ ] newsItems , double percentOfDocs ) { if ( percentOfDocs < 0.0 || percentOfDocs > 1.0 ) { throw new IllegalArgumentException ( "Value-for-\'percentOfDocs\'-argument-should-be-" + "between-0-and-1." ) ; } Random rand = new Random ( ) ; int sampleSize = ( int ) Math . round ( percentOfDocs * newsItems . length ) ; Map < Integer , Item > pickedItems = new HashMap < Integer , Item > ( ) ; while ( pickedItems . size ( ) < sampleSize ) { int itemId = rand . nextInt ( newsItems . length ) ; Item item = newsItems [ itemId ] ; if ( ! pickedItems . containsKey ( item . getId ( ) ) ) { pickedItems . put ( item . getId ( ) , item ) ; } } return pickedItems . values ( ) . toArray ( new ContentItem [ pickedItems . size ( ) ] ) ; } \n', 0.41178510249070166)

('File pickRandomWritableDir ( File excludedDir ) throws NoWritableLedgerDirException { List < File > writableDirs = getWritableLedgerDirs ( ) ; final int start = rand . nextInt ( writableDirs . size ( ) ) ; int idx = start ; File candidate = writableDirs . get ( idx ) ; while ( null != excludedDir && excludedDir . equals ( candidate ) ) { idx = ( idx + 1 ) % writableDirs . size ( ) ; if ( idx == start ) { throw new NoWritableLedgerDirException ( "No-writable-directories-found-from-" + "-available-writable-dirs-(" + writableDirs + ")-:-exclude-dir-" + excludedDir ) ; } candidate = writableDirs . get ( idx ) ; } return candidate ; } \n', 0.40499171167040976)

('private ArrayList < Integer > getRandomNumbers ( int k , int maxRandomNumber ) { Random randomGen = new Random ( ) ; ArrayList < Integer > randomNumbers = new ArrayList < Integer > ( k ) ; for ( int i = 0 ; i < k ; i ++ ) { int randTemp = randomGen . nextInt ( maxRandomNumber ) ; while ( randomNumbers . contains ( randTemp ) ) randTemp = randomGen . nextInt ( maxRandomNumber ) ; randomNumbers . add ( randTemp ) ; } return randomNumbers ; } \n', 0.4032158523620074)

('public void sayPickItUp ( String name ) { Random rand = new Random ( ) ; int i = Math . abs ( rand . nextInt ( ) % playerPickItUpPrompt . length ) ; speak ( playerPickItUpPrompt [ i ] . replace ( "%s" , name ) ) ; } \n', 0.39858776606906665)

('private static MusicItem [ ] pickRandomSongs ( MusicItem [ ] songs , double percentOfAllSongs ) { if ( percentOfAllSongs < 0.0 || percentOfAllSongs > 1.0 ) { throw new IllegalArgumentException ( "Value-for-\'percentOfAllSongs\'-argument-should-be-between-0-and-1." ) ; } Random rand = new Random ( ) ; int sampleSize = ( int ) Math . round ( percentOfAllSongs * songs . length ) ; Map < Integer , MusicItem > pickedItems = new HashMap < Integer , MusicItem > ( ) ; while ( pickedItems . size ( ) < sampleSize ) { int songId = rand . nextInt ( songs . length ) ; MusicItem song = songs [ songId ] ; if ( ! pickedItems . containsKey ( song . getId ( ) ) ) { pickedItems . put ( song . getId ( ) , song ) ; } } return pickedItems . values ( ) . toArray ( new MusicItem [ pickedItems . size ( ) ] ) ; } \n', 0.39796246170242094)

('public static int pickOneRandomly ( int first , int second ) { boolean pickFirst = random . nextBoolean ( ) ; if ( pickFirst ) { return first ; } else { return second ; } } \n', 0.393935880565887)

('@ Override public Piece pickNextPiece ( ) { boolean random = ( adversary . getValue ( ) < gen . nextInt ( adversary . getMaximum ( ) ) ) ; if ( random ) { return super . pickNextPiece ( ) ; } else { double max = - 1 ; Piece worst = new Piece ( "" ) ; for ( Piece p : pieces ) { Brain . Move m = brain . bestMove ( board , p , HEIGHT , null ) ; double value = ( m != null ) ? m . score : Integer . MAX_VALUE ; if ( value > max ) { max = value ; worst = p ; } } return worst ; } } \n', 0.3938289779554956)

('public static List < City > pickCities ( int numberOfDestinations ) { List < City > all = read . getCities ( ) ; List < City > chosen = new ArrayList < City > ( ) ; chosen . add ( all . get ( 0 ) ) ; List < Integer > numbers = new ArrayList < Integer > ( ) ; while ( numbers . size ( ) < numberOfDestinations ) { int index = random . nextInt ( all . size ( ) ) ; if ( ! numbers . contains ( index ) && index != 0 ) { numbers . add ( index ) ; chosen . add ( all . get ( index ) ) ; } } return chosen ; } \n', 0.39280226897920734)

('private < T > T pickRandomlyFromList ( final List < T > list ) { return list . get ( random . nextInt ( list . size ( ) ) ) ; } \n', 0.3927845453226804)

('public static int [ ] pickRandomly ( int [ ] arr , int m ) { int [ ] copy = Arrays . copyOfRange ( arr , 0 , arr . length ) , retval = new int [ m ] ; Random rand = new Random ( ) ; int index = arr . length , random ; for ( int i = 0 ; i < m ; ++ i ) { random = rand . nextInt ( index ) ; retval [ i ] = copy [ random ] ; copy [ random ] = copy [ index - 1 ] ; -- index ; } for ( int i : retval ) System . out . print ( i + "-" ) ; System . out . println ( ) ; return retval ; } \n', 0.3899142287810091)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 11 #################################
('@ Override void deserialize ( final Map < String , Object > source ) { super . deserialize ( source ) ; if ( source . containsKey ( JsonSchema . KEY_DATE_PATTERN ) ) { this . datePattern = ( String ) source . get ( JsonSchema . KEY_DATE_PATTERN ) ; } } \n', 0.4187842304303746)

('@ Override public Entry deserialize ( @ Nullable byte [ ] bytes ) { if ( bytes == null ) { return null ; } return GSON . get ( ) . fromJson ( new String ( bytes ) , Entry . class ) ; } \n', 0.4106041816504033)

('@ SuppressWarnings ( "unchecked" ) @ Override public TS deserialize ( final byte [ ] data ) throws SerializationException { ArrayList < TS > info = null ; if ( data != null ) { final String jsonData = new String ( data ) ; try { info = objectMapper . readValue ( jsonData , ArrayList . class ) ; } catch ( final Exception e ) { throw new SerializationException ( "Error-occured-while-deserializing-data-" + jsonData , e ) ; } } return ( info != null && info . size ( ) > 0 ) ? info . get ( 0 ) : null ; } \n', 0.40244103573914625)

('@ Override public Object deserialize ( byte [ ] b ) { try { return Utils . from_json ( new String ( b , "UTF-8" ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } \n', 0.4002365232842615)

('@ Override public List < Object > deserialize ( byte [ ] bytes ) { final String chars ; try { chars = new String ( bytes , encoding ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( e ) ; } final Object json ; try { json = JSONValue . parseWithException ( chars ) ; } catch ( ParseException e ) { throw new IllegalArgumentException ( e ) ; } return Collections . singletonList ( json ) ; } \n', 0.39898744797386027)

('public Character deserialize ( ObjectReader reader , Context ctx ) { String str = reader . valueAsString ( ) ; if ( str . length ( ) > 1 ) throw new JsonBindingException ( "Could-not-convert-a-string-with-length-greater-than-1-to-a-single-char." ) ; return str . charAt ( 0 ) ; } \n', 0.39716763581588516)

('public static < T > T deserialize ( byte [ ] input , Class < T > classType ) throws JsonParseException , JsonMappingException , IOException { return mapper . readValue ( input , classType ) ; }\n', 0.3966552197758171)

('public T deserialize ( byte [ ] array ) throws Exception { String str = new String ( array , _charset . toString ( ) ) ; return _marshaller . unmarshall ( ( Json . Object ) Json . read ( new StringReader ( str ) ) ) ; } \n', 0.39277812821663327)

('@ Override public byte [ ] deserialize ( JsonElement json , Type typeOfT , JsonDeserializationContext context ) throws JsonParseException { if ( typeOfT . equals ( byte [ ] . class ) ) throw new JsonParseException ( "Not-a-byte[]:-" + typeOfT ) ; String input = json . getAsString ( ) ; baos . reset ( ) ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { char chr = input . charAt ( i ) ; if ( chr != \'%\' ) { baos . write ( chr ) ; } else { baos . write ( ( hexValue ( input . charAt ( ++ i ) ) << 4 ) | hexValue ( input . charAt ( ++ i ) ) ) ; } } return baos . toByteArray ( ) ; } \n', 0.39091846034350836)

('public static < T > T deserializeFromJSON ( String json , Class < T > as , HashMap < String , Object > typeMap ) { if ( json . length ( ) == 0 ) return null ; return deserializeFromJSON ( new QTokenizer ( json ) , as , typeMap ) ; } \n', 0.39054874792737787)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 12 #################################
('public static void copyToClipboard ( final String text ) { StringSelection selection = new StringSelection ( text == null ? "" : text ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; if ( clipboard != null ) { clipboard . setContents ( selection , selection ) ; } else { BeamLogManager . getSystemLogger ( ) . severe ( "failed-to-obtain-clipboard-instance" ) ; } } \n', 0.47947588439425187)

('public static void copyToClipboard ( final String text ) { final StringSelection selection = new StringSelection ( text == null ? "" : text ) ; final Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; if ( clipboard != null ) { clipboard . setContents ( selection , selection ) ; } else { BeamLogManager . getSystemLogger ( ) . severe ( "failed-to-obtain-clipboard-instance" ) ; } } \n', 0.47947588439425187)

('public static void copyToClipboard ( String str ) { Toolkit kit = Toolkit . getDefaultToolkit ( ) ; Clipboard clipboard = kit . getSystemClipboard ( ) ; StringSelection ss = new StringSelection ( str ) ; clipboard . setContents ( ss , ss ) ; } \n', 0.4761093645389748)

('static void copyToClipboard ( String textToCopy ) { StringSelection stringSelection = new StringSelection ( textToCopy ) ; Clipboard clpbrd = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clpbrd . setContents ( stringSelection , null ) ; } \n', 0.4730787630694193)

('protected void copyToClipboard ( ) { if ( _clipboard != null ) { _clipboard . dispose ( ) ; } String stackTrace = stackTraceToString ( _status . getException ( ) ) ; _clipboard = new Clipboard ( _list . getDisplay ( ) ) ; _clipboard . setContents ( new Object [ ] { stackTrace } , new Transfer [ ] { TextTransfer . getInstance ( ) } ) ; } \n', 0.469547078319246)

('public static void copyToClipboard ( final String text ) { try { final Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipboard . setContents ( new StringSelection ( text ) , null ) ; } catch ( final Throwable e ) { Log . error ( SystemUtils . class , e ) ; } } \n', 0.4694453049938584)

('private void copyToClipboard ( ) { if ( clipboard != null ) clipboard . dispose ( ) ; StringBuffer statusBuffer = new StringBuffer ( ) ; populateCopyBuffer ( status , statusBuffer , 0 ) ; clipboard = new Clipboard ( list . getDisplay ( ) ) ; clipboard . setContents ( new Object [ ] { statusBuffer . toString ( ) } , new Transfer [ ] { TextTransfer . getInstance ( ) } ) ; } \n', 0.4676704178452773)

('private static void copyToClipboard ( AuxiliaryElementSelection selection , Clipboard clipboard ) throws ActionExecutionException { try { clipboard = clipboard == null ? Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) : clipboard ; clipboard . setContents ( selection , null ) ; } catch ( Throwable t ) { throw new ActionExecutionException ( "Error-occurs-while-performing-the-copy-operation!" , t ) ; } } \n', 0.46632412747847496)

('private void copyToClipboard ( ) { if ( clipboard != null ) { clipboard . dispose ( ) ; } StringBuffer statusBuffer = new StringBuffer ( ) ; populateCopyBuffer ( status , statusBuffer , 0 ) ; clipboard = new Clipboard ( list . getDisplay ( ) ) ; clipboard . setContents ( new Object [ ] { statusBuffer . toString ( ) } , new Transfer [ ] { TextTransfer . getInstance ( ) } ) ; } \n', 0.4654998457034473)

('protected void copyToClipboard ( String text ) { Clipboard clipboard = null ; try { clipboard = new Clipboard ( Display . getCurrent ( ) ) ; clipboard . setContents ( new Object [ ] { text } , new Transfer [ ] { TextTransfer . getInstance ( ) } ) ; } finally { if ( clipboard != null ) clipboard . dispose ( ) ; } } \n', 0.46534073895535744)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 13 #################################
('private static ArrayList < ArrayList < Integer >> transposeMatrix ( ArrayList < ArrayList < Integer >> matrix ) { int numRows = matrix . size ( ) ; int numCols = matrix . get ( 0 ) . size ( ) ; ArrayList < ArrayList < Integer >> newMat = new ArrayList < ArrayList < Integer >> ( ) ; for ( int i = 0 ; i < numCols ; i ++ ) newMat . add ( new ArrayList < Integer > ( ) ) ; for ( int i = 0 ; i < numRows ; i ++ ) { for ( int j = 0 ; j < numCols ; j ++ ) { newMat . get ( j ) . add ( matrix . get ( i ) . get ( j ) ) ; } } return newMat ; } \n', 0.3932453567335805)

('public static Vector3d matrixToEuler ( Matrix3d matrix , Vector3d vector ) { final double sinb = - matrix . m20 ; final double y = Math . asin ( sinb ) ; final double cosb = Math . cos ( y ) ; final double sina = matrix . m21 / cosb ; final double sinc = matrix . m10 / cosb ; double x = Math . asin ( sina ) ; double z = Math . asin ( sinc ) ; final double cosa = matrix . m22 / cosb ; final double cosc = matrix . m00 / cosb ; if ( cosa < 0 ) x = Math . PI - x ; if ( cosc < 0 ) z = Math . PI - z ; if ( vector == null ) vector = new Vector3d ( x , y , z ) ; else vector . set ( x , y , z ) ; return vector ; } \n', 0.3812537012657374)

('public static RealMatrix divideMatrixByNumber ( RealMatrix matrix , double divisionNumber ) { for ( int i = 0 ; i < matrix . getRowDimension ( ) ; i ++ ) { for ( int j = 0 ; j < matrix . getColumnDimension ( ) ; j ++ ) { matrix . multiplyEntry ( i , j , 1 / divisionNumber ) ; } } return matrix ; } \n', 0.3762124377248103)

('public static < T > Matrix < T > matrix ( int size , List < T > values ) { if ( values == null || values . size ( ) != size * size || values . contains ( null ) ) return NaM ( ) ; return immutableMatrix ( size , values ) ; } \n', 0.3733395879958228)

('private RealMatrix formAlgebraicMatrix ( RealVector v ) { RealMatrix a = new Array2DRowRealMatrix ( 4 , 4 ) ; a . setEntry ( 0 , 0 , v . getEntry ( 0 ) ) ; a . setEntry ( 0 , 1 , v . getEntry ( 3 ) ) ; a . setEntry ( 0 , 2 , v . getEntry ( 4 ) ) ; a . setEntry ( 0 , 3 , v . getEntry ( 6 ) ) ; a . setEntry ( 1 , 0 , v . getEntry ( 3 ) ) ; a . setEntry ( 1 , 1 , v . getEntry ( 1 ) ) ; a . setEntry ( 1 , 2 , v . getEntry ( 5 ) ) ; a . setEntry ( 1 , 3 , v . getEntry ( 7 ) ) ; a . setEntry ( 2 , 0 , v . getEntry ( 4 ) ) ; a . setEntry ( 2 , 1 , v . getEntry ( 5 ) ) ; a . setEntry ( 2 , 2 , v . getEntry ( 2 ) ) ; a . setEntry ( 2 , 3 , v . getEntry ( 8 ) ) ; a . setEntry ( 3 , 0 , v . getEntry ( 6 ) ) ; a . setEntry ( 3 , 1 , v . getEntry ( 7 ) ) ; a . setEntry ( 3 , 2 , v . getEntry ( 8 ) ) ; a . setEntry ( 3 , 3 , - 1 ) ; return a ; } \n', 0.36729404610081867)

('public static < T extends FieldElement < T >> FieldMatrix < T > asFieldMatrix ( Array < T > array ) { Check . argument ( array . isMatrix ( ) , CAN_ONLY_VIEW_2D_ARRAYS ) ; return new AbstractFieldMatrix < T > ( ) { @ Override public FieldMatrix < T > createMatrix ( int rowDimension , int columnDimension ) throws NotStrictlyPositiveException { return asFieldMatrix ( array . newEmptyArray ( rowDimension , columnDimension ) ) ; } @ Override public FieldMatrix < T > copy ( ) { return asFieldMatrix ( array . copy ( ) ) ; } @ Override public T getEntry ( int row , int column ) throws OutOfRangeException { return array . get ( row , column ) ; } @ Override public void setEntry ( int row , int column , T value ) throws OutOfRangeException { array . set ( row , column , value ) ; } @ Override public void addToEntry ( int row , int column , T increment ) throws OutOfRangeException { array . set ( row , column , array . get ( row , column ) . add ( increment ) ) ; } @ Override public void multiplyEntry ( int row , int column , T factor ) throws OutOfRangeException { array . set ( row , column , array . get ( row , column ) . multiply ( factor ) ) ; } @ Override public int getRowDimension ( ) { return array . rows ( ) ; } @ Override public int getColumnDimension ( ) { return array . columns ( ) ; } } ; } \n', 0.3660563073558313)

('public static String calROCMatrix ( String label , ArrayList < HashMap < String , StatusCount >> statusCountList ) { StringBuilder matrix = new StringBuilder ( ) ; matrix . append ( "min_bootstrap_words-" + label + "-" ) ; matrix . append ( "bootstrap" ) ; HashMap < String , StatusCount > statusCountMap = statusCountList . get ( 0 ) ; for ( String rank : statusCountMap . keySet ( ) ) { if ( rank . startsWith ( "sub" ) ) continue ; matrix . append ( "-" + rank + "_FPR" + "-" + rank + "_TPR" + "-" + rank + "_F1score" ) ; } matrix . append ( "-" ) ; for ( int b = 0 ; b < statusCountList . size ( ) ; b ++ ) { matrix . append ( b ) ; statusCountMap = statusCountList . get ( b ) ; for ( String rank : statusCountMap . keySet ( ) ) { if ( rank . startsWith ( "sub" ) ) continue ; StatusCount st = statusCountMap . get ( rank ) ; matrix . append ( "-" + st . calFPR ( ) + "-" + st . calSensitivity ( ) + "-" + st . calF1score ( ) ) ; } matrix . append ( "-" ) ; } return matrix . toString ( ) ; } \n', 0.3653580593210932)

('public static final Matrix matrixFromEuler ( double heading , double attitude , double bank ) { double ch = Math . cos ( heading ) ; double sh = Math . sin ( heading ) ; double ca = Math . cos ( attitude ) ; double sa = Math . sin ( attitude ) ; double cb = Math . cos ( bank ) ; double sb = Math . sin ( bank ) ; Matrix m = new Matrix ( 3 , 3 ) ; m . set ( 0 , 0 , ch * ca ) ; m . set ( 0 , 1 , sh * sb - ch * sa * cb ) ; m . set ( 0 , 2 , ch * sa * sb + sh * cb ) ; m . set ( 1 , 0 , sa ) ; m . set ( 1 , 1 , ca * cb ) ; m . set ( 1 , 2 , - ca * sb ) ; m . set ( 2 , 0 , - sh * ca ) ; m . set ( 2 , 1 , sh * sa * cb + ch * sb ) ; m . set ( 2 , 2 , - sh * sa * sb + ch * cb ) ; return m ; } \n', 0.36384201498016566)

('public void projMatrix ( float [ ] matrix ) { Utils . perspectiveM ( matrix , 0 , 45 , aspect , near , far ) ; } \n', 0.36368751219539125)

('public static RealMatrix toRotationMatrix ( List < Double > angles ) { double dimDouble = ( 1.0 + sqrt ( 1.0 + 8.0 * angles . size ( ) ) ) / 2.0 ; int dim = ( int ) Math . floor ( dimDouble ) ; RealMatrix left , right ; left = MatrixTools . identity ( dim ) ; right = new Array2DRowRealMatrix ( dim , dim ) ; int k = 0 ; for ( int j = dim - 2 ; j >= 0 ; j -- ) for ( int i = j + 1 ; i < dim ; i ++ ) { right = elementary ( dim , i , j , angles . get ( k ) ) ; left = left . multiply ( right ) ; k ++ ; } return left ; } \n', 0.3630953094491747)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 14 #################################
('public static void sortStrings ( String [ ] strings ) { sortStrings ( strings , 0 , strings . length - 1 ) ; } \n', 0.44744101926833524)

('private void sortStringList ( List < String > strings ) { Collections . sort ( strings , String . CASE_INSENSITIVE_ORDER ) ; } \n', 0.44136169867191)

('private String [ ] sort ( Comparator < String > c ) { String [ ] strs = strings . clone ( ) ; Arrays . sort ( strs , c ) ; return strs ; } \n', 0.4406988009438045)

('private void checkStringSortCorrect ( List < RowMetaAndData > list , boolean caseSensitive , boolean asc ) throws KettleValueException { List < String > actual = new ArrayList < String > ( ) ; List < String > expected = new ArrayList < String > ( ) ; String caseSen = caseSensitive ? "case-sensitive" : "case-unsensitive" ; for ( RowMetaAndData row : list ) { String value = row . getString ( STR , null ) ; if ( ! caseSensitive ) { expected . add ( value . toLowerCase ( ) ) ; actual . add ( value . toLowerCase ( ) ) ; } else { expected . add ( value ) ; actual . add ( value ) ; } } if ( asc ) { Collections . sort ( expected ) ; } else { Collections . sort ( expected ) ; Collections . reverse ( expected ) ; } Assert . assertEquals ( "Data-is-sorted:-" + caseSen , expected , actual ) ; } \n', 0.43284447819230065)

('public static void sortStrings ( Vector values , int left , int right , Swapper swapper ) { int oleft = left ; int oright = right ; String mid = ( String ) values . elementAt ( ( left + right ) / 2 ) ; do { while ( ( ( String ) ( values . elementAt ( left ) ) ) . compareTo ( mid ) < 0 ) left ++ ; while ( mid . compareTo ( ( String ) ( values . elementAt ( right ) ) ) < 0 ) right -- ; if ( left <= right ) { swapper . swap ( values , left , right ) ; left ++ ; right -- ; } } while ( left <= right ) ; if ( oleft < right ) sortStrings ( values , oleft , right , swapper ) ; if ( left < oright ) sortStrings ( values , left , oright , swapper ) ; } \n', 0.43210132381437816)

('private String [ ] sortStrings ( String [ ] sin ) { Collator defaultCollator = Collator . getInstance ( ) ; String tmp ; for ( int i = 0 ; i < sin . length ; i ++ ) { for ( int j = i + 1 ; j < sin . length ; j ++ ) { if ( defaultCollator . compare ( sin [ i ] , sin [ j ] ) > 0 ) { tmp = sin [ i ] ; sin [ i ] = sin [ j ] ; sin [ j ] = tmp ; } } } return sin ; } \n', 0.4301190528719425)

('public String [ ] sortStringsByLenght ( String ... sourceStrings ) { List < String > listString = new ArrayList < String > ( ) ; for ( String str : sourceStrings ) { listString . add ( str ) ; } Collections . sort ( listString , new Comparator < String > ( ) { @ Override public int compare ( String a , String b ) { return a . length ( ) - b . length ( ) ; } } ) ; return listString . toArray ( new String [ 0 ] ) ; } \n', 0.4295064373509713)

('public static String [ ] sortStringArray ( String [ ] array ) { if ( Objects . isEmpty ( array ) ) { return new String [ 0 ] ; } Arrays . sort ( array ) ; return array ; } \n', 0.4265263102921439)

('private void sortStringList ( List < String > list ) { Collections . sort ( list , new Comparator < String > ( ) { @ Override public int compare ( String lhs , String rhs ) { return lhs . compareToIgnoreCase ( rhs ) ; } } ) ; } \n', 0.42400150021115346)

('private static void sortSmileyStrings ( ) { sortedSmileyStrings = new String [ smileyToSmileyCode . keySet ( ) . size ( ) ] ; sortedSmileyStrings = smileyToSmileyCode . keySet ( ) . toArray ( sortedSmileyStrings ) ; Arrays . sort ( sortedSmileyStrings , new Comparator < String > ( ) { @ Override public int compare ( String arg0 , String arg1 ) { return arg1 . length ( ) - arg0 . length ( ) ; } } ) ; } \n', 0.4231065040616748)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 15 #################################
("public static String convertDecimalStringToHexString ( String in ) { int integer = Integer . parseInt ( in ) ; String hexString = Integer . toHexString ( integer ) ; if ( hexString . length ( ) == 1 ) { hexString = '0' + hexString ; } return hexString ; } \n", 0.4253949201254642)

('public static BigDecimal convertToBigDecimal ( byte [ ] bytes ) { BigDecimal retVal = null ; try { retVal = new BigDecimal ( new String ( bytes , "UTF-8" ) ) ; } catch ( Exception exp ) { retVal = null ; } return retVal ; } \n', 0.399204598559953)

("public static long hexStringToLong ( String s ) throws NumberFormatException { if ( s == null || s . length ( ) < 2 ) { throw new NumberFormatException ( s ) ; } char firstChar = s . charAt ( 0 ) ; if ( firstChar >= '0' && firstChar <= '7' ) { return Long . parseLong ( s , 16 ) ; } else { java . math . BigInteger big = new java . math . BigInteger ( s , 16 ) ; return big . longValue ( ) ; } } \n", 0.39713434465990016)

('public static String doubleToHexString ( double val ) { long reversed = Long . reverseBytes ( Double . doubleToLongBits ( val ) ) ; String res = Long . toHexString ( reversed ) ; res = "0000000000000000" . substring ( res . length ( ) ) + res ; return res ; } \n', 0.39177754522931646)

('public static long hexStringToLong ( String s ) throws NumberFormatException { boolean isNeg ; String toUse = s ; if ( s . startsWith ( Utility . hexStart ) ) toUse = s . substring ( Utility . hexStart . length ( ) ) ; String lastString = toUse . substring ( toUse . length ( ) - 1 ) ; if ( toUse . substring ( 0 , 1 ) . equals ( "-" ) ) { toUse = "-0" + toUse . substring ( 1 , toUse . length ( ) - 1 ) ; isNeg = true ; } else { toUse = "0" + toUse . substring ( 0 , toUse . length ( ) - 1 ) ; isNeg = false ; } Long i = Long . valueOf ( toUse , 16 ) ; long val = i . longValue ( ) ; val = val << 4 ; if ( isNeg ) { val -= Long . valueOf ( lastString , 16 ) . longValue ( ) ; } else { val += Long . valueOf ( lastString , 16 ) . longValue ( ) ; } return val ; } \n', 0.39075071833812264)

('public static String toHexString ( double d ) { if ( isNaN ( d ) ) return "NaN" ; if ( isInfinite ( d ) ) return d < 0 ? "-Infinity" : "Infinity" ; long bits = doubleToLongBits ( d ) ; CPStringBuilder result = new CPStringBuilder ( ) ; if ( bits < 0 ) result . append ( \'-\' ) ; result . append ( "0x" ) ; final int mantissaBits = 52 ; final int exponentBits = 11 ; long mantMask = ( 1L << mantissaBits ) - 1 ; long mantissa = bits & mantMask ; long expMask = ( 1L << exponentBits ) - 1 ; long exponent = ( bits >>> mantissaBits ) & expMask ; result . append ( exponent == 0 ? \'0\' : \'1\' ) ; result . append ( \'.\' ) ; result . append ( Long . toHexString ( mantissa ) ) ; if ( exponent == 0 && mantissa != 0 ) { int offset = 4 + ( ( bits < 0 ) ? 1 : 0 ) ; int desiredLength = offset + ( mantissaBits + 3 ) / 4 ; while ( result . length ( ) < desiredLength ) result . insert ( offset , \'0\' ) ; } result . append ( \'p\' ) ; if ( exponent == 0 && mantissa == 0 ) { } else { boolean denormal = exponent == 0 ; exponent -= ( 1 << ( exponentBits - 1 ) ) - 1 ; if ( denormal ) ++ exponent ; } result . append ( Long . toString ( exponent ) ) ; return result . toString ( ) ; } \n', 0.3904328016366099)

('public static String longToHexString ( long number ) throws NumberFormatException { return Long . toString ( number , 16 ) ; } \n', 0.38664686520217584)

('private static String longToHexLiteral ( long val ) { String hexDigits = Long . toHexString ( val ) ; if ( hexDigits . length ( ) % 2 == 1 ) { hexDigits = "0" + hexDigits ; } return "x\'" + hexDigits + "\'" ; } \n', 0.3841448883848527)

('public static String toHexString ( double d ) { if ( ! FpUtils . isFinite ( d ) ) return Double . toString ( d ) ; else { StringBuffer answer = new StringBuffer ( 24 ) ; if ( FpUtils . rawCopySign ( 1.0 , d ) == - 1.0 ) answer . append ( "-" ) ; answer . append ( "0x" ) ; d = Math . abs ( d ) ; if ( d == 0.0 ) { answer . append ( "0.0p0" ) ; } else { boolean subnormal = ( d < DoubleConsts . MIN_NORMAL ) ; long signifBits = ( Double . doubleToLongBits ( d ) & DoubleConsts . SIGNIF_BIT_MASK ) | 0x1000000000000000L ; answer . append ( subnormal ? "0." : "1." ) ; String signif = Long . toHexString ( signifBits ) . substring ( 3 , 16 ) ; answer . append ( signif . equals ( "0000000000000" ) ? "0" : signif . replaceFirst ( "0{1,12}$" , "" ) ) ; answer . append ( "p" + ( subnormal ? DoubleConsts . MIN_EXPONENT : FpUtils . getExponent ( d ) ) ) ; } return answer . toString ( ) ; } } \n', 0.3828759051552598)

('private static String convertToHexString ( int [ ] iArray ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i : iArray ) { sb . append ( Integer . toHexString ( i ) ) ; } return sb . toString ( ) ; } \n', 0.3825049421027435)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 16 #################################
('public static Date convertToDate ( String dateString ) { int year = Integer . parseInt ( dateString . substring ( 0 , 4 ) ) ; int month = Integer . parseInt ( dateString . substring ( 5 , 7 ) ) ; int day = Integer . parseInt ( dateString . substring ( 8 ) ) ; return convertToDate ( year , month , day ) ; } \n', 0.4235647263410027)

('public static String convertLongToDateString ( long toConvert ) { Date d = new Date ( toConvert ) ; return d . toString ( ) ; } \n', 0.41886483422176785)

('public Calendar convertDateStringToCalendar ( String dateStr ) { Calendar calendar = null ; if ( dateStr != null ) { calendar = dateTimeService . getCurrentCalendar ( ) ; calendar . set ( Integer . parseInt ( dateStr . substring ( 6 , 10 ) ) , Integer . parseInt ( dateStr . substring ( 0 , 2 ) ) - 1 , Integer . parseInt ( dateStr . substring ( 3 , 5 ) ) ) ; } return calendar ; } \n', 0.41656568540273947)

('public static String convertToDate ( String dateTime , String formatForDisplay ) { String [ ] parseDateTime = dateTime . split ( "T" ) ; String finalDateTime = parseDateTime [ 0 ] + "-" + parseDateTime [ 1 ] . replace ( "Z" , "" ) ; SimpleDateFormat convertStringToDate = new SimpleDateFormat ( "yyyy-MM-dd-HH:mm:ss" ) ; SimpleDateFormat forDisplaying = new SimpleDateFormat ( formatForDisplay ) ; try { Date theDate = convertStringToDate . parse ( finalDateTime ) ; String result = forDisplaying . format ( theDate ) ; return result ; } catch ( ParseException e ) { e . printStackTrace ( ) ; return null ; } } \n', 0.41499555737945193)

('public static int convertDateTime ( String s ) { int returnValue = 0 ; String hour , minute , second ; if ( ! s . substring ( 0 , 10 ) . equals ( Globals . electionDate ) ) { return Integer . MAX_VALUE ; } hour = s . substring ( 11 , 13 ) ; minute = s . substring ( 14 , 16 ) ; second = s . substring ( 17 ) ; returnValue += ( Integer . valueOf ( hour . trim ( ) ) - 7 ) * 3600 ; returnValue += ( Integer . valueOf ( minute . trim ( ) ) ) * 60 ; returnValue += ( Integer . valueOf ( second . trim ( ) ) ) ; return returnValue ; } \n', 0.41449478504547643)

('protected Date convertStringToDate ( String s ) { try { return dateFormat . parse ( s ) ; } catch ( ParseException e ) { throw new DataImportHandlerException ( SEVERE , "Value-for-" + LAST_INDEX_KEY + "-is-invalid-for-date-format-" + dateFormat . toLocalizedPattern ( ) + "-:-" + s ) ; } } \n', 0.4143634507708913)

('protected Date convertStringToDate ( String value ) throws ParsingException { try { return format . parse ( value ) ; } catch ( ParseException e ) { throw new ParsingException ( "Value-<" + value + ">-could-not-be-parsed-to-date-using-format-<" + format + ">." ) ; } } \n', 0.41383154068754224)

('public static Date convertStringToDate ( String date , String format ) { if ( format . equals ( "yyyymmdd" ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( date . substring ( 0 , 4 ) ) ; sb . append ( "-" ) ; sb . append ( date . substring ( 4 , 6 ) ) ; sb . append ( "-" ) ; sb . append ( date . substring ( 6 , 8 ) ) ; return Date . valueOf ( sb . toString ( ) ) ; } return null ; } \n', 0.41295574383066436)

('private String convertDateToPersistableString ( final Date aDate ) { return new SimpleDateFormat ( "yyyy/MM/dd" , Locale . US ) . format ( aDate ) ; } \n', 0.41288965734879535)

('public static String convertDateToString ( long value ) { return DATE_FORMAT . format ( new Date ( value ) ) ; } \n', 0.410722455382874)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 17 #################################
('private void parseCommandLineArguments ( final String [ ] arguments ) { if ( arguments == null || arguments . length == 0 ) { return ; } for ( String argument : arguments ) { if ( argument . startsWith ( "-m=" ) ) { this . minimized = Boolean . parseBoolean ( argument . substring ( "-m=" . length ( ) ) ) ; } } } \n', 0.4514160906825629)

('private static void readCommandLineArgs ( String [ ] args ) throws NumberFormatException { for ( String s : args ) { if ( s . toLowerCase ( ) . startsWith ( "traincorpus=" ) ) TRAIN_CORPUS = "./input/" + s . split ( "=" ) [ 1 ] ; if ( s . toLowerCase ( ) . startsWith ( "testcorpus=" ) ) TEST_CORPUS = "./input/" + s . split ( "=" ) [ 1 ] ; } } \n', 0.44767473373204814)

('public static String parseCommandLineInput ( String [ ] args ) throws Exception { if ( args . length == 1 ) { String pattern = "[a-zA-z]+" ; String cityName = args [ 0 ] ; if ( cityName . matches ( pattern ) ) { return cityName ; } else { throw new InvalidParameterNameException ( "Please-pass-a-valid-city-name-as-a-parameter.-Aborting." ) ; } } else { throw new TooManyParametersException ( "Input-parameters-not-correctly-specified.-Please-only-specify-one-parameter.-Aborting." ) ; } } \n', 0.4454745052886194)

('private static void parseCommandLine ( final String [ ] args ) throws IOException { if ( args . length == 0 ) { Configuration . initializeFromClasspathConfig ( ) ; } else if ( args . length == 1 ) { Configuration . initializeFromConfigFile ( new File ( args [ 0 ] ) ) ; } else { System . err . println ( "usage:-Main-[config.properties]" ) ; System . exit ( 1 ) ; } } \n', 0.44481066389821966)

('private Parameter getComplexParameterFromCommandLine ( String parameterValues ) throws ParameterParseException { ComplexParameter parameter = new ComplexParameter ( ) ; String [ ] values = parameterValues . split ( WHITE_SPACE ) ; if ( values . length < 3 ) { throw new ParameterParseException ( NLS . bind ( PreflightingNLS . CommandLineInputProcessor_IncorrectSyntax , parameterValues ) ) ; } else { String parameterType = values [ 0 ] ; if ( parameterType . startsWith ( PARAMETER_MARKER ) ) { parameterType = parameterType . substring ( 1 ) ; } parameter . setParameterType ( parameterType ) ; parameter . setValue ( values [ 1 ] ) ; int lenghtToCut = values [ 0 ] . length ( ) + values [ 1 ] . length ( ) + 2 ; String subParameters = parameterValues . substring ( lenghtToCut ) ; String [ ] checkSyntax = subParameters . split ( "|s*|w+|s*" + COMPLEX_PARAMETER_SEPARATOR + "|s*|w+|s*" ) ; if ( checkSyntax . length > 0 ) { throw new ParameterParseException ( NLS . bind ( PreflightingNLS . CommandLineInputProcessor_IncorrectSyntax , parameterValues ) ) ; } Pattern pat = Pattern . compile ( "|w+|s*" + COMPLEX_PARAMETER_SEPARATOR + "|s*|w+" ) ; Matcher matcher = pat . matcher ( subParameters ) ; while ( matcher . find ( ) ) { String part = subParameters . substring ( matcher . start ( ) , matcher . end ( ) ) ; String [ ] pair = part . split ( COMPLEX_PARAMETER_SEPARATOR ) ; parameter . addParameter ( pair [ 0 ] . trim ( ) , pair [ 1 ] . trim ( ) ) ; } } return parameter ; } \n', 0.43805530162765804)

('public static List < String > parseCommandLine ( String commandLineString , VariableSpace variableSpace , boolean ignoreSqoopCommand ) throws IOException { List < String > args = new ArrayList < String > ( ) ; StringReader reader = new StringReader ( commandLineString ) ; try { StreamTokenizer tokenizer = new StreamTokenizer ( reader ) ; tokenizer . ordinaryChar ( \'-\' ) ; tokenizer . ordinaryChar ( \'.\' ) ; tokenizer . ordinaryChars ( \'0\' , \'9\' ) ; tokenizer . wordChars ( \'\x00\' , \'?\' ) ; tokenizer . whitespaceChars ( 0 , \'-\' ) ; tokenizer . quoteChar ( \'"\' ) ; tokenizer . quoteChar ( \'|\'\' ) ; boolean skipToken = false ; while ( tokenizer . nextToken ( ) != StreamTokenizer . TT_EOF ) { if ( tokenizer . sval != null ) { String s = tokenizer . sval ; if ( variableSpace != null ) { s = variableSpace . environmentSubstitute ( s ) ; } if ( ignoreSqoopCommand && args . isEmpty ( ) ) { if ( "sqoop" . equals ( s ) ) { skipToken = true ; continue ; } else if ( skipToken ) { ignoreSqoopCommand = false ; skipToken = false ; continue ; } } if ( s . startsWith ( ARG_D ) ) { handleCustomOption ( args , s , tokenizer , variableSpace ) ; continue ; } args . add ( escapeEscapeSequences ( s ) ) ; } } } finally { reader . close ( ) ; } return args ; } \n', 0.43703869449421345)

('@ SuppressWarnings ( "unchecked" ) public static Map < String , String > parseCommandLineArguments ( String [ ] args ) { return ( Map ) parseCommandLineArguments ( args , false ) ; }\n', 0.43691366114696084)

("private static String [ ] parseCommandLine ( String commandLine ) { int spaceIndex = commandLine . indexOf ( '-' ) ; if ( spaceIndex == - 1 ) { return new String [ ] { commandLine , null } ; } return new String [ ] { commandLine . substring ( 0 , spaceIndex ) , commandLine . substring ( spaceIndex + 1 ) } ; } \n", 0.43303210642185425)

('public static void parseCommandLine ( String string ) { Lexer lexer ; Parser parser ; Token token ; if ( string == null ) return ; lexer = new Lexer ( new PushbackReader ( new StringReader ( string ) , 10000 ) ) ; parser = new Parser ( lexer ) ; try { parser . parse ( ) . apply ( new CmdLineDepth ( ) ) ; } catch ( Exception exception ) { System . out . println ( "[Error]Expc:-Commande-incorrect,-" + exception . getMessage ( ) ) ; } } \n', 0.4314303534853559)

('public static String [ ] extractCommandLines ( String script ) { ArrayList < String > commandLines = new ArrayList < > ( ) ; Pattern continuationPattern = Pattern . compile ( "|s*(.*?)|s+||" ) ; String [ ] lines = script . split ( "-" ) ; StringBuilder commandLine = new StringBuilder ( ) ; for ( String line : lines ) { Matcher joiningMatcher = continuationPattern . matcher ( line ) ; if ( joiningMatcher . matches ( ) ) { commandLine . append ( joiningMatcher . group ( 1 ) ) ; commandLine . append ( \'-\' ) ; } else { commandLine . append ( line . trim ( ) ) ; if ( commandLine . length ( ) > 0 ) { commandLines . add ( commandLine . toString ( ) ) ; commandLine = new StringBuilder ( ) ; } } } if ( commandLine . length ( ) > 0 ) { commandLines . add ( commandLine . toString ( ) ) ; } return commandLines . toArray ( new String [ commandLines . size ( ) ] ) ; } \n', 0.4300238348456703)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 18 #################################
('public Collection < List < ? >> valueOfSubjectAlternativeName ( ) throws IOException { return decodeGeneralNames ( getExtensionByOID ( "2.5.29.17" ) ) ; } \n', 0.3508001183039373)

('public T [ ] getEnumValuesByName ( ) { if ( enumValuesByName == null ) { T [ ] values = getEnumValuesInOrder ( ) ; if ( values != null ) { values = ( T [ ] ) values . clone ( ) ; Arrays . sort ( ( Enum < ? > [ ] ) values , ENUM_COMPARATOR ) ; enumValuesByName = values ; } } return enumValuesByName ; } \n', 0.3445348876186796)

('public static String valueOfNameValuePair ( String nameEqualsValue ) { String value = nameEqualsValue . substring ( nameEqualsValue . indexOf ( \'=\' ) + 1 ) . trim ( ) ; int i = value . indexOf ( \';\' ) ; if ( i > 0 ) value = value . substring ( 0 , i ) ; if ( value . startsWith ( """ ) ) { value = value . substring ( 1 , value . indexOf ( \'"\' , 1 ) ) ; } else { i = value . indexOf ( \'-\' ) ; if ( i > 0 ) value = value . substring ( 0 , i ) ; } return value ; } \n', 0.3375629800972938)

('public static final < T extends Enum < T >> T ofName ( Class < T > enumType , String name ) { name = trimToNull ( name ) ; if ( name != null ) { name = name . toUpperCase ( ) ; try { return Enum . valueOf ( enumType , name ) ; } catch ( IllegalArgumentException iae ) { return null ; } } return null ; } \n', 0.3228037752178956)

('public static < T extends Enum < T >> T valueOf ( Class < T > en , String name ) { if ( name == null ) return null ; try { return Enum . valueOf ( en , name ) ; } catch ( IllegalArgumentException e ) { return null ; } } \n', 0.3215643239377468)

('public static final Symbol valueOfName ( String name ) { if ( name == null ) { throw new IllegalArgumentException ( "Symbol-name-cannot-be-null" ) ; } if ( set . get ( ) == null ) { set . compareAndSet ( null , EnumSet . allOf ( Symbol . class ) ) ; } EnumSet < Symbol > enums = set . get ( ) ; Symbol sym = null ; if ( enums . size ( ) != mapping . size ( ) ) { for ( Symbol s : enums ) { if ( name . equals ( s . getName ( ) ) ) { sym = s ; } mapping . put ( s . getName ( ) , s ) ; } } else { sym = mapping . get ( name ) ; } if ( sym != null ) { return sym ; } return null ; } \n', 0.3183141679234665)

('public static < E extends Enum < E >> void assertEnumNameWithValueOf ( Class < E > enumClass ) { for ( Enum < E > value : enumClass . getEnumConstants ( ) ) { Assert . assertEquals ( value , Enum . valueOf ( enumClass , value . name ( ) ) ) ; } } \n', 0.31682478985198215)

('public Collection < List < ? >> valueOfIssuerAlternativeName ( ) throws IOException { return decodeGeneralNames ( getExtensionByOID ( "2.5.29.18" ) ) ; } \n', 0.3100417338933684)

('public long getEnumValue ( String name ) { for ( int i = 0 ; i < enums . size ( ) ; ++ i ) { Enum n = ( enums . get ( i ) ) ; if ( n . getName ( ) . equals ( name ) ) { return n . getValue ( ) ; } } throw new NoSuchElementException ( "No-enumerate-named-"" + name + ""-in-EnumType-"" + getName ( ) + """ ) ; } \n', 0.30142384604249284)

('public static < T extends Enum < T >> T valueOf ( final Class < T > enumType , final String name ) { return Enum . valueOf ( enumType , name ) ; } \n', 0.29923037500858585)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 19 #################################
('private void exportMavenDependenciesToArchive ( WebArchive finalArchive ) { Set < File > jarFiles = Sets . newHashSet ( ) ; for ( String dependency : mavenDependencies ) { try { File dependencyDir = new File ( cacheDir , dependency ) ; if ( ! dependencyDir . exists ( ) ) { resolveMavenDependency ( dependency , dependencyDir ) ; } else if ( dependencyDirIsStale ( dependencyDir ) ) { cleanDependencyDir ( dependencyDir ) ; resolveMavenDependency ( dependency , dependencyDir ) ; } File [ ] listFiles = dependencyDir . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { return name . endsWith ( ".jar" ) ; } } ) ; jarFiles . addAll ( Arrays . asList ( listFiles ) ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Can\'t-resolve-maven-dependency:-" + dependency , e ) ; } } File [ ] files = jarFiles . toArray ( new File [ jarFiles . size ( ) ] ) ; finalArchive . addAsLibraries ( files ) ; } \n', 0.4041014263573336)

('public static void exportReportToXls ( String reportSourcePath , String outputDirectory , String outputFileName , Map params , Connection connection ) throws IOException , JRException { String op = null ; if ( outputFileName == null ) { op = outputDirectory ; File userDir = new File ( outputDirectory . substring ( 0 , outputDirectory . lastIndexOf ( "|" ) ) ) ; if ( ! userDir . exists ( ) ) userDir . mkdirs ( ) ; } else { op = outputDirectory + outputFileName ; File userDir = new File ( outputDirectory ) ; if ( ! userDir . exists ( ) ) userDir . mkdirs ( ) ; } File sourceFile = Resources . getResourceAsFile ( reportSourcePath ) ; JasperReport jasperReport = ( JasperReport ) JRLoader . loadObject ( sourceFile ) ; JasperPrint jasperPrint = JasperFillManager . fillReport ( jasperReport , params , connection ) ; JRXlsExporter jrxlsexporter = new JRXlsExporter ( ) ; jrxlsexporter . setParameter ( JRExporterParameter . JASPER_PRINT , jasperPrint ) ; jrxlsexporter . setParameter ( JRExporterParameter . OUTPUT_FILE_NAME , op ) ; jrxlsexporter . exportReport ( ) ; } \n', 0.4017084932605199)

('private void exportPreferencesToFile ( Preferences prefs , String fileName , String desc ) { File file = new File ( fileName ) ; FileOutputStream output = null ; if ( ! file . exists ( ) ) { try { file . createNewFile ( ) ; } catch ( IOException e ) { log . warn ( "Impossible-to-export-" + desc + "-to-"" + fileName + ""-:-" + e . getMessage ( ) ) ; } } if ( file . exists ( ) ) { try { output = new FileOutputStream ( file ) ; prefs . exportSubtree ( output ) ; log . info ( desc + "-exported-into-"" + fileName + """ ) ; } catch ( FileNotFoundException e ) { log . warn ( "Impossible-to-export-" + desc + "-into-"" + fileName + ""-:-" + e . getMessage ( ) ) ; } catch ( IOException e ) { log . warn ( "Impossible-to-export-" + desc + "-into-"" + fileName + ""-:-" + e . getMessage ( ) ) ; } catch ( BackingStoreException e ) { log . warn ( "Impossible-to-export-" + desc + "-into-"" + fileName + ""-:-" + e . getMessage ( ) ) ; } finally { if ( output != null ) { try { output . close ( ) ; } catch ( IOException e ) { } } } } } \n', 0.39910885699278165)

('private void exportPerformanceMatrix ( WorkloadInfo info ) throws IOException { File file = new File ( ARCHIVE_DIR , "workloads.csv" ) ; boolean ready = file . exists ( ) && file . length ( ) > 0 ; Writer writer = new BufferedWriter ( new FileWriter ( file , true ) ) ; MatrixExporter exporter = Exporters . newMatrixExporter ( info ) ; try { if ( ! ready ) exporter . init ( writer ) ; exporter . export ( writer ) ; } finally { writer . close ( ) ; } String id = info . getId ( ) ; String path = file . getAbsolutePath ( ) ; String msg = "perf-details-of-workload-{}-has-been-added-to-{}" ; LOGGER . debug ( msg , id , path ) ; } \n', 0.3954911285037904)

('@ Override public void exportReport ( Document document , TPersonBean personBean , Locale locale , Map < String , Object > parameters , OutputStream os , Map < String , Object > contextMap , Map < String , Object > description ) throws ReportExportException { String format = ( String ) description . get ( IDescriptionAttributes . FORMAT ) ; if ( format == null || ! format . equals ( FORMAT_DOCX ) ) { throw new ReportExportException ( ERROR_UNKNOWN_FORMAT ) ; } String docxTemplatePath = null ; URL completeURL = ( URL ) parameters . get ( JasperReportExporter . REPORT_PARAMETERS . COMPLETE_URL ) ; if ( completeURL != null ) { docxTemplatePath = completeURL . getFile ( ) ; WordprocessingMLPackage wpMLP = AssembleWordprocessingMLPackage . getWordMLPackage ( MeetingDatasource . WORK_ITEM_BEAN , MeetingDatasource . REPORT_BEANS , docxTemplatePath , personBean . getObjectID ( ) , locale ) ; try { Docx4J . save ( wpMLP , os , Docx4J . FLAG_NONE ) ; } catch ( Exception e ) { LOGGER . error ( "Exporting-the-docx-failed-with-throwable-" + e . getMessage ( ) ) ; LOGGER . debug ( ExceptionUtils . getStackTrace ( e ) ) ; } } } \n', 0.39537197668183066)

('public void exportSettingsToFile ( SharedPreferences prefs , File settingsFile ) throws JSONException , IOException { JSONObject json = exportSettings ( prefs ) ; if ( settingsFile . exists ( ) ) { settingsFile . delete ( ) ; } settingsFile . getParentFile ( ) . mkdirs ( ) ; settingsFile . createNewFile ( ) ; FileWriter writer = new FileWriter ( settingsFile ) ; writer . write ( json . toString ( 2 ) ) ; writer . flush ( ) ; writer . close ( ) ; } \n', 0.3916413605100637)

('private void exportDistributorVersions ( File baseDir ) throws IOException { List < DistributorVersion > versions = distVerCurator . findAll ( ) ; if ( versions == null || versions . isEmpty ( ) ) { return ; } File distVerDir = new File ( baseDir . getCanonicalPath ( ) , "distributor_version" ) ; distVerDir . mkdir ( ) ; FileWriter writer = null ; for ( DistributorVersion dv : versions ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Exporting-Distributor-Version" + dv . getName ( ) ) ; } try { File file = new File ( distVerDir . getCanonicalPath ( ) , dv . getName ( ) + ".json" ) ; writer = new FileWriter ( file ) ; distVerExporter . export ( mapper , writer , dv ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } } \n', 0.386698622875146)

('public void export ( Display display ) { if ( chooser == null ) { initializeChooser ( ) ; } File outFile = null ; int returnVal = chooser . showSaveDialog ( display ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { outFile = chooser . getSelectedFile ( ) ; } else { return ; } String format = ( ( SimpleFileFilter ) chooser . getFileFilter ( ) ) . getExtension ( ) ; String ext = IOLib . getExtension ( outFile ) ; if ( ! format . equals ( ext ) ) { outFile = new File ( outFile . toString ( ) + "." + format ) ; } boolean exported = false ; String errorMessage = null ; try { OutputStream out = new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ; exported = export ( display , out , format ) ; out . flush ( ) ; out . close ( ) ; } catch ( Exception ex ) { exported = false ; errorMessage = ex . getMessage ( ) ; ex . printStackTrace ( ) ; } if ( ! exported ) { JOptionPane . showMessageDialog ( display , errorMessage , "Export-Error" , JOptionPane . ERROR_MESSAGE ) ; } } \n', 0.38385205500364006)

('public void exportCsv ( final ArrayList < CityInformationField > fieldsToExport ) throws IOException { FileWriter writer = new FileWriter ( this . exportedCsvFileName ) ; writeCsvHeaderToFile ( writer ) ; for ( CityInformationField f : fieldsToExport ) { writeFieldToFile ( writer , f ) ; } writer . flush ( ) ; writer . close ( ) ; System . out . println ( "Sucessfully-exported-" + fieldsToExport . size ( ) + "-fields-to-" + this . exportedCsvFileName + "." ) ; } \n', 0.3823097519175188)

('public static File saveExcelWebFormsToFS ( String reportType , Date initialDate , Date finalDate ) throws Exception { try { String folder = UtilMethods . getTemporaryDirPath ( ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "MMddyyyy" ) ; String fileNameDate = sdf . format ( initialDate ) ; String filePath = folder + fileName + "_" + reportType + "_" + fileNameDate + fileExtension ; File excelFile = new File ( filePath ) ; if ( ! excelFile . exists ( ) ) { excelFile . createNewFile ( ) ; } FileWriter fileWriter = new FileWriter ( excelFile ) ; String code = CreateExcelWebForms ( reportType , initialDate , finalDate ) ; fileWriter . write ( code ) ; fileWriter . flush ( ) ; fileWriter . close ( ) ; return excelFile ; } catch ( Exception ex ) { String message = ex . toString ( ) ; Logger . debug ( WebFormFactory . class , message ) ; throw ex ; } } \n', 0.3792061345233127)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 20 #################################
('public void setWorkingDirectory ( File wd ) { workingDirectory = ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) ? null : wd ; } \n', 0.42783612258074766)

('public void setWorkingDirectory ( File wd ) { if ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) { workingDirectory = null ; } else { workingDirectory = wd ; } } \n', 0.42783612258074766)

('public void setWorkingDirectory ( File workingDirectory ) throws MojoExecutionException { try { this . workingDirectory = workingDirectory . getCanonicalPath ( ) ; } catch ( IOException ignored ) { throw new MojoExecutionException ( "Unable-to-set-working-directory-for-JMeter-process!" ) ; } } \n', 0.4259656264195995)

('public void setWorkingDirectory ( File workingDir ) { Assert . notNull ( workingDir ) ; logger . info ( "Setting-working-directory-for-LDAP_PROVIDER:-" + workingDir . getAbsolutePath ( ) ) ; if ( workingDir . exists ( ) ) { throw new IllegalArgumentException ( "The-specified-working-directory-\'" + workingDir . getAbsolutePath ( ) + "\'-already-exists.-Another-directory-service-instance-may-be-using-it-or-it-may-be-from-a-" + "-previous-unclean-shutdown.-Please-confirm-and-delete-it-or-configure-a-different-" + "working-directory" ) ; } this . workingDir = workingDir ; service . setWorkingDirectory ( workingDir ) ; } \n', 0.4249093399552469)

('public void setWorkingDirectory ( File workingDirectory ) { this . workingDirectory = workingDirectory . getAbsolutePath ( ) ; } \n', 0.42299142273823637)

('protected void setCurrentWorkingDirectory ( File cwd ) { if ( cwd != null ) { if ( cwd . isDirectory ( ) ) this . currentWorkingDirectory = cwd ; else this . currentWorkingDirectory = cwd . getParentFile ( ) ; } else this . currentWorkingDirectory = null ; } \n', 0.4201508468648839)

('public void setWorkingDirectory ( File workingDirectory ) { m_workingDirectory = workingDirectory ; if ( m_workingDirectoryPropertySupport != null ) { m_workingDirectoryPropertySupport . firePropertyChange ( null , null , null ) ; } } \n', 0.41996574521941077)

('public void setWorkingDirectory ( File workingDir ) { if ( workingDir != null ) { this . workingDir = workingDir . getAbsolutePath ( ) ; } } \n', 0.4187692822870171)

('public void setWorkingDirectory ( File workingDirectory ) { this . configurationFile = new File ( new File ( workingDirectory . getAbsolutePath ( ) , "conf" ) , "communication.xml" ) ; } \n', 0.4183743921216871)

('public void setWorkingDirectory ( File workingDirectory ) { if ( workingDirectory != null ) { this . workingDir = workingDirectory . getAbsolutePath ( ) ; } } \n', 0.4183002165749376)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 21 #################################
('public static String getStatusText ( int nHttpStatusCode ) { Integer intKey = new Integer ( nHttpStatusCode ) ; if ( ! _status_codes . containsKey ( intKey ) ) { return "" ; } else { return ( String ) _status_codes . get ( intKey ) ; } } \n', 0.3874130869968625)

('public static String getHTTPStatusCode ( String httpHeaders ) throws WSIException { String statusCode = null ; if ( httpHeaders . startsWith ( "HTTP" ) ) { int index = httpHeaders . indexOf ( "-" ) ; int index2 = httpHeaders . indexOf ( "-" , index + 1 ) ; if ( ( index == - 1 ) || ( index2 == - 1 ) ) { throw new WSIException ( "Could-not-find-status-code-in-http-headers:-[" + httpHeaders + "]." ) ; } else { statusCode = httpHeaders . substring ( index + 1 , index2 ) ; } } else { throw new WSIException ( "Could-not-find-status-code-in-http-headers:-[" + httpHeaders + "]." ) ; } return statusCode ; } \n', 0.38298904877439427)

('public static int getStatusCode ( String url ) throws IOException { int statusCode ; HttpURLConnection con = ( HttpURLConnection ) new URL ( url ) . openConnection ( ) ; con . setInstanceFollowRedirects ( false ) ; statusCode = con . getResponseCode ( ) ; con . disconnect ( ) ; return statusCode ; } \n', 0.3828281849891293)

('public static String getStatusText ( int nHttpStatusCode ) { Integer intKey = Integer . valueOf ( nHttpStatusCode ) ; if ( ! _mapStatusCodes . containsKey ( intKey ) ) { return "" ; } else { return _mapStatusCodes . get ( intKey ) ; } } \n', 0.3760691848976545)

('public static String getStatusText ( int nHttpStatusCode ) { if ( ! mapStatusCodes . containsKey ( nHttpStatusCode ) ) { return "" ; } else { return mapStatusCodes . get ( nHttpStatusCode ) ; } } \n', 0.37369547934920017)

('public static String getStatusText ( int nHttpStatusCode ) throws RemoteException , RemoteException { startManagers ( ) ; Integer intKey = Integer . valueOf ( nHttpStatusCode ) ; if ( ! mapStatusCodes . containsKey ( intKey ) ) { return "" ; } else { return mapStatusCodes . get ( intKey ) ; } } \n', 0.3723491901410865)

('public static String getHttpStatusCodeText ( int sc ) { HttpStatusCode sCode = HttpStatusCode . fromNumStatusCode ( sc ) ; if ( sCode == null ) { return sc + " <unknown status code>" ; } else { return sCode . toString ( ) ; } }\n', 0.36257530893121925)

('public static String getStatusDescription ( int code ) { return ( String ) descriptions . get ( new Integer ( code ) ) ; } \n', 0.36002306801666745)

('public static String getStatusDescription ( int status ) { String description = "" ; Integer statusKey = new Integer ( status ) ; if ( statusDescriptions . containsKey ( statusKey ) ) { description = statusDescriptions . get ( statusKey ) ; } return String . format ( "%s %d %s" , WebDavConst . HTTPVER , status , description ) ; }\n', 0.3546645563110431)

('@ Override public int getStatusCode ( ) throws IOException { int result = - 1 ; if ( connection instanceof HttpURLConnection ) { result = ( ( HttpURLConnection ) connection ) . getResponseCode ( ) ; } return result ; } \n', 0.34530106316217857)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 22 #################################
('public static HttpResponse postJSON ( JSONObject jsonData , String apiEndpoint , Context context ) { HttpResponse result = null ; if ( ! isOnline ( context ) ) { return null ; } else { result = postJsonString ( jsonData . toString ( ) , apiEndpoint , context ) ; return result ; } } \n', 0.3768976922373781)

('private JSONObject readJSONFormRequest ( HttpServletRequest request ) { final int buf_size = 4096 ; JSONObject jsonObject = null ; BufferedReader inputStream = null ; try { inputStream = new BufferedReader ( new InputStreamReader ( request . getInputStream ( ) , Configuration . getInstance ( ) . getCharacterEncoding ( ) ) ) ; CharArrayWriter data = new CharArrayWriter ( ) ; char buf [ ] = new char [ buf_size ] ; int ret ; while ( ( ret = inputStream . read ( buf , 0 , buf_size ) ) != - 1 ) { data . write ( buf , 0 , ret ) ; } if ( data . size ( ) == 0 ) return jsonObject ; jsonObject = new JSONObject ( data . toString ( ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( "read-request-post-data-errordon\'t-support-post-encoding" , e ) ; } catch ( IOException e ) { logger . error ( "read-request-post-data-errorio-exception" , e ) ; } catch ( ParseException e ) { logger . error ( "read-request-post-data-errorparse-json-error" , e ) ; } finally { IOUtils . closeQuietly ( inputStream ) ; } logger . debug ( "Received-request-post-data:{}" , jsonObject ) ; return jsonObject ; } \n', 0.36860520585157636)

('protected Object serializeArgumentToJson ( Object pArg ) { if ( pArg == null ) { return null ; } else if ( pArg instanceof JSONAware ) { return pArg ; } else if ( pArg . getClass ( ) . isArray ( ) ) { return serializeArray ( pArg ) ; } else if ( pArg instanceof Map ) { return serializeMap ( ( Map ) pArg ) ; } else if ( pArg instanceof Collection ) { return serializeCollection ( ( Collection ) pArg ) ; } else { return pArg instanceof Number || pArg instanceof Boolean ? pArg : pArg . toString ( ) ; } } \n', 0.3513129654911224)

('public static JsonElement postSerializedJSON ( URL url , final byte [ ] jsonBytes ) throws IOException { JsonParser jp = new JsonParser ( ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setDoOutput ( true ) ; conn . setDoInput ( true ) ; conn . setRequestMethod ( "POST" ) ; conn . setRequestProperty ( "Content-Type" , "application/json" ) ; conn . setRequestProperty ( "charset" , "utf-8" ) ; conn . setRequestProperty ( "Content-Length" , Integer . toString ( jsonBytes . length ) ) ; DataOutputStream wr = new DataOutputStream ( conn . getOutputStream ( ) ) ; wr . write ( jsonBytes , 0 , jsonBytes . length ) ; wr . flush ( ) ; wr . close ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; return jp . parse ( reader ) ; } \n', 0.35085202095759604)

('public static JSONObject postJsonRequest ( String url , String postData ) throws IOException , JSONException { URL obj = new URL ( url ) ; HttpURLConnection con = ( HttpURLConnection ) obj . openConnection ( ) ; con . setRequestMethod ( "POST" ) ; if ( DEBUG ) Log . d ( TAG , "Posting:-" + postData + "-to-" + url ) ; con . setDoOutput ( true ) ; DataOutputStream wr = new DataOutputStream ( con . getOutputStream ( ) ) ; wr . writeBytes ( postData ) ; wr . flush ( ) ; wr . close ( ) ; int responseCode = con . getResponseCode ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String inputLine ; StringBuffer response = new StringBuffer ( ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { response . append ( inputLine ) ; } in . close ( ) ; JSONObject json = new JSONObject ( response . toString ( ) ) ; return json ; } \n', 0.34975675414772045)

('private JSONRequest parseJSONRequest ( HttpServletRequest request ) throws IOException { BufferedReader reader = null ; char [ ] buff = new char [ 100 ] ; int sz = 0 ; try { reader = request . getReader ( ) ; StringBuffer buffer = new StringBuffer ( ) ; while ( ( sz = reader . read ( buff ) ) != - 1 ) { buffer . append ( buff , 0 , sz ) ; } FVLog . log ( LogLevel . DEBUG , null , "---------JSON-RPC-request:" + buffer . toString ( ) ) ; return gson . fromJson ( buffer . toString ( ) , JSONRequest . class ) ; } finally { if ( reader != null ) reader . close ( ) ; } } \n', 0.34876313051447444)

('@ Nullable public static ObjectNode requestJSON ( final String uri , @ Nullable final Parameters params ) { final HttpResponse response = request ( "GET" , uri , params , new Parameters ( "Accept" , "application/json,-text/javascript,-*/*;-q=0.01" ) , null ) ; final String responseData = getResponseData ( response , false ) ; if ( responseData != null ) { try { return ( ObjectNode ) JsonUtils . reader . readTree ( responseData ) ; } catch ( final IOException e ) { Log . w ( "requestJSON" , e ) ; } } return null ; } \n', 0.33751532007024665)

('public String postBusinessJsonProcess ( String entity_id , String json , String _user_id ) throws Exception { Hashtable params = new Hashtable ( ) ; String retval = "" ; try { params . put ( "entity_id" , entity_id ) ; params . put ( "json" , json ) ; params . put ( "_user_id" , _user_id ) ; retval = this . doCurl ( "POST" , "/business/json/process" , params ) ; } finally { } return retval ; } \n', 0.33597753489326254)

('public static String processJsonString ( String jsonString ) { String replaceString ; try { Log . d ( Constant . LOG_TAG , "the-jsonString-is-" + jsonString ) ; replaceString = new String ( jsonString . replace ( "|"" , """ ) . replace ( "||u" , "|u" ) . getBytes ( "UTF-8" ) , "UTF-8" ) ; replaceString = replaceString . substring ( 1 , replaceString . length ( ) - 1 ) ; return replaceString ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return null ; } \n', 0.3344603761666054)

('public Map < String , Object > requestJson ( String path , Map < String , Object > getParams , Map < String , Object > postParams , Map < String , Object > requestOptions ) throws BoxViewException { HttpUriRequest request = createRequest ( path , getParams , postParams , requestOptions ) ; Integer timeout = createTimeout ( requestOptions ) ; HttpResponse response = execute ( request , timeout ) ; String responseBody = null ; try { responseBody = EntityUtils . toString ( response . getEntity ( ) ) ; } catch ( IOException e ) { } return handleJsonResponse ( responseBody , request ) ; } \n', 0.3323959691024525)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 23 #################################
('private void closeConnections ( Vector < Connection > connections ) { try { for ( Connection con : connections ) { if ( ! con . isClosed ( ) ) { con . close ( ) ; } } } catch ( SQLException e ) { } } \n', 0.35471095431477073)

('private void manageConnections ( ) { try { servSock = new ServerSocket ( port ) ; System . out . printf ( "Server-listening-on-port-%d-" , port ) ; connHandler = new ConnectionHandler ( this , maxConnections ) ; handlerThread = new Thread ( connHandler ) ; handlerThread . start ( ) ; } catch ( IOException ex ) { System . out . println ( "Error-while-attempting-to-listen-for-connections." ) ; ex . printStackTrace ( ) ; } } \n', 0.3487104999639783)

('public static void finishConnect ( String username , Socket socket ) { Server . println ( "Continuing-to-connect-with-username-" + username ) ; sendAll ( new ConnectionMessage ( username , Utils . Utils . getCurrentTimestamp ( ) , ConnectionMessage . types . CONNECT ) ) ; giveAllConnections ( username ) ; Server . println ( "True;-can-connect-with" + username ) ; } \n', 0.3481096675283152)

('public void stopListeningForConnections ( ) throws ResourceDiscoveryException { shouldAcceptConnections = false ; try { newResource . stopWaitingForIncomingConnection ( ) ; serverSocket . close ( ) ; clientCommandsServerSocket . close ( ) ; } catch ( ResourceException ex ) { throw new ResourceDiscoveryException ( "Could-not-stop-connection" ) ; } catch ( NullPointerException ex ) { } catch ( IOException ex ) { } try { resourceDiscoveryThread . join ( ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( "global" ) . log ( Level . FINER , "Resource-discovery-thread-interrupted-while-waiting-to-close" ) ; } catch ( NullPointerException ex ) { } } \n', 0.34766611665018976)

('private static void openConnection ( Socket clientSocket ) { ServerConnection serverConnection = new ServerConnection ( clientSocket ) ; new Thread ( serverConnection ) . start ( ) ; DeveloperLogger . appendText ( "clientSocket-temporary-connection-address:-" + serverConnection . getConnectedAddress ( ) ) ; serverConnections . add ( 0 , serverConnection ) ; } \n', 0.3464268522639515)

('public void connected ( ) throws CommunicatorException { try { myConnection . getChannel ( ) . finishConnect ( ) ; LOG . info ( "Connection-extablished-successfully-with" + "-the-remote-host" ) ; } catch ( IOException e ) { throw new CommunicatorException ( e ) ; } } \n', 0.3459954982339756)

('public HttpURLConnection openConnection ( URL url ) throws IOException { HttpURLConnection con = ( HttpURLConnection ) url . openConnection ( ) ; con . setReadTimeout ( ( int ) HTTP_READ_TIMEOUT_SECONDS ) ; con . setConnectTimeout ( ( int ) HTTP_CONNECT_TIMEOUT_SECONDS ) ; return con ; } \n', 0.34535439813230967)

('protected void receiveAndAddConnection ( ) { try { DatagramPacket receivePacket = new DatagramPacket ( receiveData , receiveData . length ) ; if ( logger != null ) logger . info ( "waiting-for-" + ( numClients - connections . size ( ) ) + "-more-clients-to-reconnect..." ) ; socket . receive ( receivePacket ) ; InetAddress ip = receivePacket . getAddress ( ) ; int port = receivePacket . getPort ( ) ; String connID = UDPConnection . buildHash ( ip , port ) ; if ( connections . get ( connID ) == null ) { if ( connections . size ( ) == 0 ) { frameCount = 0 ; if ( logger != null ) logger . info ( "resetting-frame-count" ) ; } UDPConnection conn = new UDPConnection ( ip , port ) ; connections . put ( connID , conn ) ; conn . send ( socket , getSyncPayload ( ) ) ; if ( logger != null ) logger . fine ( "added-new-connection:-" + conn ) ; if ( listener != null ) { listener . clientConnected ( conn ) ; } } } catch ( SocketTimeoutException e ) { } catch ( IOException e ) { handleException ( e ) ; } } \n', 0.34473075443449164)

('private void closeConnections ( Vector connections ) { try { for ( int i = 0 ; i < connections . size ( ) ; i ++ ) { Connection connection = ( Connection ) connections . elementAt ( i ) ; if ( ! connection . isClosed ( ) ) { connection . close ( ) ; } } } catch ( SQLException sqle ) { } } \n', 0.3446418368303569)

('public void manageProfileConnection ( IConnectionProfile profile , String factoryID , Object client ) { ManagedProfileKey key = new ManagedProfileKey ( profile , factoryID ) ; if ( ! mManagedProfileKeyToConnections . containsKey ( key ) ) { IConnection con = createConnection ( profile , factoryID ) ; mManagedProfileKeyToConnections . put ( key , con ) ; mManagedProfileKeyToClientSet . put ( key , new HashSet ( ) ) ; IConnectListener listener = ( IConnectListener ) mFactoryIDToListener . get ( factoryID ) ; if ( listener == null ) { listener = new ProfileConnectListener ( factoryID ) ; mFactoryIDToListener . put ( factoryID , listener ) ; } Set listeners = ( Set ) mProfileToListenerSet . get ( profile ) ; if ( listeners == null ) { listeners = new HashSet ( ) ; mProfileToListenerSet . put ( profile , listeners ) ; } listeners . add ( listener ) ; profile . addConnectListener ( listener ) ; } ( ( Set ) mManagedProfileKeyToClientSet . get ( key ) ) . add ( client ) ; } \n', 0.34381061683868597)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 24 #################################
('public void copyFromLocalFile ( Path src , Path dst ) throws IOException { copyFromLocalFile ( false , src , dst ) ; } \n', 0.37266021544785133)

('@ Deprecated public void copyFromLocalFile ( Path src , Path dst ) throws IOException { copyFromLocalFile ( false , true , false , src , dst ) ; } \n', 0.37266021544785133)

('public void copyToLocalFile ( boolean delSrc , boolean validate , Path src , Path dst ) throws IOException { FileUtil . copy ( this , src , getLocal ( getConf ( ) ) , dst , delSrc , validate , getConf ( ) ) ; } \n', 0.3694456612481368)

('public void copyToLocalFile ( boolean delSrc , Path src , Path dst ) throws IOException { FileUtil . copy ( this , src , getLocal ( getConf ( ) ) , dst , delSrc , getConf ( ) ) ; } \n', 0.3686831406995327)

('public static void copyFiles ( final File src , final FilenameFilter filter , final File dest , final boolean inSortedOrder , final boolean overwrite ) throws IOException { if ( ! src . exists ( ) ) { if ( LOGGER . isLoggable ( Level . FINE ) ) { LOGGER . fine ( src . getAbsolutePath ( ) + "-does-not-exist" ) ; } return ; } if ( src . isDirectory ( ) ) { if ( LOGGER . isLoggable ( Level . FINE ) ) { LOGGER . fine ( src . getAbsolutePath ( ) + "-is-a-directory." ) ; } if ( ! dest . exists ( ) ) { dest . mkdirs ( ) ; } String list [ ] = ( filter == null ) ? src . list ( ) : src . list ( filter ) ; if ( inSortedOrder ) { Arrays . sort ( list ) ; } for ( int i = 0 ; i < list . length ; i ++ ) { copyFiles ( new File ( src , list [ i ] ) , filter , new File ( dest , list [ i ] ) , inSortedOrder , overwrite ) ; } } else { copyFile ( src , dest , overwrite ) ; } } \n', 0.36843956840840947)

('public void copyFromLocalFile ( boolean delSrc , Path src , Path dst ) throws IOException { copyFromLocalFile ( delSrc , true , src , dst ) ; } \n', 0.36822160180892594)

('public static void copyFileToFile ( File file , File destFile , boolean overwrite ) throws IOException { if ( ( ! overwrite ) && destFile . isFile ( ) ) { throw new IllegalStateException ( "Destination-file-" + destFile + "-already-exists" ) ; } if ( destFile . isDirectory ( ) ) { throw new IllegalStateException ( "Destination-file-is-an-existing-directory" ) ; } try ( FileInputStream in = new FileInputStream ( file ) ; FileOutputStream out = new FileOutputStream ( destFile ) ) { int bytesRead ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; while ( ( bytesRead = in . read ( buffer ) ) != - 1 ) { out . write ( buffer , 0 , bytesRead ) ; } } destFile . setLastModified ( file . lastModified ( ) ) ; } \n', 0.36465579717700014)

('public static void copyAllFiles ( File src , File dst ) { if ( ! src . isDirectory ( ) ) { FileManager . copyFile ( src , dst ) ; } else { if ( ! dst . exists ( ) ) { dst . mkdirs ( ) ; } int length = src . getPath ( ) . length ( ) ; File [ ] files = src . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { FileManager . copyAllFiles ( files [ i ] , new File ( dst , files [ i ] . getPath ( ) . substring ( length ) ) ) ; } } } \n', 0.36391720009839784)

('public void copyFiles ( DependencyTracker t , File omitMe ) { try { for ( Iterator e = t . mDependencies . iterator ( ) ; e . hasNext ( ) ; ) { FileInfo f = ( FileInfo ) e . next ( ) ; if ( ! f . mPathname . equals ( omitMe . getCanonicalPath ( ) ) ) { mDependencies . add ( f ) ; } } } catch ( java . io . IOException e ) { throw new ChainedException ( e ) ; } } \n', 0.35835582942398425)

('public static void copyFile ( Path from , Path to ) throws IOException { if ( from == null ) { throw new NullPointerException ( "From-file-is-null" ) ; } if ( Files . notExists ( from ) ) { throw new IOException ( "From-file-does-not-exists-" + from . toAbsolutePath ( ) . toString ( ) ) ; } if ( from . equals ( to ) ) { throw new IOException ( "cannot-copy-onto-itself" ) ; } try { copyFromStreamToFile ( Files . newInputStream ( from ) , to ) ; } catch ( IOException e ) { throw new IOException ( from + "-->-" + to + ":" + e . getMessage ( ) , e ) ; } } \n', 0.35736109306752517)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 25 #################################
('public static BufferedReader getBufferedReader ( File f , String encoding ) throws IOException { if ( encoding == null ) { encoding = DEFAULT_ENCODING ; } return new BufferedReader ( new InputStreamReader ( getInputStream ( f ) , encoding ) ) ; } \n', 0.37264694312987334)

('public static BufferedReader bufferedReader ( File file , String encoding ) throws IOException { BufferedReader result ; FileInputStream fis = new FileInputStream ( file . getPath ( ) ) ; try { result = bufferedReader ( fis , encoding ) ; } catch ( UnsupportedEncodingException uee ) { try { fis . close ( ) ; } catch ( IOException ioe ) { } throw uee ; } return result ; } \n', 0.3659441663719698)

('public static void readFileBufferedFileReader ( File file ) { BufferedReader bufferedReader = null ; try { log . info ( "##-[ReadFile]-read-file:-" + file . getCanonicalPath ( ) + "-##" ) ; bufferedReader = new BufferedReader ( new FileReader ( file ) ) ; String line ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { log . info ( "##-[ReadFile]-line:-" + line + "-##" ) ; } } catch ( FileNotFoundException e ) { log . error ( "##-[ReadFile]-open-file-failed-##" ) ; log . error ( e . getMessage ( ) ) ; } catch ( IOException e ) { log . error ( "##-[ReadFile]-read-file-failed-##" ) ; log . error ( e . getMessage ( ) ) ; } finally { try { if ( bufferedReader != null ) { bufferedReader . close ( ) ; } } catch ( IOException e ) { log . error ( "##-[ReadFile]-close-file-failed-##" ) ; log . error ( e . getMessage ( ) ) ; } } } \n', 0.3653537608164582)

('private BufferedReader getBufferedReader ( File file ) throws IOException { InputStream inputStream = getInputStream ( file ) ; return new BufferedReader ( new InputStreamReader ( inputStream ) ) ; } \n', 0.3626938665074163)

('private static BufferedReader getBufferedReader ( File file , String encoding ) throws FileNotFoundException { BufferedReader reader ; try { if ( encoding != null ) { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , encoding ) ) ; } else { reader = new BufferedReader ( new FileReader ( file ) ) ; } } catch ( UnsupportedEncodingException e ) { throw new FileNotFoundException ( "Unsupported-encoding-" + encoding ) ; } return reader ; } \n', 0.3626722854320767)

('public static BufferedReader getBufferedReader ( File file ) throws FileNotFoundException { FileInputStream fis = new FileInputStream ( file ) ; InputStreamReader isr = new InputStreamReader ( fis ) ; return new BufferedReader ( isr ) ; } \n', 0.3622239237841156)

('public static BufferedReader getBufferedReader ( String File ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( File ) , "ISO-8859-1" ) ) ; return br ; } \n', 0.3615215813009689)

('public static String loadTextFile ( File file ) throws IOException { char [ ] buffer = new char [ 4096 ] ; int len ; StringBuilder input = new StringBuilder ( ) ; BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; try { while ( ( len = reader . read ( buffer ) ) != - 1 ) { input . append ( buffer , 0 , len ) ; } } finally { reader . close ( ) ; } return input . toString ( ) ; } \n', 0.3607215733120296)

('public BufferedReader getBufferedReader ( String file , String format ) { try { fis = new FileInputStream ( file ) ; isr = new InputStreamReader ( fis , format ) ; br = new BufferedReader ( isr ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return br ; } \n', 0.3600310489002144)

('public static BufferedReader getBufferedReader ( File file , Charset charset ) throws FileNotFoundException { return new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , charset ) ) ; } \n', 0.35955237201641943)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 26 #################################
('public long elapsedNanoTime ( ) { if ( ! run ) { throw new UnrunTimerException ( ) ; } if ( running ) { return elapsed + System . nanoTime ( ) - startTime ; } else { return elapsed ; } } \n', 0.34436739679792827)

('public long getMetricElapsedTime ( Timer timer , TimeUnit desiredUnit ) { return timers . get ( timer ) . elapsed ( desiredUnit ) ; } \n', 0.34431423032664865)

('public long getElapsedTimeFromTimer ( Object o ) { synchronized ( timerMap ) { Timer timer = timerMap . get ( o ) ; if ( timer == null ) { timer = new Timer ( ) ; timerMap . put ( o , timer ) ; } return timer . getElapsedTime ( ) ; } } \n', 0.3353703552966095)

('public static String timeUsed ( long startTime ) { if ( options . testMode ) return "TIME" ; long delta = java . lang . System . currentTimeMillis ( ) - startTime ; return ( delta / 1000.0 ) + "-s" + "-" + spaceUsed ( ) ; } \n', 0.31946785732191657)

('@ Deprecated public String getElapsedTime ( ) { return this . getElapsedTime ( this . timerFormat ) ; } \n', 0.3186045885685859)

('public static final void startTimer ( int level , int timerNum ) { if ( using ) { if ( ! Debug . isLevelEnabled ( level ) ) return ; if ( ( timerNum >= 0 ) && ( timerNum < MAX_TIMERS ) ) timers [ timerNum ] = System . currentTimeMillis ( ) ; } } \n', 0.3181164011477551)

('public static String timeUsed ( long startTime ) { if ( getOptions ( ) . testMode ) return "TIME" ; long delta = java . lang . System . currentTimeMillis ( ) - startTime ; return ( delta / 1000.0 ) + "-s" + "-" + spaceUsed ( ) ; } \n', 0.3179770491142459)

('public long timeElapsed ( ) { return timer . elapsedTime ( ) ; } \n', 0.31646646295652214)

('public long elapsedTime ( ) { if ( ! timer . isRunning ( ) ) return elapsedTime ; long now = System . currentTimeMillis ( ) ; if ( startTime == - 1 ) { startTime = now ; } return now - startTime + elapsedTime ; } \n', 0.3141698009608492)

('public long getElapsedTime ( ) { return timer . getElapsedTime ( ) ; } \n', 0.30721512478027035)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 27 #################################
('public static String reverseStringUsingRecursion ( String inputString ) { if ( inputString . length ( ) == 0 ) { return "" ; } return inputString . charAt ( inputString . length ( ) - 1 ) + reverseStringUsingRecursion ( inputString . substring ( 0 , inputString . length ( ) - 1 ) ) ; } \n', 0.3631486670384907)

('public static String reverseString ( String inputString ) { String reversedString = "" ; if ( inputString . length ( ) == 1 ) { return inputString ; } else { reversedString += inputString . charAt ( inputString . length ( ) - 1 ) + reverseString ( inputString . substring ( 0 , inputString . length ( ) - 1 ) ) ; return reversedString ; } } \n', 0.36049334819153733)

('public static String toReversedString ( byte [ ] ba ) { return toReversedString ( ba , 0 , ba . length ) ; } \n', 0.35416919974314576)

('public static String reverseString ( String s ) { String result = s ; if ( result != null ) { StringBuffer rs = new StringBuffer ( s ) ; result = rs . reverse ( ) . toString ( ) ; } return result ; } \n', 0.3511572278102068)

('public void reverseStringReverse ( String input ) { if ( input == null || input . isEmpty ( ) || input . trim ( ) . isEmpty ( ) ) { System . out . println ( "-Input-String-is-null-/-empty-/blank" ) ; return ; } System . out . println ( "STRING-" + reverseString ( input ) ) ; } \n', 0.35020387188126223)

('private String reverseString ( final String s ) { final int len = s . length ( ) ; char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { chars [ i ] = s . charAt ( len - i - 1 ) ; } return new String ( chars ) ; } \n', 0.3491569990833373)

('private static String [ ] strings ( Object [ ] objects ) { String [ ] strings = new String [ objects . length ] ; for ( int i = 0 ; i < objects . length ; i += 1 ) { strings [ i ] = String . valueOf ( objects [ i ] ) ; } return strings ; } \n', 0.3486399308842557)

('public static String reverseString ( String toReverse ) { final StringBuffer buffer = new StringBuffer ( toReverse ) ; return buffer . reverse ( ) . toString ( ) ; } \n', 0.348074950250101)

('private static String reverseString ( String string ) { char [ ] newSet = new char [ string . length ( ) ] ; for ( int i = string . length ( ) - 1 ; i >= 0 ; i -- ) { newSet [ string . length ( ) - 1 - i ] = string . charAt ( i ) ; } return String . valueOf ( newSet ) ; } \n', 0.346155301741543)

('private static String reverseString ( String in ) { StringBuilder out = new StringBuilder ( in ) . reverse ( ) ; return out . toString ( ) ; }\n', 0.3449229108970294)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 28 #################################
('public static String extractHtml ( String content , String startpoint , String endpoint ) { Pattern startPattern = Pattern . compile ( startpoint , Pattern . CASE_INSENSITIVE ) ; Pattern endPattern = Pattern . compile ( endpoint , Pattern . CASE_INSENSITIVE ) ; Matcher startMatcher = startPattern . matcher ( content ) ; Matcher endMatcher = endPattern . matcher ( content ) ; int start = 0 ; int end = content . length ( ) ; if ( startMatcher . find ( ) ) { start = startMatcher . end ( ) ; } if ( endMatcher . find ( start ) ) { end = endMatcher . start ( ) ; } return content . substring ( start , end ) ; } \n', 0.4225099506087976)

('public static String extractContentStrippingMarkup ( String htmlText , String startMark , String endMark ) { String content = "" ; int startMarkIndex = htmlText . indexOf ( startMark ) ; int endMarkIndex = htmlText . indexOf ( endMark ) ; if ( startMarkIndex != - 1 && endMarkIndex != - 1 ) { startMarkIndex += startMark . length ( ) ; content = htmlText . substring ( startMarkIndex , endMarkIndex ) ; Source src = new Source ( content ) ; content = src . getTextExtractor ( ) . toString ( ) ; } return content ; } \n', 0.4201197423600136)

("public boolean extractJSONfromHTML ( ) { JSONValue jsonValue ; String tagId = url . substring ( url . lastIndexOf ( '/' ) + 1 ) ; Element dataTag = Document . get ( ) . getElementById ( tagId ) ; if ( dataTag != null ) { jsonValue = JSONParser . parseStrict ( dataTag . getInnerHTML ( ) ) ; task . process ( jsonValue ) ; return true ; } else { String location = Window . Location . getHref ( ) ; return false ; } } \n", 0.41435941131403653)

('private String extractFromHtml ( String content ) throws Exception { Parser myParser ; Node [ ] nodes = null ; myParser = Parser . createParser ( content , null ) ; NodeFilter filter = new NodeClassFilter ( TextNode . class ) ; nodes = myParser . extractAllNodesThatMatch ( filter ) . toNodeArray ( ) ; StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) { TextNode textnode = ( TextNode ) nodes [ i ] ; String line = textnode . toPlainTextString ( ) . trim ( ) ; result . append ( line ) ; } return result . toString ( ) ; } \n', 0.41264880182455893)

('public static LinkedList extractFootnotesFromContent ( String content ) { LinkedList < String > footnotes = new LinkedList < > ( ) ; int pos = 0 ; while ( pos != - 1 ) { pos = content . indexOf ( Constants . footnoteHtmlTag , pos ) ; if ( pos != - 1 ) { int end = content . indexOf ( """ , pos + Constants . footnoteHtmlTag . length ( ) ) ; if ( end != - 1 ) { String fn = content . substring ( pos + Constants . footnoteHtmlTag . length ( ) , end ) ; if ( - 1 == footnotes . indexOf ( fn ) ) { footnotes . add ( fn ) ; } pos = end ; } else { pos = pos + Constants . footnoteHtmlTag . length ( ) ; } } } return footnotes ; } \n', 0.4123791874405629)

('private Map < String , Object > extractHTMLContent ( String url , InputStream in ) throws Exception { Map < String , Object > config = new HashMap < String , Object > ( ) ; config . put ( "perComponentDOM" , false ) ; config . put ( "perPipelineDOM" , true ) ; Map < String , Object > metadata = new HashMap < String , Object > ( ) ; metadata . put ( "url" , url ) ; List < String > components = new ArrayList < String > ( ) ; components . add ( "meaningfulweb" ) ; Map < String , Object > output = new HashMap < String , Object > ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; byte [ ] contentBytes = new byte [ DEFAULT_BUFFER_SIZE ] ; long totalBytesRead = 0L ; while ( true ) { int count = in . read ( contentBytes ) ; if ( count > 0 ) { totalBytesRead += count ; baos . write ( contentBytes , 0 , count ) ; } else if ( count < 0 ) { break ; } if ( totalBytesRead >= MAX_CONTENT_LEN ) break ; } if ( totalBytesRead >= MAX_CONTENT_LEN ) throw new IOException ( "content-too-large" ) ; contentBytes = baos . toByteArray ( ) ; Extract extract = new Extract ( contentBytes ) ; extract . getComponents ( ) . addAll ( components ) ; extract . setConfig ( config ) ; extract . setMetadata ( metadata ) ; try { htmlExtractor . extract ( extract ) ; output = extract . getExtracted ( ) ; } catch ( Exception e ) { logger . error ( "Error-extracting-content" , e ) ; } return output ; } \n', 0.4033043923545837)

('private void extractFaviconFromHTML ( Image icon , File cachedFile ) { try { String page = fetchPage ( icon . getArticleURL ( ) ) ; Matcher matcher = FAVICON_PATTERN . matcher ( page ) ; if ( matcher . find ( ) ) { URL url = new URL ( icon . getArticleURL ( ) , matcher . group ( 1 ) ) ; StreamUtils . copyStreamToFile ( openConnection ( url ) . getInputStream ( ) , cachedFile ) ; LOG . debug ( "Downloaded-favicon-via-web-page:-" + url . toString ( ) ) ; } else { LOG . info ( "No-favicon-for:-" + icon . getArticleURL ( ) ) ; } } catch ( IOException ex ) { cachedFile . delete ( ) ; LOG . warn ( "Failed-downloading-home-page-for-favicon:-" + icon . getArticleURL ( ) ) ; } } \n', 0.40291513158355446)

('private void extract ( final String html ) { this . characterCount = html . length ( ) ; this . result = new StringBuffer ( html . length ( ) / 5 ) ; this . tagText = new StringBuffer ( 1024 ) ; try { ByteArrayInputStream byis = new ByteArrayInputStream ( html . getBytes ( Charsets . UTF_8 ) ) ; new HtmlExtractorParser ( byis , "UTF-8" ) . extract ( this ) ; } catch ( Exception exc ) { exc . printStackTrace ( ) ; error = exc ; } StringTokenizer st = new StringTokenizer ( result . toString ( ) , "-" , false ) ; while ( st . hasMoreTokens ( ) ) { this . wordCount ++ ; st . nextToken ( ) ; } } \n', 0.39949920027715435)

('public static List < String > extractUrlsFromHtml ( String html ) { List < String > result = new ArrayList < String > ( ) ; Matcher matcher = HTML_URLS . matcher ( html ) ; while ( matcher . find ( ) ) { result . add ( matcher . group ( 2 ) ) ; } return result ; } \n', 0.3992919839028373)

('public static String extractImgData ( String html ) throws IllegalArgumentException { Document dom = Jsoup . parse ( html ) ; Elements divtags = dom . getElementsByTag ( "div" ) ; Element imgdatatag = null ; for ( Element e : divtags ) { if ( e . hasAttr ( "id" ) && e . attr ( "id" ) . equals ( "draw_current_avatar" ) ) imgdatatag = e ; } if ( imgdatatag != null ) { return imgdatatag . text ( ) ; } else throw new IllegalArgumentException ( "Invalid-HTML" ) ; } \n', 0.398822300973668)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 29 #################################
('protected String getAboutHTMLPath ( ) { return aboutHTMLText . getText ( ) . trim ( ) ; } \n', 0.37964179689233013)

('public byte [ ] getHtml ( HttpClient client , HttpUriRequest request , String header , String footer ) throws IOException { for ( Entry < String , String > e : requestProperties . entrySet ( ) ) request . setHeader ( e . getKey ( ) , e . getValue ( ) ) ; BufferedReader in = null ; try { HttpResponse response = client . execute ( request ) ; StringBuilder html = new StringBuilder ( ) ; html . append ( header ) ; html . append ( NL ) ; HttpEntity entity = response . getEntity ( ) ; if ( entity != null ) { String inputLine ; in = new BufferedReader ( new InputStreamReader ( entity . getContent ( ) ) ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { html . append ( inputLine ) ; html . append ( NL ) ; } } html . append ( footer ) ; html . append ( NL ) ; html . trimToSize ( ) ; return html . toString ( ) . getBytes ( this . charSet ) ; } finally { if ( in != null ) { in . close ( ) ; } } } \n', 0.37261473237287746)

('private String getAboutHtmlFromMultilingualString ( Translator translator , String version ) { final String aboutHtmlBeforeVersionNumber = Translator . get ( "AboutHTMLBeforeVersionNumber" ) ; final String aboutHmlAfterVersionNumber = Translator . get ( "AboutHTMLAfterVersionNumber" ) ; final int aboutHTMLBeforeVersionNumberLength = aboutHtmlBeforeVersionNumber . length ( ) ; final int versionNumberStringLength = version . length ( ) ; final int aboutHtmlAfterVersionNumberLength = aboutHmlAfterVersionNumber . length ( ) ; final int aboutHtmlStringBuilderCapacity = aboutHTMLBeforeVersionNumberLength + versionNumberStringLength + aboutHtmlAfterVersionNumberLength ; final StringBuilder aboutHtmlStringBuilder = new StringBuilder ( aboutHtmlStringBuilderCapacity ) ; aboutHtmlStringBuilder . append ( aboutHtmlBeforeVersionNumber ) ; aboutHtmlStringBuilder . append ( version ) ; aboutHtmlStringBuilder . append ( aboutHmlAfterVersionNumber ) ; return aboutHtmlStringBuilder . toString ( ) ; } \n', 0.364020897402028)

('public List < String > getWebLinksListFromHtml ( String htmlData ) { final List < String > webLinksList = new ArrayList < String > ( ) ; htmlData . replaceAll ( "|s+" , "-" ) ; final HTMLLinkExtractor extractor = new HTMLLinkExtractor ( ) ; final List < HtmlLink > links = extractor . grabHTMLLinks ( htmlData ) ; for ( int i = 0 ; i < links . size ( ) ; i ++ ) { final HtmlLink htmlLinks = links . get ( i ) ; webLinksList . add ( htmlLinks . getLink ( ) ) ; } return webLinksList ; } \n', 0.3633318176434981)

('String getHTMLForAdminPage ( Map < String , String > params ) { try { String template = m_htmlTemplates . get ( "admintemplate.html" ) ; for ( Entry < String , String > e : params . entrySet ( ) ) { String key = e . getKey ( ) . toUpperCase ( ) ; String value = e . getValue ( ) ; if ( key == null ) continue ; if ( value == null ) value = "NULL" ; template = template . replace ( "#" + key + "#" , value ) ; } return template ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return "<html><body>An-unrecoverable-error-was-encountered-while-generating-this-page.</body></html>" ; } \n', 0.36266395522414147)

('public String getWebPageContents ( ) { if ( webPageContents == null || webPageContents . isEmpty ( ) ) { final String htmlPageLocationInitial = getHtmlPageLocation ( ) ; final String pageLocation ; pageLocation = htmlPageLocationInitial . startsWith ( "/" ) ? htmlPageLocationInitial . substring ( 1 , htmlPageLocationInitial . length ( ) ) : htmlPageLocationInitial ; webPageContents = IO . read ( Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( pageLocation ) ) ; } return webPageContents ; } \n', 0.3583296544198321)

('public static Spanned getHtml ( Context context , int resId , Object ... formatArgs ) { Object [ ] args = new Object [ formatArgs . length ] ; for ( int i = 0 ; i < formatArgs . length ; i ++ ) { String url = context . getString ( ( Integer ) formatArgs [ i ] ) ; args [ i ] = "-<a-href=\'" + url + "\'>" + url + "</a>-" ; } return Html . fromHtml ( context . getString ( resId , args ) ) ; } \n', 0.35779345751363373)

('public String fetchArticleHtml ( final String identifier ) throws SQLException { final Cursor cursor = this . databaseHelper . query ( true , DATABASE_TABLE , new String [ ] { KEY_ROWID , KEY_HTML } , this . createIdentifierCondition ( identifier ) , null , null , null , null , null ) ; if ( cursor != null ) { cursor . moveToFirst ( ) ; final String html = cursor . getString ( cursor . getColumnIndexOrThrow ( ArticleDbAdapter . KEY_HTML ) ) ; cursor . close ( ) ; return html ; } return null ; } \n', 0.35606394949059683)

('public String getHtmlReasons ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( HTML ) ; List < String > reasons = getReasons ( ) ; if ( ! reasons . isEmpty ( ) ) { String firstReason = reasons . get ( 0 ) ; if ( firstReason . startsWith ( HTML ) ) { firstReason = firstReason . substring ( HTML . length ( ) ) ; } sb . append ( firstReason ) ; } return sb . toString ( ) ; } \n', 0.3550778189252652)

('public static String getWebHtml ( String webUrl ) { System . out . println ( "Reading-Web-" ) ; URL u = null ; InputStream in = null ; InputStreamReader r = null ; BufferedReader br = null ; String message = null ; String html = null ; try { u = new URL ( webUrl ) ; in = u . openStream ( ) ; r = new InputStreamReader ( in , "UTF-8" ) ; br = new BufferedReader ( r ) ; while ( ( message = br . readLine ( ) ) != null ) { html = html + message ; } } catch ( Exception e ) { e . getStackTrace ( ) ; System . out . println ( e . getMessage ( ) ) ; } finally { try { u = null ; in . close ( ) ; r . close ( ) ; br . close ( ) ; } catch ( Exception e ) { } } System . out . println ( "----Read-finisded" ) ; return html ; } \n', 0.3538113579091579)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 30 #################################
('public void dumpToHTMLFile ( File file ) throws IOException { PrintWriter w = new PrintWriter ( new FileWriter ( file ) ) ; w . println ( "<html><body>" ) ; w . println ( "<h1>List-of-all-artifacts</h1>" ) ; TreeSet < String > sortedSet = new TreeSet < String > ( ) ; sortedSet . addAll ( nodes . keySet ( ) ) ; for ( String path : sortedSet ) { w . println ( "<a-href="#" + path . replace ( \'/\' , \'_\' ) + "">" + path + "</a><br>" ) ; } w . println ( "<h1>Dependencies-per-artifact</h1>" ) ; for ( String path : nodes . keySet ( ) ) { w . println ( "<h2><a-name="" + path . replace ( \'/\' , \'_\' ) + "">" + path + "</a></h2>" ) ; INode n = nodes . get ( path ) ; w . println ( "<h3>Uses</h3>" ) ; for ( Link link : sortList ( n . getOutgoing ( ) ) ) { w . println ( "<a-href="#" + link . getTarget ( ) . getPath ( ) . replace ( \'/\' , \'_\' ) + "">" + link . getTarget ( ) . getPath ( ) + "</a><br>" ) ; } w . println ( "<h3>Used-by</h3>" ) ; for ( Link link : sortList ( n . getIncoming ( ) ) ) { w . println ( "<a-href="#" + link . getSource ( ) . getPath ( ) . replace ( \'/\' , \'_\' ) + "">" + link . getSource ( ) . getPath ( ) + "</a><br>" ) ; } } w . println ( "</body></html>" ) ; w . close ( ) ; } \n', 0.3952643947424098)

('public static void endHTMLFile ( DataOutputStream writer , boolean include_text ) throws IOException { String section_end_rule = "<br>-<hr>-" ; String anchor_link = "<p><tt><a-href="#Top">-top-of-page-</a></tt></p>-" ; String end_tags = "</body>-</html>-" ; if ( include_text ) { writer . writeBytes ( section_end_rule ) ; writer . writeBytes ( anchor_link ) ; } writer . writeBytes ( end_tags ) ; writer . close ( ) ; } \n', 0.3917720662165949)

('public void logHtml ( String xmlFilename , String xslUri , String outFilename , String textFilename ) { logXml ( xmlFilename , xslUri ) ; File xmlFile = new File ( xmlFilename ) ; if ( xslUri == null || xmlFile . length ( ) > getMaxXmlConversionLength ( ) ) { logHtmlFromText ( textFilename , outFilename ) ; return ; } File xsltFile = new File ( xslUri ) ; Source xmlSource = new StreamSource ( xmlFile ) ; Source xsltSource = new StreamSource ( xsltFile ) ; try { TransformerFactory transFact = TransformerFactory . newInstance ( ) ; Transformer trans = transFact . newTransformer ( xsltSource ) ; PrintStream pout = null ; try { pout = new PrintStream ( new FileOutputStream ( outFilename ) ) ; trans . transform ( xmlSource , new StreamResult ( pout ) ) ; } catch ( Exception ex ) { this . err . println ( "Can\'t-open-output-file-" + outFilename ) ; logHtmlFromText ( textFilename , outFilename ) ; } finally { if ( pout != null ) { pout . close ( ) ; } } } catch ( Throwable e ) { logHtmlFromText ( textFilename , outFilename ) ; } } \n', 0.3842749330921675)

('public VddLogToHTML ( String inputFilename ) throws VDDLogException { File infile ; backTraceID = 0 ; eventDumpID = 0 ; try { infile = ( new File ( inputFilename ) ) . getCanonicalFile ( ) ; } catch ( IOException e ) { throw new VDDLogException ( "Unable-to-resolve-" + inputFilename , e ) ; } this . issues = new VddLogIssues ( ) ; try { in = new BufferedReader ( new FileReader ( infile ) ) ; } catch ( FileNotFoundException e ) { throw new VDDLogException ( "Failed-to-find-input-file-" + infile , e ) ; } String fn = infile . getName ( ) ; if ( ! fn . endsWith ( ".log" ) ) { throw new VDDLogException ( inputFilename + "-is-not-a-VDD-log-file" ) ; } outfile = new File ( infile . getParent ( ) + File . separator + "Report-" + fn . replaceAll ( ".log$" , ".html" ) ) ; System . out . println ( "(*)Generating-report:-" + outfile ) ; try { out = new PrintStream ( new FileOutputStream ( outfile ) ) ; } catch ( FileNotFoundException e ) { throw new VDDLogException ( "Unable-to-write-to-" + outfile , e ) ; } } \n', 0.38016492425110815)

('private void dumpHtmlToFile ( StringBuilder html , boolean append ) { FsUtils . writeDataToStorage ( new File ( mResultsRootDirPath , HTML_DETAILS_RELATIVE_PATH ) , html . toString ( ) . getBytes ( ) , append ) ; html . setLength ( 0 ) ; mResultsSinceLastHtmlDump = 0 ; } \n', 0.37972654108837633)

('public void writeOutputToHTML ( ) throws BadOutputFormatException , IOException { BufferedWriter writer = new BufferedWriter ( new FileWriter ( outputFile ) ) ; writer . write ( formatToHTML ( ) ) ; writer . flush ( ) ; writer . close ( ) ; } \n', 0.37409037087067765)

('private File saveHTML ( String html ) { File htmlOutput = null ; try { htmlOutput = new File ( System . getProperty ( "user.dir" ) + System . getProperty ( "file.separator" ) + "myUpload.html" ) ; FileWriter fw = new FileWriter ( htmlOutput ) ; fw . write ( html ) ; fw . flush ( ) ; fw . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } return htmlOutput ; } \n', 0.36840157515960015)

('private String getSimpleHtmlOutputPath ( ) { if ( parsedSimpleHtmlOutputPath == null ) { File reportPath = new File ( targetDirectory , "lint-results/lint-results-simple-html" ) ; createReportDirIfNeeded ( reportPath ) ; return reportPath . getAbsolutePath ( ) ; } return parsedSimpleHtmlOutputPath ; } \n', 0.36633243672862426)

('private String getHtmlOutputPath ( ) { if ( parsedHtmlOutputPath == null ) { File reportPath = new File ( targetDirectory , "lint-results/lint-results-html" ) ; createReportDirIfNeeded ( reportPath ) ; return reportPath . getAbsolutePath ( ) ; } return parsedHtmlOutputPath ; } \n', 0.3662159783891644)

('private void displayHTMLOutput ( Diagnosis diagnosis ) { if ( diagnosis != null ) { if ( diagnosis . getLogFileStream ( ) . length ( ) > 0 ) { htmlLogFileView . initializeDialog ( diagnosis . getLogFileStream ( ) ) ; } } } \n', 0.3617195093509016)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 31 #################################
('public static String getClientIpAddress ( ) { return ( String ) clientIpAddress . get ( ) ; } \n', 0.4023261090756701)

('public static String getLocalIpAddress ( ) { if ( localIpAddress . length ( ) == 0 ) { localIpAddress = "0.0.0.0" ; } return localIpAddress ; } \n', 0.39764766508978444)

('private InetAddress getServerInetAddress ( ) throws SocketException , UnknownHostException { if ( serverSocketAddress == null ) { boolean preferIPV4Stack = Boolean . getBoolean ( "java.net.preferIPv4Stack" ) ; boolean preferIPV6Addresses = Boolean . getBoolean ( "java.net.preferIPv6Addresses" ) && ! preferIPV4Stack ; try { serverSocketAddress = getFirstNonLoopbackAddress ( preferIPV4Stack , preferIPV6Addresses ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; } if ( serverSocketAddress == null ) { LOG . warning ( "no-remote-ip-address-available-so-only-possible-to-test-using-loopback-address." ) ; serverSocketAddress = InetAddress . getLocalHost ( ) ; } } return serverSocketAddress ; } \n', 0.3932953695155823)

('public static String getProperIpAddress ( String fullIpAddress ) { String [ ] ipAddressArray = fullIpAddress . split ( "|." ) ; String part1 = String . valueOf ( Integer . valueOf ( ipAddressArray [ 0 ] ) ) ; String part2 = String . valueOf ( Integer . valueOf ( ipAddressArray [ 1 ] ) ) ; String part3 = String . valueOf ( Integer . valueOf ( ipAddressArray [ 2 ] ) ) ; String part4 = String . valueOf ( Integer . valueOf ( ipAddressArray [ 3 ] ) ) ; return part1 + "." + part2 + "." + part3 + "." + part4 ; } \n', 0.3862191740859795)

('public static String getLocalHostIPAddress ( ) { try { return InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException exception ) { return "127.0.0.1" ; } } \n', 0.3856248230716528)

('public String getIpAddress ( ) { return ipAddress . toString ( ) ; } \n', 0.38288481445206346)

('public static String getDefaultIPAddress ( ) { String address = "127.0.0.1" ; List < String > localAddresses = getLocalIPAddresses ( ) ; if ( localAddresses . size ( ) > 0 ) { address = localAddresses . get ( 0 ) ; } return address ; } \n', 0.38277236460476105)

('public static String getRealIPAddress ( String ipAddress ) throws UnknownHostException { if ( ipAddress . equals ( "localhost" ) || ipAddress . equals ( "127.0.0.1" ) ) { ipAddress = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } return ipAddress ; } \n', 0.3824407369709638)

('public static String getIPAddress ( ) { String ipAddress = null ; try { return InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { logger . error ( "Unable-to-get-the-IpAddress" , e ) ; } logger . debug ( "IP-is-" + ipAddress ) ; return ipAddress ; } \n', 0.37960890274291825)

('private static InetAddress getFloatingIpAddress ( Server server ) { Preconditions . checkNotNull ( server , "instance-is-null" ) ; InetAddress floatingIpAddress = null ; try { Iterator < Address > iterator = server . getAddresses ( ) . values ( ) . iterator ( ) ; Address floatingAddress = null ; while ( iterator . hasNext ( ) ) { Address address = iterator . next ( ) ; if ( address . getVersion ( ) == 4 ) { break ; } } while ( iterator . hasNext ( ) ) { floatingAddress = iterator . next ( ) ; if ( floatingAddress . getVersion ( ) == 4 ) { floatingIpAddress = InetAddress . getByName ( floatingAddress . getAddr ( ) ) ; break ; } } } catch ( UnknownHostException e ) { throw new IllegalArgumentException ( "Invalid-floating-IP-address" , e ) ; } return floatingIpAddress ; } \n', 0.37901534522061797)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 32 #################################
('public static int levenshteinSimilarity ( String compareString1 , String compareString2 , int minPercent ) { int dlw = getLevenshteinDistance ( compareString1 , compareString2 , minPercent ) ; if ( ( minPercent > - 1 ) && ( dlw == - 1 ) ) return 0 ; int maxlwlm = Math . max ( compareString1 . length ( ) , compareString2 . length ( ) ) ; int percent = 100 ; if ( maxlwlm > 0 ) { percent = 100 - ( dlw * 100 ) / maxlwlm ; if ( percent >= 100 ) { percent = 100 ; if ( ! compareString1 . equals ( compareString2 ) ) percent = percent - 1 ; } else if ( percent < 0 ) { percent = 0 ; } } return percent ; } \n', 0.4052618261405815)

('public String similarity ( String userInput , String Xbrltext ) { float similarity = 0.0f ; String simi ; float count = 0.0f ; char [ ] user = userInput . toCharArray ( ) ; char [ ] xbrl = Xbrltext . toCharArray ( ) ; int length = xbrl . length ; int pos ; pos = Xbrltext . indexOf ( userInput ) ; if ( pos != - 1 ) { String subStr = Xbrltext . substring ( pos , Xbrltext . length ( ) ) ; xbrl = subStr . toCharArray ( ) ; for ( int i = 0 ; i < user . length ; i ++ ) { char c = user [ i ] ; if ( c == xbrl [ i ] ) { count += 1.0 ; } else { break ; } } } if ( count == xbrl . length ) { return "100%" ; } similarity = count / length ; NumberFormat format = NumberFormat . getInstance ( ) ; format . setMaximumIntegerDigits ( 2 ) ; format . setMaximumFractionDigits ( 2 ) ; simi = format . format ( similarity * 100 ) + "%" ; System . out . println ( simi + "%" ) ; return simi ; } \n', 0.3972115266599574)

('private void evaluateByCosineSimilarity ( ) { ArrayList < EvaluateResult > resultList = new ArrayList < EvaluateResult > ( ) ; int qid ; int rel ; String docSten = "" ; HashMap < String , Integer > doctokenMap ; HashMap < String , Integer > qryTokenMap ; double score ; for ( int i = 0 ; i < qIdList . size ( ) ; i ++ ) { qid = qIdList . get ( i ) ; rel = relList . get ( i ) ; doctokenMap = tokMapList . get ( i ) ; docSten = strList . get ( i ) ; if ( rel != 99 ) { qryTokenMap = tokMapList . get ( getQrySentIndex ( qid ) ) ; score = computeCosineSimilarity ( qryTokenMap , doctokenMap ) ; EvaluateResult docResult = new EvaluateResult ( ) ; docResult . qid = qid ; docResult . rel = rel ; docResult . score = score ; docResult . sentence = docSten ; resultList . add ( docResult ) ; } } sortAndPrintResult ( resultList ) ; } \n', 0.39114900246594875)

('public Double getSimilarity ( String q , String d ) throws IOException { if ( q == null || d == null || q . length ( ) == 0 || d . length ( ) == 0 ) return 0.0 ; Double sim = 0.0 ; Map < String , Integer > wordsQ = tokenized ( q ) ; Map < String , Integer > wordsD = tokenized ( d ) ; Double normQ = 0.0 ; Double normD = 0.0 ; for ( Map . Entry < String , Integer > e : wordsQ . entrySet ( ) ) { String t = e . getKey ( ) ; Integer tfd = wordsD . get ( t ) ; Double idf = idf ( t ) ; if ( tfd != null ) { sim += e . getValue ( ) * tfd * Math . pow ( idf , 2 ) ; normD += Math . pow ( tfd * idf , 2 ) ; } normQ += Math . pow ( e . getValue ( ) * idf , 2 ) ; } for ( Map . Entry < String , Integer > e : wordsD . entrySet ( ) ) { if ( ! wordsQ . containsKey ( e . getKey ( ) ) ) { normD += Math . pow ( e . getValue ( ) * idf ( e . getKey ( ) ) , 2 ) ; } } sim = sim / ( Math . sqrt ( normQ ) * Math . sqrt ( normD ) ) ; return sim . isNaN ( ) ? 0.0 : sim ; } \n', 0.38455814670168087)

('public double computeSimilarity ( String source , String target ) { if ( source == null || target == null ) return 0.0D ; String [ ] s = source . split ( "|s+" ) ; String [ ] t = target . split ( "|s+" ) ; int intersection = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { for ( int j = 0 ; j < t . length ; j ++ ) { String test = s [ i ] ; if ( test . equalsIgnoreCase ( t [ j ] ) ) { intersection ++ ; j = target . length ( ) ; } } } if ( intersection > 0 ) { int union = s . length + t . length - intersection ; return intersection / ( double ) union ; } return 0.0D ; } \n', 0.38443154816505487)

('public double similarity ( StringRef stringRef1 , StringRef stringRef2 ) { double length1 = stringRef1 . length ; double length2 = stringRef2 . length ; HashMapVector v1 = stringRef1 . vector ; HashMapVector v2 = stringRef2 . vector ; double similarity = 0 ; if ( length1 == 0 || length2 == 0 ) { return 0 ; } Iterator mapEntries = v1 . iterator ( ) ; while ( mapEntries . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) mapEntries . next ( ) ; String token = ( String ) entry . getKey ( ) ; if ( v2 . hashMap . containsKey ( token ) ) { double count1 = ( ( Weight ) entry . getValue ( ) ) . getValue ( ) ; double count2 = ( ( Weight ) v2 . hashMap . get ( token ) ) . getValue ( ) ; TokenInfo tokenInfo = m_tokenInfoMap . get ( token ) ; if ( tokenInfo != null ) { double increment = count1 * count2 ; if ( m_useIDF ) { increment *= tokenInfo . idf * tokenInfo . idf ; } similarity += increment ; } } } similarity /= length1 * length2 ; return similarity ; } \n', 0.38298104986865705)

('public double similarity ( ) { double sim = ( double ) maxDistance / Math . min ( s1 . length ( ) - 1 , s2 . length ( ) - 1 ) ; return sim > MAX_SIMILARITY ? MAX_SIMILARITY : sim ; } \n', 0.38062710662457544)

('public Map < String , Float > findSimilarity ( String code , int threshhold , TrieNode node , int distance ) { Map < String , Float > result = new HashMap < String , Float > ( ) ; if ( threshhold > 0 ) { for ( Map . Entry < Character , TrieNode > nodeX : node . children . entrySet ( ) ) { if ( nodeX . getKey ( ) == code . charAt ( 0 ) ) { result . putAll ( ( findSimilarity ( code . substring ( 1 ) , threshhold , nodeX . getValue ( ) , distance ) ) ) ; } else { result . putAll ( findSimilarity ( code . substring ( 1 ) , threshhold - 1 , nodeX . getValue ( ) , distance + 1 ) ) ; } } } else { for ( Map . Entry < Character , TrieNode > nodeX : node . children . entrySet ( ) ) { if ( nodeX . getKey ( ) == code . charAt ( 0 ) ) { result . putAll ( ( findSimilarity ( code . substring ( 1 ) , 0 , nodeX . getValue ( ) , distance ) ) ) ; } } } for ( String word : node . leaf ) { result . put ( word , ( 1 - distance / length ) ) ; } return result ; } \n', 0.3797189195069509)

('public static int stringSimilarity ( String str ) { char [ ] charArr = str . toCharArray ( ) ; int length = charArr . length ; int sum = length ; for ( int i = 1 ; i < length ; i ++ ) { int similarity = 0 ; for ( ; similarity < length - i ; similarity ++ ) if ( charArr [ similarity ] != charArr [ similarity + i ] ) { break ; } sum += similarity ; } return sum ; } \n', 0.37820021667330606)

('public static int levenshtein ( String str1 , String str2 ) { char [ ] chars1 = str1 . toCharArray ( ) ; char [ ] chars2 = str2 . toCharArray ( ) ; int length1 = str1 . length ( ) ; int length2 = str2 . length ( ) ; int [ ] [ ] matrix = new int [ length1 + 1 ] [ length2 + 1 ] ; int cost = 0 ; if ( length1 == 0 ) return length2 ; else if ( length2 == 0 ) return length1 ; else if ( str1 . equals ( str2 ) ) return 0 ; for ( int i = 0 ; i < length1 ; i ++ ) matrix [ i ] [ 0 ] = i ; for ( int j = 0 ; j < length2 ; j ++ ) matrix [ 0 ] [ j ] = j ; for ( int i = 1 ; i < length1 ; i ++ ) { for ( int j = 1 ; j < length2 ; j ++ ) { if ( chars1 [ i ] == chars2 [ j ] ) cost = 0 ; else cost = 1 ; matrix [ i ] [ j ] = ( int ) MathHelper . min ( matrix [ i - 1 ] [ j ] + 1 , matrix [ i ] [ j - 1 ] + 1 , matrix [ i - 1 ] [ j - 1 ] + cost ) ; } } return matrix [ length1 - 1 ] [ length2 - 1 ] ; } \n', 0.37761346446498567)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 33 #################################
('public static double simulateNormalDistribution ( double mean , double standardDeviation ) { return new NormalDistribution ( Random . generator , mean , standardDeviation , NormalDistribution . DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample ( ) ; } \n', 0.3909394390300517)

('public void computeDistribution ( ) throws IOException { computeDistribution ( EmpiricalDistributionImpl . DEFAULT_BIN_COUNT ) ; } \n', 0.3835667312988993)

('public int nextBinomial ( int numberOfTrials , double probabilityOfSuccess ) { return new BinomialDistribution ( getRandomGenerator ( ) , numberOfTrials , probabilityOfSuccess ) . sample ( ) ; } \n', 0.3834891603205559)

('public void computeDistribution ( ) throws IOException , ZeroException , NullArgumentException { computeDistribution ( EmpiricalDistribution . DEFAULT_BIN_COUNT ) ; } \n', 0.38348356074412904)

('public static double log10BinomialProbability ( final int n , final int k , final double log10p ) { if ( log10p > 1e-18 ) throw new IllegalArgumentException ( "log10p:-Log-probability-must-be-0-or-less" ) ; double log10OneMinusP = Math . log10 ( 1 - Math . pow ( 10 , log10p ) ) ; return log10BinomialCoefficient ( n , k ) + log10p * k + log10OneMinusP * ( n - k ) ; } \n', 0.3805805373510208)

('public double exponentialDistribution ( double average ) { double uniformDistribution = Math . random ( ) ; return - average * Math . log ( uniformDistribution ) ; } \n', 0.3794505471190732)

('public static NormalDistribution normalDistribution ( double mean , double sd ) { NormalDistribution dist = new NormalDistribution ( mean , sd ) ; dist . reseedRandomGenerator ( seed ) ; return dist ; } \n', 0.3771282631925565)

('public static int simulatePoissonDistribution ( double mean ) { return new PoissonDistribution ( Random . generator , mean , PoissonDistribution . DEFAULT_EPSILON , PoissonDistribution . DEFAULT_MAX_ITERATIONS ) . sample ( ) ; } \n', 0.3763465587530923)

('public static double binomialProbability ( final int n , final int k , final double p ) { return Math . pow ( 10 , log10BinomialProbability ( n , k , Math . log10 ( p ) ) ) ; } \n', 0.3759102551077473)

('public static double binomialProbability ( int n , int k , double p ) { return Math . pow ( 10 , log10BinomialProbability ( n , k , Math . log10 ( p ) ) ) ; } \n', 0.3759102551077473)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 34 #################################
('public void saveCSVConfig ( final OutputStream out ) throws IOException { final OutputStreamWriter writer = new OutputStreamWriter ( out ) ; final CsvWriter csv = new CsvWriter ( ) ; try { final Enumeration keys = params . keys ( ) ; final Enumeration values = params . elements ( ) ; while ( keys . hasMoreElements ( ) ) { final String key = ( String ) keys . nextElement ( ) ; final String value = ( String ) values . nextElement ( ) ; csv . append ( key ) ; csv . append ( value ) ; csv . nl ( ) ; writer . write ( csv . toString ( ) ) ; csv . reset ( ) ; } } finally { writer . close ( ) ; out . close ( ) ; } } \n', 0.3874548523264726)

('public void writeCSV ( Writer writer , String columnDelimiter , String rowDelimiter ) throws IOException { for ( K k : getItems ( ) ) { writer . write ( k . toString ( ) ) ; writer . write ( columnDelimiter ) ; writer . write ( acc . get ( k ) . toString ( ) ) ; writer . write ( rowDelimiter ) ; } } \n', 0.3868236753386918)

('private void writeCSV ( ResultSet rs , PrintWriter writer ) throws SQLException { ResultSetMetaData meta = rs . getMetaData ( ) ; int columns = meta . getColumnCount ( ) + 1 ; StringBuffer line = new StringBuffer ( ) ; String item ; for ( int i = 1 ; i < columns ; i ++ ) { if ( i != 1 ) { line . append ( ",-" ) ; } line . append ( meta . getColumnName ( i ) ) ; } writer . println ( line . toString ( ) ) ; while ( rs . next ( ) ) { line = new StringBuffer ( ) ; for ( int i = 1 ; i < columns ; i ++ ) { item = rs . getString ( i ) ; if ( i != 1 ) { line . append ( ",-" ) ; } if ( item != null ) { line . append ( item ) ; } } writer . println ( line . toString ( ) ) ; } } \n', 0.37947071595943155)

('public static void writeCsvCredits ( List < Player > allPlayers , Writer fWriter ) { try { for ( Player player : allPlayers ) { fWriter . write ( player . getBalance ( ) + "," ) ; } fWriter . write ( "-" ) ; fWriter . flush ( ) ; } catch ( IOException e ) { throw new RuntimeException ( "Error-while-writing-file-" + fWriter + "." + e ) ; } } \n', 0.3742101933990231)

('public void saveAsCSV ( OutputStream out , String [ ] lineup ) throws IOException { BufferedWriter wout = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; wout . write ( "Nr;Login;Password;DisplayName;ExcludedAssignment;ExcludedRound;" ) ; wout . newLine ( ) ; int [ ] seq = getRegistrationSequence ( ) ; for ( int t = 0 ; t < teams . size ( ) ; t ++ ) { int idx = seq [ t ] ; wout . write ( String . valueOf ( registrationIndex . get ( idx ) . intValue ( ) + 1 ) ) ; wout . write ( ";" ) ; wout . write ( String . valueOf ( teams . get ( idx ) ) ) ; wout . write ( ";" ) ; wout . write ( String . valueOf ( passwords . get ( idx ) ) ) ; wout . write ( ";" ) ; wout . write ( String . valueOf ( displayNames . get ( idx ) ) ) ; wout . write ( ";" ) ; wout . write ( String . valueOf ( excludedAssignments . get ( idx ) ) ) ; wout . write ( ";" ) ; boolean found = false ; for ( int r = 0 ; r < lineup . length ; r ++ ) { if ( excludedAssignments . get ( idx ) . equals ( lineup [ r ] ) ) { wout . write ( String . valueOf ( r + 1 ) ) ; found = true ; } } if ( ! found ) wout . write ( "-1" ) ; wout . write ( ";" ) ; wout . newLine ( ) ; } wout . flush ( ) ; } \n', 0.3733350726313076)

('public final void writeCSV ( final File file ) throws IOException { PrintWriter f = null ; try { f = new PrintWriter ( new FileWriter ( file ) ) ; for ( String el : list ) { f . println ( el ) ; } } catch ( IOException ex ) { throw ex ; } finally { if ( f != null ) { f . flush ( ) ; f . close ( ) ; } } } \n', 0.37297974138521883)

('public void writeCsv ( OutputStream out ) throws Exception { Writer writer = new OutputStreamWriter ( out ) ; Statement stmt = this . conn . createStatement ( ) ; ResultSet results = stmt . executeQuery ( "SELECT-*-from-usage_log" ) ; Csv . getInstance ( ) . write ( writer , results ) ; } \n', 0.37236269346788614)

('public String saveAsCsvASCIIString ( ) throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; saveAsCsvASCII ( baos ) ; return baos . toString ( ) ; } \n', 0.36316771079452614)

('public static void writeCSV ( List < double [ ] [ ] > epochs ) throws Exception { java . io . File file = new java . io . File ( "Epochs.csv" ) ; java . io . PrintWriter outfile = new java . io . PrintWriter ( file ) ; for ( double [ ] [ ] epoch : epochs ) { for ( int i = 0 ; i < epoch [ 2 ] . length ; i ++ ) { outfile . write ( epoch [ 2 ] [ i ] + "," ) ; } outfile . write ( "-" ) ; } outfile . close ( ) ; } \n', 0.3615257785390633)

('public void writeToCsv ( File csvFile ) throws IOException { PrintWriter pw = new PrintWriter ( csvFile , "UTF8" ) ; pw . println ( Wahlbewerber . tableHead ( new Character ( \';\' ) , new Character ( \'"\' ) ) ) ; for ( Wahlbewerber wb : this . bewerber ) { pw . println ( wb . toCsv ( new Character ( \';\' ) , new Character ( \'"\' ) ) ) ; } pw . close ( ) ; } \n', 0.3607634775724987)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 35 #################################
('public boolean isCheckBoxChecked ( int index ) { return checker . isButtonChecked ( CheckBox . class , index ) ; } \n', 0.40116223313751387)

('private void checkAll ( boolean checked ) { searchEnginesCheckboxListener . enable ( false ) ; for ( JCheckBox cBox : searchEngineCheckboxes ) { cBox . setSelected ( checked ) ; cBoxes . get ( cBox ) . setValue ( cBox . isSelected ( ) ) ; } searchEnginesCheckboxListener . enable ( true ) ; if ( ! checked ) { searchEngineCheckboxes . get ( 0 ) . setSelected ( true ) ; } } \n', 0.39119113923151666)

('public void check ( ) { getDispatcher ( ) . beforeCheck ( this ) ; RemoteWebElement e = ( RemoteWebElement ) getElement ( ) ; while ( ! e . isSelected ( ) ) { e . click ( ) ; } if ( Config . getBoolConfigProperty ( ConfigProperty . ENABLE_GUI_LOGGING ) ) { logUIAction ( UIActions . CHECKED ) ; } getDispatcher ( ) . afterCheck ( this ) ; }\n', 0.3898256310392757)

('public boolean isCheckBoxChecked ( String text ) { return checker . isButtonChecked ( CheckBox . class , text ) ; } \n', 0.38915318195231596)

('public static JCheckBox checkbox ( String text , final PropertyChangeBean bean , final String property ) { final JCheckBox checkbox = new JCheckBox ( text ) ; bean . addPropertyChangeListener ( property , new PropertyChangeListener ( ) { @ Override public void propertyChange ( PropertyChangeEvent evt ) { checkbox . setSelected ( ( boolean ) evt . getNewValue ( ) ) ; } } ) ; checkbox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { ReflectionUtils . setValue ( bean , property , checkbox . isSelected ( ) ) ; } } ) ; return checkbox ; } \n', 0.3860983005918478)

('public boolean isDeathCheckBoxChecked ( ) { return deathCheckBox . isSelected ( ) ; } \n', 0.38078060067706376)

('@ SuppressWarnings ( "unchecked" ) default boolean isChecked ( Supplier < By > selector ) { return new Checkbox < > ( ( T ) this , selector ) . isChecked ( ) ; } \n', 0.37809268689644926)

('public boolean isHPCheckBoxChecked ( ) { return hpCheckBox . isSelected ( ) ; } \n', 0.37801377980511974)

('private boolean isChecked ( Button checkbox ) { return ( ( checkbox != null ) && ( ! checkbox . isDisposed ( ) ) && ( checkbox . getSelection ( ) ) && ( ! checkbox . getGrayed ( ) ) ) ; } \n', 0.37408498724811057)

('public void checkForAllSelections ( ) { JCheckBox masterCheckbox = getMasterCheckbox ( ) ; if ( isAllSelected ( ) ) { if ( ! masterCheckbox . isSelected ( ) ) { masterCheckbox . setSelected ( true ) ; } } else { if ( masterCheckbox . isSelected ( ) ) { masterCheckbox . setSelected ( false ) ; } } } \n', 0.3721905150105631)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 36 #################################
('public void setTabText ( int index , String text ) { checkIndex ( index ) ; tabs . get ( index ) . setWidget ( new Label ( text ) ) ; } \n', 0.39578567274992327)

('private void setWidgetText ( org . eclipse . swt . widgets . Widget widget , String string ) { if ( widget instanceof Text ) { ( ( Text ) widget ) . setText ( string ) ; } else if ( widget instanceof Combo ) { ( ( Combo ) widget ) . setText ( string ) ; } else if ( widget instanceof CCombo ) { ( ( CCombo ) widget ) . setText ( string ) ; } else if ( widget instanceof Button ) { if ( string . equals ( ExporterTools . ATTR_ENABLE ) ) { ( ( Button ) widget ) . setSelection ( true ) ; } else { ( ( Button ) widget ) . setSelection ( false ) ; } } } \n', 0.366244831368142)

('protected Text findVisibleTextWidget ( final Composite composite ) { final Control [ ] children = composite . getChildren ( ) ; for ( final Control child : children ) { if ( child instanceof Text ) { final Text text = ( Text ) child ; if ( text . isVisible ( ) ) { return text ; } } else if ( child instanceof Composite ) { final Composite childComposite = ( Composite ) child ; final Text subresult = findVisibleTextWidget ( childComposite ) ; if ( subresult != null ) { return subresult ; } } } return null ; } \n', 0.36420104910743334)

('public static String extractWidgetLabel ( Component widget ) { String label = null ; if ( widget instanceof AbstractButton ) { label = ( ( AbstractButton ) widget ) . getText ( ) ; if ( label == null ) label = "" ; } return label ; } \n', 0.35765075012538367)

('void initLabel ( String label ) { formattedLabel = new AttributedString ( label ) ; formattedLabel . addAttribute ( TextAttribute . FONT , comDiaView . getFont ( ) ) ; formattedLabel . addAttribute ( TextAttribute . UNDERLINE , TextAttribute . UNDERLINE_ON ) ; } \n', 0.3574061125474781)

('public static void setTextWidgetValue ( Text widget , String text ) { if ( text == null ) { return ; } else { widget . setText ( text ) ; } } \n', 0.35251360219705896)

('public static void setTextWidgetValue ( Text widget , String text , String def ) { if ( text == null ) { if ( def != null ) { widget . setText ( def ) ; } return ; } else { widget . setText ( text ) ; } } \n', 0.3524460444086062)

('public Label getTextControl ( Composite parent ) { if ( textField == null ) { textField = new Label ( parent , SWT . NONE ) ; textField . setFont ( parent . getFont ( ) ) ; textField . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { textField = null ; } } ) ; } else { checkParent ( textField , parent ) ; } return textField ; } \n', 0.3491913737340837)

('public static void setStyledTextToWidget ( StyledText styledTextWidget , String htmlText ) { List < StyleRange > styleRangeList = new ArrayList < StyleRange > ( ) ; String text = "" ; for ( int counter = 0 ; counter < htmlText . length ( ) ; ) { int startIndex = htmlText . indexOf ( "<b>" , counter ) ; if ( startIndex >= 0 ) { final String readyText = htmlText . substring ( counter , startIndex ) ; text += readyText ; startIndex += 3 ; int endIndex = htmlText . indexOf ( "</b>" , startIndex ) ; final String boldText = htmlText . substring ( startIndex , endIndex ) ; endIndex += 4 ; final int boldStartIndex = text . length ( ) ; text += boldText ; styleRangeList . add ( new StyleRange ( boldStartIndex , boldText . length ( ) , null , null , SWT . BOLD ) ) ; counter = endIndex ; } else { text += htmlText . substring ( counter ) ; counter = htmlText . length ( ) ; } } styledTextWidget . setText ( text ) ; styledTextWidget . setStyleRanges ( styleRangeList . toArray ( new StyleRange [ styleRangeList . size ( ) ] ) ) ; } \n', 0.34511425228681325)

('public String getWidgetText ( Component w ) { if ( w instanceof AbstractButton ) { return ( ( ( AbstractButton ) w ) . getText ( ) ) ; } if ( w instanceof JLabel ) { return ( ( ( JLabel ) w ) . getText ( ) ) ; } return null ; } \n', 0.33860020270072355)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 37 #################################
('public static int convertToNumber ( String str , int fallback ) { try { if ( StringUtils . isEmpty ( str ) ) { return fallback ; } return Integer . valueOf ( str . trim ( ) ) ; } catch ( NumberFormatException ex ) { LOGGER . error ( "Could-not-parse-string-{}-as-number" , str , ex ) ; return fallback ; } } \n', 0.4172186775606706)

('public static String convertNumberToFriendlyString ( long number ) { int numDigits = String . valueOf ( number ) . length ( ) ; int numDigitsLeftover = numDigits % 3 ; if ( numDigitsLeftover == 0 ) { numDigitsLeftover = 3 ; } int precision = 4 - numDigitsLeftover ; return convertNumberToFriendlyString ( number , precision ) ; } \n', 0.40835450164816467)

('protected String convertBigNumber ( String numberAsString ) { String wholeWord = "" ; while ( numberAsString . length ( ) % 3 != 0 ) { numberAsString = "0" + numberAsString ; } int count = numberAsString . length ( ) / 3 ; for ( int i = 0 ; i < count ; i ++ ) { String place = numberNames [ count - i - 1 ] ; String word = convertHundreds ( numberAsString . substring ( i * 3 , i * 3 + 3 ) ) ; if ( word . length ( ) > 0 ) { wholeWord = wholeWord + "-" + word + "-" + place ; } } return wholeWord . trim ( ) ; } \n', 0.3871126395998713)

('protected Number convertToNumber ( String value , Class < ? extends Number > targetType , Locale locale ) throws ConversionException { if ( value == null ) { return null ; } value = value . trim ( ) ; ParsePosition parsePosition = new ParsePosition ( 0 ) ; Number parsedValue = getFormat ( locale ) . parse ( value , parsePosition ) ; if ( parsePosition . getIndex ( ) != value . length ( ) ) { throw new ConversionException ( "Could-not-convert-\'" + value + "\'-to-" + getModelType ( ) . getName ( ) ) ; } if ( parsedValue == null ) { return null ; } return parsedValue ; } \n', 0.38479405216693646)

('@ Override protected BigDecimal convertObjectToNumber ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return BigDecimal . ZERO ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToNumber ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToNumber ( sourceObject ) ; } \n', 0.3808780771587239)

('private static Object convertToNumber ( Object value ) { try { return Integer . parseInt ( String . valueOf ( value ) ) ; } catch ( NumberFormatException e ) { try { return Double . parseDouble ( String . valueOf ( value ) ) ; } catch ( NumberFormatException e2 ) { } } return value ; } \n', 0.37736934051313253)

('protected BigDecimal convertObjectToNumber ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return BigDecimal . ZERO ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToNumber ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToNumber ( sourceObject ) ; } \n', 0.3756330614695591)

('public static Number convertNumber ( String str ) throws NumberFormatException { if ( str . startsWith ( "+" ) ) { return new Integer ( str . substring ( 1 , str . length ( ) ) ) ; } if ( str . startsWith ( "0x" ) ) { return ( convertInt ( str . substring ( 2 ) , 16 ) ) ; } else if ( str . indexOf ( \'.\' ) != - 1 ) { Double dc = new Double ( str ) ; if ( ! str . endsWith ( "d" ) ) { double x = dc . doubleValue ( ) ; if ( x <= ( double ) Float . MAX_VALUE && x >= ( float ) Float . MIN_VALUE ) { return new Float ( ( float ) x ) ; } } return dc ; } else { return ( convertInt ( str , 10 ) ) ; } } \n', 0.37293676869248377)

('protected long convertToNumber ( final String num ) throws NumberFormatException { int base = 10 ; long multiplier = 1 ; String s ; char firstChar = num . charAt ( 0 ) ; char lastChar = num . charAt ( num . length ( ) - 1 ) ; if ( num . startsWith ( "0x" ) || num . startsWith ( "0X" ) ) { base = 16 ; s = num . substring ( 2 ) ; } else if ( lastChar == \'b\' ) { base = 2 ; s = num . substring ( 0 , num . length ( ) - 1 ) ; } else if ( lastChar == \'k\' ) { multiplier = 1024L ; s = num . substring ( 0 , num . length ( ) - 1 ) ; } else if ( lastChar == \'m\' ) { multiplier = 1048576L ; s = num . substring ( 0 , num . length ( ) - 1 ) ; } else if ( firstChar == \'0\' && num . length ( ) > 1 ) { base = 8 ; s = num . substring ( 1 ) ; } else { s = num ; } return Long . parseLong ( s , base ) * multiplier ; } \n', 0.3725150313063015)

('public static String convertNumberToString ( String input ) { if ( input . startsWith ( "+" ) ) input = input . substring ( 1 ) ; StringBuilder sb = new StringBuilder ( ) ; int i ; for ( i = 0 ; i < input . length ( ) ; i ++ ) { if ( input . charAt ( i ) == \'0\' ) sb . append ( "-" ) . append ( SIFIR ) . append ( "-" ) ; else { break ; } } String rest = input . substring ( i ) ; if ( rest . length ( ) == 0 ) { return sb . toString ( ) . trim ( ) ; } return ( Strings . whiteSpacesToSingleSpace ( sb . toString ( ) + "-" + convertToString ( Long . parseLong ( rest ) ) ) ) . trim ( ) ; } \n', 0.3692959762700865)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 38 #################################
('public static void saveInstancesInFiles ( Instances inst , int categrory ) throws IOException { String fileDesitination = "" ; switch ( categrory ) { case FeatureSelection . USER : fileDesitination = FeatureSelection . USER_SELECT_DES ; break ; case FeatureSelection . A1 : fileDesitination = FeatureSelection . A1_DES ; break ; case FeatureSelection . A2 : fileDesitination = FeatureSelection . A2_DES ; break ; case FeatureSelection . A3 : fileDesitination = FeatureSelection . A3_DES ; break ; default : fileDesitination = FeatureSelection . Test_DES ; break ; } BufferedWriter writer = new BufferedWriter ( new FileWriter ( fileDesitination ) ) ; writer . write ( inst . toString ( ) ) ; writer . flush ( ) ; writer . close ( ) ; } \n', 0.4251942453634263)

('public List < File > saveConfigurationFiles ( ) { List < File > failedList = new ArrayList < > ( ) ; for ( File f : extraFilesList ) { try { saveConfigurationFile ( f ) ; } catch ( IOException ex ) { failedList . add ( f ) ; } } return ( failedList . isEmpty ( ) ? null : failedList ) ; } \n', 0.4083003629221543)

('public static void saveFiles ( List < FileElement > files , String path ) { List < String > lines = new ArrayList < String > ( ) ; for ( FileElement fe : files ) { lines . add ( fe . toString ( ) ) ; } writeFile ( lines , path ) ; } \n', 0.40813709159242323)

('private void storeNewFilesList ( List < String > newFilesList ) throws IOException { BufferedWriter writer = null ; try { File newFiles = new File ( generator . getNuxeoHome ( ) , NEW_FILES ) ; writer = new BufferedWriter ( new FileWriter ( newFiles , false ) ) ; int index = generator . getNuxeoHome ( ) . getCanonicalPath ( ) . length ( ) + 1 ; for ( String filepath : newFilesList ) { writer . write ( new File ( filepath ) . getCanonicalPath ( ) . substring ( index ) ) ; writer . newLine ( ) ; } } finally { IOUtils . closeQuietly ( writer ) ; } } \n', 0.4073790241700428)

('public void saveAllChartsToFiles ( File outputDir ) throws IOException { if ( ! outputDir . isDirectory ( ) ) throw new IOException ( "saveAllChartsToFiles:-File-" + outputDir . getAbsolutePath ( ) + "-is-not-a-directory" ) ; if ( ! outputDir . exists ( ) || ! outputDir . canWrite ( ) ) throw new IOException ( "saveAllChartsToFiles:-nonexistent-or-unwriteable-directory-" + outputDir . getAbsolutePath ( ) ) ; for ( PanelWithChart pwc : getChartPanels ( ) ) pwc . saveChartToImageFile ( new File ( outputDir , createChartFileName ( pwc . getName ( ) ) ) ) ; } \n', 0.40099040267933145)

('public static void saveCollectionInFile ( Collection < String > collection , String filePathToStore , boolean isToUseQuotes ) { try { BufferedWriter writer = new BufferedWriter ( new FileWriter ( filePathToStore ) ) ; for ( String s : collection ) { if ( isToUseQuotes ) { writer . write ( """ + s + ""-" ) ; } else { writer . write ( s + "-" ) ; } } writer . close ( ) ; } catch ( IOException e ) { logger . error ( "IO-Error-occured" ) ; logger . error ( Helper . getStackTrace ( e ) ) ; } } \n', 0.4006728580382055)

('protected static void saveFileList ( ArrayList < DataHouse > list ) { File dest = IO . FileChooserRequest . getSelectedFile ( new String [ ] { ".sims" } , true ) ; if ( dest != null ) { boolean write = true ; String name = dest . getAbsolutePath ( ) ; if ( ! name . contains ( ".sims" ) ) name = name + ".sims" ; dest = new File ( name ) ; if ( dest . exists ( ) ) { int reply = javax . swing . JOptionPane . showConfirmDialog ( null , "Destination-file-already-exist.-Would-you-like-to-overwrite?" , "Requestion-Permission-to-Overwrite" , javax . swing . JOptionPane . YES_NO_OPTION ) ; write = reply == javax . swing . JOptionPane . YES_OPTION ? true : false ; } if ( write ) { ListIO . saveFileList ( list , name ) ; } } } \n', 0.39889320216587376)

('void saveFileList ( ) { try { File dir = new File ( "." ) ; for ( File file : dir . listFiles ( ) ) { if ( file . getName ( ) . endsWith ( ".files" ) ) { System . out . println ( "Deleting:-" + file . getName ( ) ) ; file . delete ( ) ; } } for ( String server : clientsFiles . keySet ( ) ) { FileWriter fw = new FileWriter ( new File ( server + ".files" ) ) ; for ( String file : clientsFiles . get ( server ) ) { fw . write ( file ) ; fw . write ( "-" ) ; } fw . close ( ) ; System . out . println ( "Writing:-" + server + ".files" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.3987272220865795)

('private static void saveFiles ( final List < String > contents , final File outputDirectory , final String outputName , final String fileExtension ) throws IOException { int index ; File directory ; File rooScriptFile ; FileWriter fileWriter ; directory = new File ( outputDirectory , outputName ) ; directory . mkdir ( ) ; index = 0 ; for ( String content : contents ) { index = index + 1 ; rooScriptFile = new File ( directory , "schema" + index + "." + fileExtension ) ; fileWriter = new FileWriter ( rooScriptFile , false ) ; fileWriter . write ( content ) ; fileWriter . close ( ) ; } } \n', 0.3973974959800747)

('protected void saveFiles ( ) { Iterator < String > iterator = ( Iterator < String > ) files . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { String fileName = ( String ) iterator . next ( ) ; Document doc = ( Document ) files . get ( fileName ) ; saveFile ( fileName , doc ) ; } } \n', 0.393918246019018)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 39 #################################
('public static void ConcatenateFiles ( ArrayList < String > inFilePaths , ArrayList < String > inFileDescriptions , String outFilePath , String headerComment ) throws Exception { StringBuffer out = new StringBuffer ( ) ; if ( headerComment != null && ! headerComment . equals ( "" ) ) out . append ( "#" + headerComment + "-" ) ; for ( int i = 0 ; i < inFilePaths . size ( ) ; i ++ ) { if ( inFileDescriptions != null ) out . append ( inFileDescriptions . get ( i ) ) ; out . append ( ReadTextFile ( inFilePaths . get ( i ) ) ) ; } FileUtilities . WriteTextToFile ( outFilePath , out . toString ( ) ) ; } \n', 0.27866470385535086)

('public static void concatenateFiles ( Collection < String > fileNames , String extension , String output ) throws IOException , InterruptedException { FileWriter w = new FileWriter ( output + extension ) ; for ( String file : fileNames ) { BufferedReader br = new BufferedReader ( new FileReader ( file + extension ) ) ; while ( br . ready ( ) ) { String line = br . readLine ( ) ; w . write ( line + "-" ) ; } br . close ( ) ; } w . close ( ) ; } \n', 0.2733419018934228)

('public static String concatenateFiles ( List < File > files ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; for ( File file : files ) { if ( sb . length ( ) > 0 ) sb . append ( "-" ) ; String fileContents = org . apache . commons . io . FileUtils . readFileToString ( file ) ; sb . append ( fileContents ) ; } return sb . toString ( ) ; } \n', 0.2718140570196329)

('public static ArrayList < String > concatenateParagraphTagLines ( ArrayList < ArrayList < String >> paragraphTagLines ) { ArrayList < String > paragraphTags = new ArrayList < > ( ) ; paragraphTagLines . stream ( ) . map ( ( paragraphTagLine ) -> concatenateStringArrayList ( paragraphTagLine ) ) . forEach ( ( paragraphTag ) -> { paragraphTags . add ( paragraphTag ) ; } ) ; return paragraphTags ; } \n', 0.26662453995990987)

('public static HashMap < String , String > readSOMLibFileHeaders ( BufferedReader br , String fileType ) throws IOException { HashMap < String , String > map = new HashMap < String , String > ( ) ; String line = null ; int lineNumber = 0 ; while ( ( line = br . readLine ( ) ) != null ) { lineNumber ++ ; line = line . trim ( ) ; if ( line . startsWith ( COMMENT_INDICATOR ) ) { Logger . getLogger ( "at.tuwien.ifs.somtoolbox" ) . finest ( "Read-comment-\'" + line + "\'." ) ; } else if ( line . startsWith ( "$" ) ) { StringTokenizer tokenizer = new StringTokenizer ( line , "-" ) ; String key = tokenizer . nextToken ( ) ; String value = null ; if ( tokenizer . hasMoreElements ( ) ) { value = tokenizer . nextToken ( "" ) . trim ( ) ; } else { Logger . getLogger ( "at.tuwien.ifs.somtoolbox" ) . severe ( "Header-in-" + fileType + "-file-corrupt!" ) ; throw new IOException ( "Header-in-" + fileType + "-file-corrupt!" ) ; } map . put ( key , value ) ; } else if ( line . length ( ) > 0 ) { map . put ( "FIRST_CONTENT_LINE" , line ) ; map . put ( "LINE_NUMBER" , String . valueOf ( lineNumber ) ) ; return map ; } } return map ; } \n', 0.24506773314627228)

('public void concatenateStreams ( final Reader [ ] readers , final File outputFile ) throws IOException { if ( outputFile == null ) { throw new IOException ( "outputFile-is-required-for-concatenation-of-files." ) ; } LOGGER . debug ( "Begining-stream-concatenation" ) ; List < Reader > readerList = Arrays . asList ( readers ) ; FileWriter outWriter = null ; DirectoryIO . createDir ( outputFile . getParentFile ( ) ) ; outputFile . createNewFile ( ) ; try { outWriter = new FileWriter ( outputFile ) ; for ( Reader listItem : readerList ) { FilteredReader fr = new FilteredReader ( listItem , "-" , "-" ) ; String line ; do { line = fr . readLine ( ) ; if ( line != null ) { outWriter . append ( line + "-" ) ; } } while ( line != null ) ; listItem . close ( ) ; } } finally { try { outWriter . close ( ) ; } catch ( Exception e ) { LOGGER . error ( "Unable-to-close-file.-This-should-not-matter" ) ; } } } \n', 0.24248356396675425)

('private static void concatenateFiles ( Collection < File > files , File resultFile ) { try { BufferedWriter out = null ; try { out = new BufferedWriter ( new FileWriter ( resultFile ) ) ; for ( File f : files ) { BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( f ) ) ; String s ; while ( ( s = in . readLine ( ) ) != null ) { out . write ( s ) ; out . newLine ( ) ; } } finally { if ( in != null ) { in . close ( ) ; } } } } finally { if ( out != null ) { out . close ( ) ; } } } catch ( IOException e ) { throw new IOFailure ( "Couldn\'t-combine-indexes-for-" + files . size ( ) + "-jobs-into-" + resultFile , e ) ; } } \n', 0.24005157620827192)

('public List < String > getAllHeaderLinesAsList ( ) { try { List < String > allHeaderLines = new ArrayList < String > ( ) ; Enumeration < ? > headerEnum = originMessage . getAllHeaders ( ) ; while ( headerEnum . hasMoreElements ( ) ) { Header currentHeader = ( Header ) headerEnum . nextElement ( ) ; String headerLine = currentHeader . getName ( ) + ":-" + currentHeader . getValue ( ) ; allHeaderLines . add ( headerLine ) ; } return allHeaderLines ; } catch ( MessagingException e ) { throw new RuntimeException ( "Konnte-Header-Lines-nicht-beziehen." , e ) ; } } \n', 0.23016231623448136)

('public static void concatenateFiles ( final File fileOutput , final File ... files ) throws IOException { if ( log . isDebugEnabled ( ) ) log . debug ( HelperLog . methodStart ( fileOutput , files ) ) ; if ( null == fileOutput ) { throw new RuntimeExceptionIsNull ( "fileOutput" ) ; } if ( null == files ) { throw new RuntimeExceptionIsNull ( "files" ) ; } if ( ! HelperArray . isValid ( files ) ) { throw new RuntimeExceptionIsEmpty ( "files" ) ; } PrintWriter pw = null ; try { pw = new PrintWriter ( new FileOutputStream ( fileOutput ) ) ; BufferedReader br = null ; for ( final File file : files ) { if ( null == file ) { throw new RuntimeExceptionIsNull ( "file" ) ; } if ( file . isFile ( ) ) { try { br = new BufferedReader ( new FileReader ( file ) ) ; String line = br . readLine ( ) ; while ( null != line ) { pw . println ( line ) ; line = br . readLine ( ) ; } } finally { if ( null != br ) { br . close ( ) ; } } } } } finally { if ( null != pw ) { pw . close ( ) ; } } if ( log . isDebugEnabled ( ) ) log . debug ( HelperLog . methodExit ( ) ) ; } \n', 0.23008309688395773)

('public static void concatenate ( List < File > files , File concatenatedFile ) { BufferedWriter writer ; try { writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( concatenatedFile . getAbsoluteFile ( ) , false ) , DataUtilDefaults . charSet ) ) ; FileInputStream inputStream ; for ( File input : files ) { inputStream = new FileInputStream ( input ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( inputStream , "UTF-8" ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { writer . write ( line + DataUtilDefaults . lineTerminator ) ; } inputStream . close ( ) ; } writer . flush ( ) ; writer . close ( ) ; } catch ( UnsupportedEncodingException e ) { throw new DataUtilException ( e ) ; } catch ( FileNotFoundException e ) { throw new DataUtilException ( e ) ; } catch ( IOException e ) { throw new DataUtilException ( e ) ; } }\n', 0.2271749070541083)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 40 #################################
('public static Map . Entry < Integer , String > replaceAllWeirdCharsFromFile ( String f ) throws IOException { Charset charset = Charset . forName ( "UTF-8" ) ; int weirdCharsCount = 0 ; Set < String > weirdCharsList = new HashSet < > ( ) ; String text = new String ( Files . readAllBytes ( Paths . get ( f ) ) , charset ) ; char [ ] textArray = text . toCharArray ( ) ; for ( int i = 0 ; i < textArray . length ; i ++ ) { if ( text . codePointAt ( i ) > 500 && i != 0 ) { textArray [ i ] = \'-\' ; weirdCharsList . add ( String . valueOf ( text . charAt ( i ) ) ) ; System . out . println ( i + "-" + text . charAt ( i ) + "-" + text . codePointAt ( i ) ) ; weirdCharsCount ++ ; } } text = String . valueOf ( textArray ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( Paths . get ( f . substring ( 0 , f . length ( ) - 4 ) + "_clean.srt" ) , charset ) ) { writer . write ( text ) ; writer . flush ( ) ; } catch ( EOFException e ) { Log . appendToInfoArea ( e . toString ( ) ) ; e . printStackTrace ( ) ; } return new AbstractMap . SimpleEntry < > ( weirdCharsCount , String . join ( ",-" , weirdCharsList ) ) ; } \n', 0.41923295526177545)

('public static String replaceFileExtension ( String fileName , String newExtension ) { String ext = getFileExtension ( fileName ) ; String newFileName ; if ( ext . equals ( "" ) ) { newFileName = fileName + "." + newExtension ; } else { newFileName = fileName . replaceAll ( "." + ext , newExtension ) ; } return newFileName ; } \n', 0.4126533666048869)

('private static int replaceInFile ( File file ) throws IOException { fileReplacements = 0 ; if ( ! checkAttributes ( file ) ) { return fileReplacements ; } String original ; try { original = FileUtils . readFileToString ( file ) ; } catch ( IOException e ) { System . err . println ( "Error-reading-" + file . getCanonicalPath ( ) ) ; System . err . println ( e . getMessage ( ) ) ; return fileReplacements ; } String contents = original ; contents = replaceInPattern ( contents ) ; if ( ! contents . equals ( original ) ) { if ( ! file . canWrite ( ) ) { file . setReadable ( true , false ) ; System . out . println ( "Making-file-writable:-" + file . getCanonicalPath ( ) ) ; } if ( ! file . canWrite ( ) ) { System . err . println ( "Could-not-make-file-writable:-" + file . getCanonicalPath ( ) ) ; } else { FileUtils . writeStringToFile ( file , contents ) ; filesModified ++ ; } System . out . println ( file . getAbsolutePath ( ) + "-" + fileReplacements + "-replacements" ) ; } filesScanned ++ ; return fileReplacements ; } \n', 0.4024448847939923)

('private void replaceFile ( final File file ) throws Exception { lg . cetak ( "" ) ; lg . debug1 ( "" ) ; String content = FileUtils . readTextFile ( file . getPath ( ) ) ; Matcher matcher = pattern . matcher ( content ) ; boolean b = true ; int nbFound = 0 ; int start = 0 ; while ( b ) { b = matcher . find ( start ) ; if ( b ) { nbFound ++ ; start = matcher . end ( ) ; } } if ( nbFound > 0 ) { nbFilesChanged ++ ; nbReplacements += nbFound ; log . info ( "Found-" + nbFound + "-occurrence" + ( nbFound > 1 ? "s" : "" ) + "-of-the-sequence-in-file-\'" + file + \'|\'\' ) ; String s = matcher . replaceAll ( dest ) ; if ( debugEnabled ) { log . debug ( "Content-with-replacements-performed:-" + s ) ; } if ( ! searchOnly ) { FileUtils . writeTextFile ( file . getPath ( ) , s ) ; } } else if ( debugEnabled ) { log . debug ( "Sequence-not-found-in-file-\'" + file + \'|\'\' ) ; } } \n', 0.40232175006408133)

('public void replaceTextInFile ( String filePath , String oldString , String newString ) throws IOException { Path path = Paths . get ( filePath ) ; Charset charset = StandardCharsets . UTF_8 ; String content = new String ( Files . readAllBytes ( path ) , charset ) ; content = content . replaceAll ( oldString , newString ) ; Files . write ( path , content . getBytes ( charset ) ) ; } \n', 0.3996224958995062)

('protected int replaceInputFile ( ) { final File inputFile = INPUT . getAbsoluteFile ( ) ; final File oldFile = new File ( inputFile . getParentFile ( ) , inputFile . getName ( ) + ".old" ) ; if ( ! oldFile . exists ( ) && inputFile . renameTo ( oldFile ) ) { if ( OUTPUT . renameTo ( inputFile ) ) { if ( ! oldFile . delete ( ) ) { System . err . println ( "Could-not-delete-old-file-:-" + oldFile . getAbsolutePath ( ) ) ; return 1 ; } } else { System . err . println ( "Could-not-move-temp-file-to-:-" + inputFile . getAbsolutePath ( ) ) ; System . err . println ( "Input-file-preserved-as-:-" + oldFile . getAbsolutePath ( ) ) ; System . err . println ( "New-file-preserved-as-:-" + OUTPUT . getAbsolutePath ( ) ) ; return 1 ; } } else { System . err . println ( "Could-not-move-input-file-:-" + inputFile . getAbsolutePath ( ) ) ; System . err . println ( "New-file-preserved-as-:-" + OUTPUT . getAbsolutePath ( ) ) ; return 1 ; } return 0 ; } \n', 0.39689951522513833)

('private int replaceInputFile ( ) { final File inputFile = INPUT . getAbsoluteFile ( ) ; final File oldFile = new File ( inputFile . getParentFile ( ) , inputFile . getName ( ) + ".old" ) ; if ( ! oldFile . exists ( ) && inputFile . renameTo ( oldFile ) ) { if ( OUTPUT . renameTo ( inputFile ) ) { if ( ! oldFile . delete ( ) ) { System . err . println ( "Could-not-delete-old-file-:-" + oldFile . getAbsolutePath ( ) ) ; return 1 ; } } else { System . err . println ( "Could-not-move-temp-file-to-:-" + inputFile . getAbsolutePath ( ) ) ; System . err . println ( "Input-file-preserved-as-:-" + oldFile . getAbsolutePath ( ) ) ; System . err . println ( "New-file-preserved-as-:-" + OUTPUT . getAbsolutePath ( ) ) ; return 1 ; } } else { System . err . println ( "Could-not-move-input-file-:-" + inputFile . getAbsolutePath ( ) ) ; System . err . println ( "New-file-preserved-as-:-" + OUTPUT . getAbsolutePath ( ) ) ; return 1 ; } return 0 ; } \n', 0.39689951522513833)

('private static String replaceFileNameDangerousCharacters ( final String name ) { final StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < name . length ( ) ; ++ i ) { final int codePoint = name . codePointAt ( i ) ; if ( isFileNameCharacter ( codePoint ) ) { sb . appendCodePoint ( codePoint ) ; } else { sb . append ( String . format ( ( Locale ) null , "%%%1$06x" , codePoint ) ) ; } } return sb . toString ( ) ; } \n', 0.39029367588004754)

("public static String sanitizeFileName ( String fileName ) { if ( fileName == null ) { return null ; } return hudson . Util . fixEmptyAndTrim ( fileName . replace ( '+' , '_' ) . replace ( '&' , '_' ) ) ; } \n", 0.3878686718142812)

('public static void replaceStringsInFile ( String filePath , Map < String , String > substitution ) { Path path = Paths . get ( filePath ) ; Charset charset = StandardCharsets . UTF_8 ; String content ; try { content = new String ( Files . readAllBytes ( path ) , charset ) ; for ( String s : substitution . keySet ( ) ) { content = content . replaceAll ( Matcher . quoteReplacement ( s ) , substitution . get ( s ) ) ; } Files . write ( path , content . getBytes ( charset ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.38767252662120927)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 41 #################################
('protected void plotData ( Rectangle plotRect , Graphics2D g2 ) { if ( data == null ) return ; double boxHeight = plotRect . getHeight ( ) / rows ; double boxWidth = plotRect . getWidth ( ) / cols ; for ( int row = 0 ; row < data . length ; row ++ ) { int yPos = ( int ) Math . round ( plotRect . getY ( ) + ( row * boxHeight ) ) ; for ( int col = 0 ; col < data [ row ] . length ; col ++ ) { int xPos = ( int ) Math . round ( plotRect . getX ( ) + ( col * boxWidth ) ) ; int value ; if ( data [ row ] [ col ] < 0 ) value = 0 ; else value = ( int ) Math . round ( 255f * ( data [ row ] [ col ] - minVal ) / ( maxVal - minVal ) ) ; Color c = new Color ( ( 255 - value ) , ( 255 - value ) , ( 255 - value ) ) ; g2 . setColor ( c ) ; g2 . fill ( new Rectangle ( xPos , yPos , ( int ) ( boxWidth + 1 ) , ( int ) ( boxHeight + 1 ) ) ) ; } } } \n', 0.2852176352577874)

('private void plotRangeRings ( final Graphics g ) { int topLeftX = 1 ; int topLeftY = 1 ; int centerX = this . width / 2 ; int centerY = this . height / 2 ; int currXOffset = 0 ; int currYOffset = 0 ; int currDistance = 0 ; while ( currDistance <= Math . max ( config . getPlotRange ( ) , 150 ) ) { currXOffset = getPixelsFromKm ( currDistance ) ; currYOffset = getPixelsFromKm ( currDistance ) ; topLeftX = centerX - currXOffset ; topLeftY = centerY - currYOffset ; g . drawOval ( topLeftX + offsetX , topLeftY + offsetY , 2 * currXOffset , 2 * currYOffset ) ; g . drawString ( String . valueOf ( currDistance ) , centerX + offsetX + currXOffset + 1 , centerY + offsetY + 11 ) ; g . drawString ( String . valueOf ( currDistance ) , centerX + offsetX - currXOffset + 1 , centerY + offsetY + 11 ) ; currDistance += config . getGridSpacing ( ) ; } } \n', 0.28072104156967)

('public static PlotCanvas plot ( double [ ] [ ] [ ] data ) { return plot ( null , data ) ; } \n', 0.2739787061023454)

('protected void plotData ( Rectangle plotRect , Graphics2D g2 ) { if ( data == null ) return ; double boxHeight = plotRect . getHeight ( ) / rows ; double boxWidth = plotRect . getWidth ( ) / cols ; for ( int row = 0 ; row < data . length ; row ++ ) { int yPos = ( int ) Math . round ( plotRect . getY ( ) + ( row * boxHeight ) ) ; for ( int col = 0 ; col < data [ row ] . length ; col ++ ) { int xPos = ( int ) Math . round ( plotRect . getX ( ) + ( col * boxWidth ) ) ; int value ; if ( data [ row ] [ col ] < 0 ) value = 0 ; else value = ( int ) Math . round ( 255f * ( data [ row ] [ col ] - minVal ) / ( maxVal - minVal ) ) ; Color c ; if ( col < ( currFrame ) ) { c = new Color ( ( 255 - value ) , ( 255 - value ) , ( 255 - value ) ) ; } else if ( col == ( currFrame ) ) { c = new Color ( value , 200 , 200 ) ; } else { c = Color . BLACK ; } g2 . setColor ( c ) ; g2 . fill ( new Rectangle ( xPos , yPos , ( int ) ( boxWidth + 1 ) , ( int ) ( boxHeight + 1 ) ) ) ; } } } \n', 0.2730485762656025)

('protected void plotCompetitors ( Rectangle plotRect , Graphics2D g2 ) { if ( competitionData == null || data == null ) return ; double boxHeight = plotRect . getHeight ( ) / rows ; double boxWidth = plotRect . getWidth ( ) / cols ; for ( int i = 0 ; i < competitionData . length ; i ++ ) { int yPos = ( int ) Math . round ( plotRect . getY ( ) + ( i * boxHeight ) ) ; int xPos = ( int ) Math . round ( plotRect . getX ( ) + ( competitionData [ i ] [ 1 ] * boxWidth ) ) ; double value = ( ( double ) competitionData [ i ] [ 2 ] / ( double ) 100 ) ; if ( i == focusRow ) g2 . setColor ( Color . GREEN ) ; else { g2 . setColor ( new Color ( 255 , 200 - ( int ) ( value * 200d ) , 0 ) ) ; } g2 . fill ( new Rectangle ( xPos , yPos , ( int ) ( boxWidth + 1 ) , ( int ) ( boxHeight + 1 ) ) ) ; } } \n', 0.27225812154690493)

('public static String plotUIP ( double U , double I ) { return plotVolt ( "U" , U ) + plotAmpere ( "I" , I ) + plotPower ( "P" , Math . abs ( U * I ) ) ; } \n', 0.2682562428044602)

('@ Override protected void drawPlot ( Graphics g ) { drawClassBackground ( g ) ; super . drawPlot ( g ) ; if ( multipleSelectionColors != null ) { for ( int i = 0 ; i < dataX . length ; i ++ ) { if ( multipleSelectionColors [ i ] != null ) { g . setColor ( foreground ) ; g . drawOval ( exsint [ i ] - 1 , whyint [ i ] - 1 , pointSize , pointSize ) ; } } } } \n', 0.2637209566624664)

('void plotLine ( int x1 , int y1 , int x2 , int y2 , Color color ) { if ( bg == null ) return ; bg . setColor ( color ) ; bg . drawLine ( x1 , y1 , x2 , y2 ) ; drawPlot ( ) ; } \n', 0.26113608961561163)

('private static void plotBackground ( final Graphics graphics ) { graphics . setColor ( Color . WHITE ) ; graphics . fillRect ( 0 , FRAME_HEIGHT - MAX_GRAPHIC_HEIGHT - OFFSET , FRAME_WIDTH , FRAME_HEIGHT ) ; graphics . setColor ( Color . BLACK ) ; final int timeStepForPlotAxisVertical = FRAME_WIDTH / 8 ; for ( int i = 0 ; i < FRAME_WIDTH ; i += timeStepForPlotAxisVertical ) { graphics . drawLine ( i , FRAME_HEIGHT - MAX_GRAPHIC_HEIGHT - OFFSET , i , FRAME_HEIGHT ) ; } final int timeStepForPlotAxisHorizontal = ( MAX_GRAPHIC_HEIGHT + OFFSET ) / 8 ; for ( int i = FRAME_HEIGHT - MAX_GRAPHIC_HEIGHT - OFFSET ; i < FRAME_HEIGHT ; i += timeStepForPlotAxisHorizontal ) { graphics . drawLine ( 0 , i , FRAME_WIDTH , i ) ; } } \n', 0.2597750270656053)

('public static void plotArray ( Comparable [ ] a ) { double [ ] tmpArray = new double [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) { String tmp1 = ( String ) a [ i ] ; tmp1 = tmp1 . toUpperCase ( ) ; char tmp2 = tmp1 . charAt ( 0 ) ; tmpArray [ i ] = ( double ) tmp2 / 100 ; } plotBars ( tmpArray ) ; } \n', 0.25974858769941755)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 42 #################################
('private static List extractZipEntries ( final ZipFile zipFile ) { final List entryList = new ArrayList ( 100 ) ; final Enumeration enumeration = zipFile . entries ( ) ; while ( enumeration . hasMoreElements ( ) ) { entryList . add ( enumeration . nextElement ( ) ) ; } return entryList ; } \n', 0.42679334068071345)

('protected void extractPluginFiles ( ) throws Exception { if ( isExtractNeeded ( ) ) { if ( extractionDirectory . exists ( ) ) { FileUtils . deleteDirectory ( extractionDirectory ) ; } if ( ! extractionDirectory . mkdir ( ) ) { throw new WorkflowRuntimeException ( "Could-not-create-the-extraction-directory-for-the-plugin:-" + extractionDirectory . getAbsolutePath ( ) ) ; } ZipFile zipFile = new ZipFile ( pluginZipFile , ZipFile . OPEN_READ ) ; for ( Enumeration entries = zipFile . entries ( ) ; entries . hasMoreElements ( ) ; ) { ZipEntry entry = ( ZipEntry ) entries . nextElement ( ) ; File entryFile = new File ( extractionDirectory + java . io . File . separator + entry . getName ( ) ) ; if ( entry . isDirectory ( ) ) { if ( ! entryFile . mkdir ( ) ) { throw new WorkflowRuntimeException ( "Failed-to-create-directory:-" + entryFile . getAbsolutePath ( ) ) ; } continue ; } InputStream is = null ; OutputStream os = null ; try { is = new BufferedInputStream ( zipFile . getInputStream ( entry ) ) ; os = new BufferedOutputStream ( new FileOutputStream ( entryFile ) ) ; while ( is . available ( ) > 0 ) { os . write ( is . read ( ) ) ; } } finally { if ( os != null ) { os . close ( ) ; } if ( is != null ) { is . close ( ) ; } } } } } \n', 0.4262977380096596)

('public static final void extractJAR ( File zFile , String extractDir ) throws IOException { File extractFile = new File ( extractDir ) ; if ( ! extractFile . exists ( ) ) { extractFile . mkdirs ( ) ; } if ( ! zFile . exists ( ) ) { throw new IOException ( zFile + "-does-not-exist." ) ; } ZipFile zipFile = new ZipFile ( zFile ) ; try { Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; byte [ ] buf = new byte [ BUFFER_LENGTH ] ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; String entryName = entry . getName ( ) ; if ( entryName . startsWith ( "META-INF" ) ) { continue ; } File entryFile = new File ( extractDir , entryName ) ; if ( entry . isDirectory ( ) ) { entryFile . mkdirs ( ) ; continue ; } entryFile . getParentFile ( ) . mkdirs ( ) ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( entryFile ) ; int len ; InputStream is = zipFile . getInputStream ( entry ) ; while ( ( len = is . read ( buf , 0 , BUFFER_LENGTH ) ) > - 1 ) { fos . write ( buf , 0 , len ) ; } } finally { fos . close ( ) ; } } } finally { zipFile . close ( ) ; } } \n', 0.41844248262249006)

('public final void extractFolder ( final String zipFile ) throws ZipException , IOException { int BUFFER = 2048 ; File file = new File ( zipFile ) ; ZipFile zip = new ZipFile ( file ) ; String newPath = zipFile . substring ( 0 , zipFile . length ( ) - 4 ) ; new File ( newPath ) . mkdir ( ) ; Enumeration zipFileEntries = zip . entries ( ) ; while ( zipFileEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipFileEntries . nextElement ( ) ; String currentEntry = entry . getName ( ) ; File destFile = new File ( newPath , currentEntry ) ; File destinationParent = destFile . getParentFile ( ) ; destinationParent . mkdirs ( ) ; if ( ! entry . isDirectory ( ) ) { BufferedInputStream is = new BufferedInputStream ( zip . getInputStream ( entry ) ) ; int currentByte ; byte data [ ] = new byte [ BUFFER ] ; FileOutputStream fos = new FileOutputStream ( destFile ) ; BufferedOutputStream dest = new BufferedOutputStream ( fos , BUFFER ) ; while ( ( currentByte = is . read ( data , 0 , BUFFER ) ) != - 1 ) { dest . write ( data , 0 , currentByte ) ; } dest . flush ( ) ; dest . close ( ) ; is . close ( ) ; } if ( currentEntry . endsWith ( ".zip" ) ) { extractFolder ( destFile . getAbsolutePath ( ) ) ; } } } \n', 0.4166917805259942)

('public static String extractZip ( File zipArchive , String outputDir ) { try { String rootDirectoryPath = null ; ZipFile zipFile = new ZipFile ( zipArchive ) ; Enumeration < ? > enu = zipFile . entries ( ) ; while ( enu . hasMoreElements ( ) ) { ZipEntry zipEntry = ( ZipEntry ) enu . nextElement ( ) ; String name = zipEntry . getName ( ) ; long size = zipEntry . getSize ( ) ; long compressedSize = zipEntry . getCompressedSize ( ) ; System . out . printf ( "name:-%-20s-|-size:-%6d-|-compressed-size:-%6d-" , name . substring ( 0 , name . indexOf ( \'/\' ) ) , size , compressedSize ) ; if ( rootDirectoryPath == null ) { rootDirectoryPath = name . substring ( 0 , name . indexOf ( \'/\' ) ) ; } File file = new File ( outputDir , name ) ; if ( name . endsWith ( "/" ) ) { file . mkdirs ( ) ; continue ; } File parent = file . getParentFile ( ) ; if ( parent != null ) { parent . mkdirs ( ) ; } InputStream is = zipFile . getInputStream ( zipEntry ) ; FileOutputStream fos = new FileOutputStream ( file ) ; byte [ ] bytes = new byte [ 1024 ] ; int length ; while ( ( length = is . read ( bytes ) ) >= 0 ) { fos . write ( bytes , 0 , length ) ; } is . close ( ) ; fos . close ( ) ; } zipFile . close ( ) ; return rootDirectoryPath ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } } \n', 0.4103092891729835)

('public static void extractAll ( ZipFile zip , File dest , boolean overwrite ) throws IOException { if ( dest . isFile ( ) ) { if ( overwrite ) { if ( ! dest . delete ( ) ) { throw new IOException ( "Failed-to-delete-existing-file-at-" + dest . getPath ( ) ) ; } } else { throw new IOException ( "Failed-to-extract-to-" + dest . getPath ( ) + "---already-exists-as-regular-file" ) ; } } Enumeration < ? extends ZipEntry > entries = zip . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; try { extract ( zip , entry , new File ( dest , entry . getName ( ) ) , overwrite ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; System . err . println ( "Failed-to-extract-" + entry . getName ( ) ) ; } } } \n', 0.4079068162259879)

('private static File extractZipFile ( File sourceFile ) throws IOException { File tempDir = File . createTempFile ( "owlapi-project" , "" ) ; tempDir . mkdir ( ) ; ZipFile zipFile = new ZipFile ( sourceFile ) ; Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry zipEntry = entries . nextElement ( ) ; if ( zipEntry . isDirectory ( ) ) { File dir = new File ( tempDir , zipEntry . getName ( ) ) ; dir . mkdirs ( ) ; } else { InputStream is = zipFile . getInputStream ( zipEntry ) ; int bufferSize = 10 * 1024 * 1024 ; BufferedInputStream bis = new BufferedInputStream ( is , bufferSize ) ; File entryFile = new File ( tempDir , zipEntry . getName ( ) ) ; entryFile . getParentFile ( ) . mkdirs ( ) ; FileOutputStream fos = new FileOutputStream ( entryFile ) ; BufferedOutputStream bos = new BufferedOutputStream ( fos ) ; byte [ ] buffer = new byte [ bufferSize ] ; while ( true ) { int read = bis . read ( buffer ) ; if ( read == - 1 ) { break ; } bos . write ( buffer , 0 , read ) ; if ( read < buffer . length ) { break ; } } bis . close ( ) ; bos . close ( ) ; } } return tempDir ; } \n', 0.4071921254880825)

('public static List < File > extractFilesFromZIP ( File zipFilename , File outputDir , boolean filesWithAbsolutePath ) throws IOException { ZipInputStream zipInputStream = new ZipInputStream ( new FileInputStream ( zipFilename ) ) ; ZipEntry zipEntry = zipInputStream . getNextEntry ( ) ; if ( zipEntry == null ) { zipInputStream . close ( ) ; throw new IOException ( "No-files-inside-ZIP" ) ; } else { List < File > extractedFiles = new ArrayList < File > ( ) ; while ( zipEntry != null ) { String entryName = zipEntry . getName ( ) ; logger . debug ( "Extracting-" + entryName ) ; File newFile = new File ( outputDir , entryName ) ; if ( filesWithAbsolutePath ) { extractedFiles . add ( newFile ) ; } else { extractedFiles . add ( new File ( entryName ) ) ; } if ( zipEntry . isDirectory ( ) ) { newFile . mkdirs ( ) ; } else { if ( newFile . getParentFile ( ) != null && ( ! newFile . getParentFile ( ) . exists ( ) ) ) { newFile . getParentFile ( ) . mkdirs ( ) ; } FileOutputStream newFileOutputStream = new FileOutputStream ( newFile ) ; IOUtils . copyLarge ( zipInputStream , newFileOutputStream ) ; newFileOutputStream . close ( ) ; zipInputStream . closeEntry ( ) ; } zipEntry = zipInputStream . getNextEntry ( ) ; } zipInputStream . close ( ) ; return extractedFiles ; } } \n', 0.4071647156098561)

('public static void extractZipArchive ( File zipFile , File targetDirectory , String entryPattern , String removedEntryPrefix ) throws IOException { if ( zipFile == null || targetDirectory == null ) throw new IllegalArgumentException ( "The-ZIP-file-and-the-target-directory-cannot-be-null." ) ; if ( ! zipFile . isFile ( ) ) throw new IllegalArgumentException ( "ZIP-file-" + targetDirectory . getName ( ) + "-does-not-exist." ) ; if ( targetDirectory . exists ( ) && ! targetDirectory . isDirectory ( ) ) throw new IllegalArgumentException ( "Target-directory-" + targetDirectory . getName ( ) + "-is-not-a-directory." ) ; Utils . createDirectory ( targetDirectory ) ; ZipFile theZipFile = new ZipFile ( zipFile ) ; Enumeration < ? extends ZipEntry > entries = theZipFile . entries ( ) ; try { while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; String suffix = entry . getName ( ) ; if ( entryPattern != null && ! suffix . matches ( entryPattern ) ) continue ; if ( removedEntryPrefix != null && suffix . startsWith ( removedEntryPrefix ) ) suffix = suffix . substring ( removedEntryPrefix . length ( ) ) ; if ( isEmptyOrWhitespaces ( suffix ) ) continue ; File f = new File ( targetDirectory , suffix ) ; if ( entry . isDirectory ( ) ) { Utils . createDirectory ( f ) ; } else { Utils . createDirectory ( f . getParentFile ( ) ) ; copyStream ( theZipFile . getInputStream ( entry ) , f ) ; } } } finally { theZipFile . close ( ) ; } } \n', 0.4050441893718282)

('public static List < String > extractZip ( ZipFile zip , File outputDir , StringFilter filter ) throws IOException { final ArrayList < String > files = new ArrayList < > ( ) ; if ( ! outputDir . mkdirs ( ) ) throw new IOException ( "Could-not-create-output-directory." ) ; final Enumeration < ? extends ZipEntry > zipFileEntries = zip . entries ( ) ; while ( zipFileEntries . hasMoreElements ( ) ) { final ZipEntry entry = zipFileEntries . nextElement ( ) ; final String entryPath = entry . getName ( ) ; final File destFile = new File ( outputDir , entryPath ) ; final File destinationParent = destFile . getParentFile ( ) ; if ( entry . isDirectory ( ) || ( filter != null && ! filter . isValid ( entryPath ) ) ) continue ; if ( ! destinationParent . mkdirs ( ) ) throw new IOException ( "Could-not-create-directory." ) ; if ( ! entry . isDirectory ( ) ) { extractZipEntry ( zip , entry , destFile ) ; files . add ( entryPath ) ; } } return files ; } \n', 0.40444430188822245)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 43 #################################
('protected Map < String , Object > parseFile ( File file ) throws IOException { if ( file == null ) { return Collections . emptyMap ( ) ; } else if ( ! file . isFile ( ) || ! file . canRead ( ) ) { throw new IOException ( String . format ( "%s-is-not-a-readable-file" , file . getAbsolutePath ( ) ) ) ; } else { try { return new Gson ( ) . fromJson ( new FileReader ( file ) , new TypeToken < Map < String , Object >> ( ) { } . getType ( ) ) ; } catch ( JsonSyntaxException e ) { throw new AmbariException ( String . format ( "Failed-to-parse-JSON-formatted-file:-%s" , file . getAbsolutePath ( ) ) , e ) ; } } } \n', 0.4267684919696004)

('public static Map < String , String > parsePropertyFile ( File buildProp , ISdkLog log ) { FileInputStream fis = null ; BufferedReader reader = null ; try { fis = new FileInputStream ( buildProp ) ; reader = new BufferedReader ( new InputStreamReader ( fis , SdkConstants . INI_CHARSET ) ) ; String line = null ; Map < String , String > map = new HashMap < String , String > ( ) ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) > 0 && line . charAt ( 0 ) != \'#\' ) { Matcher m = PATTERN_PROP . matcher ( line ) ; if ( m . matches ( ) ) { map . put ( m . group ( 1 ) , m . group ( 2 ) ) ; } else { if ( log != null ) { log . warning ( "Error-parsing-\'%1$s\':-"%2$s"-is-not-a-valid-syntax" , buildProp . getAbsolutePath ( ) , line ) ; } return null ; } } } return map ; } catch ( FileNotFoundException e ) { } catch ( IOException e ) { if ( log != null ) { log . warning ( "Error-parsing-\'%1$s\':-%2$s." , buildProp . getAbsolutePath ( ) , e . getMessage ( ) ) ; } } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { } } } return null ; } \n', 0.42265297915012673)

('private Object parseFile ( File file , String scharset ) { Charset charset = scharset == null || scharset . length ( ) == 0 ? StandardCharsets . UTF_8 : Charset . forName ( scharset ) ; if ( file . length ( ) > ) { try ( Reader reader = Files . newBufferedReader ( IO . path ( file . toString ( ) ) , charset ) ) { return parse ( reader ) ; } catch ( IOException ioe ) { throw new JsonException ( "Unable-to-process-file:-" + file . getPath ( ) , ioe ) ; } } else { try { return JsonFactory . create ( ) . fromJson ( Files . newBufferedReader ( IO . path ( file . toString ( ) ) , charset ) ) ; } catch ( IOException e ) { throw new JsonException ( "Unable-to-process-file:-" + file . getPath ( ) , e ) ; } } } \n', 0.41726749414195474)

('public List < LdifEntry > parseLdifFile ( String fileName , String encoding ) throws LdapLdifException { if ( Strings . isEmpty ( fileName ) ) { LOG . error ( I18n . err ( I18n . ERR_12064_EMPTY_FILE_NAME ) ) ; throw new LdapLdifException ( I18n . err ( I18n . ERR_12064_EMPTY_FILE_NAME ) ) ; } File file = new File ( fileName ) ; if ( ! file . exists ( ) ) { LOG . error ( I18n . err ( I18n . ERR_12066 , fileName ) ) ; throw new LdapLdifException ( I18n . err ( I18n . ERR_12067 , fileName ) ) ; } BufferedReader bufferReader = null ; try { bufferReader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , Charset . forName ( encoding ) ) ) ; return parseLdif ( bufferReader ) ; } catch ( FileNotFoundException fnfe ) { LOG . error ( I18n . err ( I18n . ERR_12068 , fileName ) ) ; throw new LdapLdifException ( I18n . err ( I18n . ERR_12067 , fileName ) , fnfe ) ; } catch ( LdapException le ) { throw new LdapLdifException ( le . getMessage ( ) , le ) ; } finally { try { if ( bufferReader != null ) { bufferReader . close ( ) ; } } catch ( IOException ioe ) { } } } \n', 0.41663823673040407)

('public static DocumentContext parse ( File json , Configuration configuration ) throws IOException { return new ParseContextImpl ( configuration ) . parse ( json ) ; }\n', 0.41602598949862307)

('public Schema parse ( String s ) { try { return parse ( FACTORY . createJsonParser ( new StringReader ( s ) ) ) ; } catch ( IOException e ) { throw new SchemaParseException ( e ) ; } } \n', 0.4080879541717049)

('private static ArrayList < String > parseJsonData ( String path ) throws IOException { FileInputStream fstream = new FileInputStream ( path ) ; DataInputStream in = new DataInputStream ( fstream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String strLine ; StringBuilder sb = new StringBuilder ( ) ; ArrayList < String > strings = new ArrayList < > ( ) ; while ( ( strLine = br . readLine ( ) ) != null ) { sb . append ( strLine ) ; if ( strLine . equals ( "" ) ) { strLine = sb . toString ( ) ; strings . add ( strLine ) ; sb = new StringBuilder ( ) ; } } strLine = sb . toString ( ) ; strings . add ( strLine ) ; br . close ( ) ; return strings ; } \n', 0.4078233608597779)

('public static JSONObject parseSourceFile ( String source , JSONParser jsonParser ) { String jsonSectionPrefix = FORM_PROPERTIES_PREFIX + "$JSON-" ; int beginningOfJsonSection = source . lastIndexOf ( jsonSectionPrefix ) ; if ( beginningOfJsonSection == - 1 ) { throw new IllegalArgumentException ( "Unable-to-parse-file---cannot-locate-beginning-of-$JSON-section" ) ; } beginningOfJsonSection += jsonSectionPrefix . length ( ) ; String jsonSectionSuffix = FORM_PROPERTIES_SUFFIX ; int endOfJsonSection = source . lastIndexOf ( jsonSectionSuffix ) ; if ( endOfJsonSection == - 1 ) { throw new IllegalArgumentException ( "Unable-to-parse-file---cannot-locate-end-of-$JSON-section" ) ; } String jsonPropertiesString = source . substring ( beginningOfJsonSection , endOfJsonSection ) ; return jsonParser . parse ( jsonPropertiesString ) . asObject ( ) ; } \n', 0.40555424028985043)

('public static List < MapRecord > parseAsMap ( File jsonFile , DocIdGenerator generator ) throws FileNotFoundException , IOException , JsonSyntaxException { Preconditions . checkNotNull ( jsonFile ) ; Preconditions . checkArgument ( jsonFile . exists ( ) && jsonFile . isFile ( ) && jsonFile . canRead ( ) , jsonFile + "-is-not-a-readable-file" ) ; Preconditions . checkNotNull ( generator ) ; final StringBuilder sb = new StringBuilder ( 128 ) ; FileReader fileReader = new FileReader ( jsonFile ) ; BufferedReader bufReader = new BufferedReader ( fileReader ) ; String line ; while ( ( line = bufReader . readLine ( ) ) != null ) { sb . append ( line ) ; } bufReader . close ( ) ; String json = sb . toString ( ) ; return parseAsMap ( json , generator ) ; } \n', 0.40080500894366766)

('public static Map < String , String > parsePropertyFile ( IAbstractFile propFile , ISdkLog log ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( propFile . getContents ( ) , SdkConstants . INI_CHARSET ) ) ; String line = null ; Map < String , String > map = new HashMap < String , String > ( ) ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) > 0 && line . charAt ( 0 ) != \'#\' ) { Matcher m = PATTERN_PROP . matcher ( line ) ; if ( m . matches ( ) ) { map . put ( m . group ( 1 ) , m . group ( 2 ) ) ; } else { log . warning ( "Error-parsing-\'%1$s\':-"%2$s"-is-not-a-valid-syntax" , propFile . getOsLocation ( ) , line ) ; return null ; } } } return map ; } catch ( FileNotFoundException e ) { } catch ( IOException e ) { log . warning ( "Error-parsing-\'%1$s\':-%2$s." , propFile . getOsLocation ( ) , e . getMessage ( ) ) ; } catch ( StreamException e ) { log . warning ( "Error-parsing-\'%1$s\':-%2$s." , propFile . getOsLocation ( ) , e . getMessage ( ) ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } return null ; } \n', 0.3997111433130349)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 44 #################################
('public HTMLElement parseHTML ( InputStreamReader isr ) { return ( HTMLElement ) super . parse ( isr ) ; } \n', 0.3885460624120572)

('public void readHTMLFromURL ( URL url ) throws IOException { InputStream in = url . openStream ( ) ; try { parseXHTML ( new InputStreamReader ( in , "UTF8" ) ) ; } finally { try { in . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( HTMLTextAreaModel . class . getName ( ) ) . log ( Level . SEVERE , "Exception-while-closing-InputStream" , ex ) ; } } } \n', 0.3738274331756572)

('private void readHtmlData ( ) throws IOException { String dataResourceName = resolveDataResourceName ( HTML_DATA_POSTFIX ) ; DataInputStream input = null ; try { input = new DataInputStream ( pageClass . getResourceAsStream ( dataResourceName ) ) ; int arrayLen = input . readInt ( ) ; htmlParts = new String [ arrayLen ] ; for ( int i = 0 ; i < arrayLen ; i ++ ) { htmlParts [ i ] = input . readUTF ( ) ; } } finally { IOUtils . closeQuietly ( input ) ; } } \n', 0.3699129563598813)

('private static List < String > parseHtml ( String html ) { List < String > data = new ArrayList < String > ( ) ; Document d = Jsoup . parse ( html ) ; Iterator < Element > i = d . select ( "table#ctl00_cphContent_gridLotto" ) . select ( "tr" ) . iterator ( ) ; Element tr = i . next ( ) ; if ( tr . select ( "th" ) . size ( ) == 0 ) { return null ; } Elements td ; StringBuilder sb ; while ( i . hasNext ( ) ) { tr = i . next ( ) ; td = tr . select ( "td" ) ; sb = new StringBuilder ( ) ; for ( Element e : td ) { sb . append ( e . text ( ) ) . append ( "-" ) ; } data . add ( sb . toString ( ) ) ; } return data ; } \n', 0.36595500549457993)

('private void loadHTML ( InputStream filesInputStream ) { System . out . println ( "HTML-Document" ) ; try { EditorKit kit = new HTMLEditorKit ( ) ; javax . swing . text . Document doc = kit . createDefaultDocument ( ) ; kit . read ( filesInputStream , doc , 0 ) ; procText = "" ; System . out . println ( doc . getText ( 0 , doc . getLength ( ) ) ) ; char [ ] origText = doc . getText ( 0 , doc . getLength ( ) ) . toCharArray ( ) ; for ( Character c : origText ) { rawText . append ( c . toString ( ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } procText = rawText . toString ( ) ; } \n', 0.36546669167908885)

('public HTML nextHTML ( ) { return ( HTML ) getWrapped ( ) . next ( ) ; } \n', 0.36518417016650495)

('public static DocumentInfo readHTMLPage ( XPathContext context , String urlStr ) throws IOException , XPathException { URL url ; URLConnection connection ; InputStream inStream = null ; String pageStr ; try { url = new URL ( urlStr ) ; connection = url . openConnection ( ) ; inStream = connection . getInputStream ( ) ; pageStr = HTMLToString . convert ( inStream ) ; } finally { if ( inStream != null ) inStream . close ( ) ; } DocumentInfo doc = context . getConfiguration ( ) . buildDocument ( new StreamSource ( new StringReader ( pageStr ) , urlStr ) ) ; return doc ; } \n', 0.3643850040280333)

('private void loadHtmlIntoView ( String text , boolean ignoreCharset ) throws IOException { Document doc = getView ( ) . getDocument ( ) ; try { doc . remove ( 0 , doc . getLength ( ) ) ; if ( ( text == null ) || ( text . equals ( "" ) ) ) { return ; } if ( ignoreCharset ) { ( ( HTMLDocument ) getView ( ) . getDocument ( ) ) . putProperty ( "IgnoreCharsetDirective" , Boolean . TRUE ) ; } Reader r = new StringReader ( text ) ; EditorKit kit = getView ( ) . getEditorKit ( ) ; kit . read ( r , doc , 0 ) ; } catch ( BadLocationException e ) { LOG . severe ( "Error-deleting-old-view-content:-" + e . getMessage ( ) ) ; return ; } } \n', 0.36174882452826096)

('private void loadHTML ( String filepath ) { System . out . println ( "HTML-Document" ) ; try { EditorKit kit = new HTMLEditorKit ( ) ; javax . swing . text . Document doc = kit . createDefaultDocument ( ) ; kit . read ( ( InputStream ) ( new FileInputStream ( filepath ) ) , doc , 0 ) ; System . out . println ( doc . getText ( 0 , doc . getLength ( ) ) ) ; char [ ] origText = doc . getText ( 0 , doc . getLength ( ) ) . toCharArray ( ) ; for ( Character c : origText ) { rawText . append ( c . toString ( ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } procText = rawText . toString ( ) ; } \n', 0.3519378490001505)

('private List < URI > parseHtmlContent ( URI uri , String type , byte [ ] content ) { List < URI > urls = new ArrayList < URI > ( ) ; try { Charset def = Xml . getCharset ( type ) ; HTMLDocumentBuilderFactory factory = new HTMLDocumentBuilderFactory ( ) ; factory . setNamespaceAware ( false ) ; factory . setXIncludeAware ( false ) ; InputSource is = factory . guessInputSource ( new ByteArrayInputStream ( content ) , def . name ( ) , content . length ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Document doc = builder . parse ( is ) ; XPath xpath = XPathFactory . newInstance ( ) . newXPath ( ) ; NodeList nl = ( NodeList ) xpath . evaluate ( "//a/@href" , doc , XPathConstants . NODESET ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { String href = ( ( Attr ) nl . item ( i ) ) . getValue ( ) ; urls . add ( uri . resolve ( href ) ) ; } } catch ( Exception ex ) { throw new IllegalStateException ( ex ) ; } return urls ; } \n', 0.3506608317966646)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 45 #################################
('public double [ ] distributionForInstance ( Instance instance ) throws Exception { double [ ] probOfClassGivenDoc = new double [ m_numClasses ] ; double [ ] logDocGivenClass = new double [ m_numClasses ] ; for ( int h = 0 ; h < m_numClasses ; h ++ ) logDocGivenClass [ h ] = probOfDocGivenClass ( instance , h ) ; double max = logDocGivenClass [ Utils . maxIndex ( logDocGivenClass ) ] ; double probOfDoc = 0.0 ; for ( int i = 0 ; i < m_numClasses ; i ++ ) { probOfClassGivenDoc [ i ] = Math . exp ( logDocGivenClass [ i ] - max ) * m_probOfClass [ i ] ; probOfDoc += probOfClassGivenDoc [ i ] ; } Utils . normalize ( probOfClassGivenDoc , probOfDoc ) ; return probOfClassGivenDoc ; } \n', 0.38181223751422)

('public double [ ] distributionForInstance ( Instance instance ) { double [ ] predValues = new double [ m_numOfClasses ] ; for ( int i = 0 ; i < m_numOfClasses ; i ++ ) predValues [ i ] = 0.0 ; double [ ] distribution = predictionValuesForInstance ( instance , m_root , predValues ) ; double max = distribution [ Utils . maxIndex ( distribution ) ] ; for ( int i = 0 ; i < m_numOfClasses ; i ++ ) { distribution [ i ] = Math . exp ( distribution [ i ] - max ) ; } double sum = Utils . sum ( distribution ) ; if ( sum > 0.0 ) Utils . normalize ( distribution , sum ) ; return distribution ; } \n', 0.37641908014788206)

('public double [ ] distributionForInstance ( Instance inst ) throws Exception { double [ ] result = new double [ 2 ] ; if ( m_replaceMissing != null ) { m_replaceMissing . input ( inst ) ; inst = m_replaceMissing . output ( ) ; } if ( m_nominalToBinary != null ) { m_nominalToBinary . input ( inst ) ; inst = m_nominalToBinary . output ( ) ; } if ( m_normalize != null ) { m_normalize . input ( inst ) ; inst = m_normalize . output ( ) ; } double wx = dotProd ( inst , m_weights , inst . classIndex ( ) ) ; double z = ( wx + m_weights [ m_weights . length - 1 ] ) ; if ( z <= 0 ) { if ( m_loss == LOGLOSS ) { result [ 0 ] = 1.0 / ( 1.0 + Math . exp ( z ) ) ; result [ 1 ] = 1.0 - result [ 0 ] ; } else { result [ 0 ] = 1 ; } } else { if ( m_loss == LOGLOSS ) { result [ 1 ] = 1.0 / ( 1.0 + Math . exp ( - z ) ) ; result [ 0 ] = 1.0 - result [ 1 ] ; } else { result [ 1 ] = 1 ; } } return result ; } \n', 0.3735956958245167)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 46 #################################
('protected String valueToCSV ( List < String > values ) { if ( values == null ) { return "" ; } String s ; if ( values . size ( ) == 1 ) { s = values . get ( 0 ) ; } else { StringBuilder str = new StringBuilder ( ) ; for ( String value : values ) { if ( str . length ( ) > 0 ) { str . append ( DSpaceCSV . valueSeparator ) ; } str . append ( value ) ; } s = str . toString ( ) ; } return """ + s . replaceAll ( """ , """" ) + """ ; } \n', 0.42133907245931446)

('protected String convertToValidCSV ( Object value ) throws IOException { if ( value == null ) return "" ; StringBuilder r = new StringBuilder ( value . toString ( ) ) ; boolean containsDoubleQuote = r . indexOf ( DOUBLEQUOTE ) >= 0 , containsDelimiter = r . indexOf ( DELIMITER ) >= 0 , containsNewline = r . indexOf ( NEWLINE ) >= 0 ; if ( containsDoubleQuote ) { int k = 0 ; while ( ( k = r . indexOf ( DOUBLEQUOTE , k ) ) >= 0 ) { r . insert ( k , DOUBLEQUOTE ) ; k += 2 ; } } if ( containsDoubleQuote || containsDelimiter || containsNewline ) { r . insert ( 0 , DOUBLEQUOTE ) ; r . append ( DOUBLEQUOTE ) ; } return r . toString ( ) ; } \n', 0.419594767180675)

('private String valueToCSV ( ArrayList < String > values ) { String s = "" ; if ( values == null ) { return s ; } if ( values . size ( ) == 1 ) { s = values . get ( 0 ) ; } else { Iterator i = values . iterator ( ) ; while ( i . hasNext ( ) ) { s = s + i . next ( ) ; if ( i . hasNext ( ) ) { s = s + DSpaceCSV . valueSeparator ; } } } s = s . replaceAll ( """ , """" ) ; s = """ + s + """ ; return s ; } \n', 0.4100924813565987)

('protected String valueToCSV ( List < String > values ) { if ( values == null ) { return "" ; } String s ; if ( values . size ( ) == 1 ) { s = values . get ( 0 ) ; } else { StringBuilder str = new StringBuilder ( ) ; for ( String value : values ) { if ( str . length ( ) > 0 ) { str . append ( DSpaceCSV . valueSeparator ) ; } str . append ( value ) ; } s = str . toString ( ) ; } return """ + s . replaceAll ( """ , """" ) + """ ; } \n', 0.40841408743552626)

('public static String stringToCsv ( String [ ] [ ] anArray ) { String csv = "" ; for ( int i = 0 ; i < anArray . length ; i ++ ) { for ( int j = 0 ; j < anArray [ i ] . length ; j ++ ) { csv += anArray [ i ] [ j ] + "," ; } csv = csv . substring ( 0 , csv . length ( ) - 2 ) ; csv += "-" ; } return csv ; } \n', 0.3984653394042661)

('public String transformToCsv ( ) { StringBuilder csvString = new StringBuilder ( ) ; csvString . append ( toCsvString ( object ) ) ; return csvString . toString ( ) ; } \n', 0.38525366469048056)

('public static String convertToCsvString ( Collection collection , Class baseClass ) throws IllegalAccessException , IOException { StringBuilder csvSb = new StringBuilder ( ) ; appendCsv ( collection , csvSb , baseClass ) ; return csvSb . toString ( ) ; } \n', 0.3850594698844837)

('public static String convertToCsvString ( Collection collection ) throws IllegalAccessException , NoSuchElementException , IOException { StringBuilder csvSb = new StringBuilder ( ) ; appendCsv ( collection , csvSb ) ; return csvSb . toString ( ) ; } \n', 0.3836186076173315)

('private Pair < String [ ] , int [ ] > convertCsvToChartMap ( String chartMapCsv ) { String [ ] parsedChartMapString = chartMapCsv . split ( CHART_MAP_DELIMITER ) ; String [ ] xData = new String [ parsedChartMapString . length / 2 ] ; int [ ] yData = new int [ parsedChartMapString . length / 2 ] ; int dataIndex = 0 ; for ( int i = 0 ; i < parsedChartMapString . length ; i += 2 ) { xData [ dataIndex ] = parsedChartMapString [ i ] ; yData [ dataIndex ] = Integer . parseInt ( parsedChartMapString [ i + 1 ] ) ; dataIndex ++ ; } return new Pair < > ( xData , yData ) ; } \n', 0.38275084310328256)

('CsvPreference toCsvPreference ( ) { logger . trace ( "toCsvPreference()---start" ) ; if ( quoteChar . isEmpty ( ) || delimiterChar . isEmpty ( ) || endOfLineSymbols . isEmpty ( ) ) { logger . warn ( "toCsvPreference()---no-preferences" ) ; logger . trace ( "toCsvPreference()---end" ) ; return null ; } CsvPreference returnCsvPreference = new CsvPreference . Builder ( quoteChar . charAt ( 0 ) , delimiterChar . charAt ( 0 ) , endOfLineSymbols ) . build ( ) ; logger . debug ( "toCsvPreference()---{}" , toString ( ) ) ; logger . trace ( "toCsvPreference()---end" ) ; return returnCsvPreference ; } \n', 0.38257843974274286)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 47 #################################
('public int getSoTimeout ( int timeout ) throws SocketException { return proxy . proxySocket . getSoTimeout ( ) ; } \n', 0.37663021645516775)

('public int getSocketTimeout ( ) { return connection . getSocketTimeout ( ) ; } \n', 0.37636614636832677)

('public static void checkSocketTimeout ( int socketTimeout ) { if ( socketTimeout < 30 || socketTimeout > 300000 ) { throw new IllegalArgumentException ( messages . getString ( "message.illegal.argument.socket.timeout" ) ) ; } } \n', 0.3763474879245159)

('public int getSoTimeout ( ) throws IOException { if ( socket != null ) { return socket . getSoTimeout ( ) ; } else { throw new IOException ( "Connection-not-openned" ) ; } } \n', 0.3751185010772058)

('public int getTimeout ( ) { try { return ( ( socket != null ) ? socket . getSoTimeout ( ) : timeout ) ; } catch ( SocketException se ) { return timeout ; } } \n', 0.3749543169917212)

('public synchronized int getSoTimeout ( ) throws SocketException { return socket . getSoTimeout ( ) ; } \n', 0.3733412854701627)

('public int getSoTimeout ( ) throws SocketException { if ( socket != null ) { return socket . getSoTimeout ( ) ; } else { return 0 ; } } \n', 0.3730408043493515)

('public int getSoTimeout ( ) throws SocketException { return socket . getSoTimeout ( ) ; } \n', 0.3730408043493515)

('public int getSoTimeout ( ) throws java . net . SocketException { return socket . getSoTimeout ( ) ; } \n', 0.3730408043493515)

('public int getSoTimeout ( ) throws SocketException { return _socket_ . getSoTimeout ( ) ; } \n', 0.3730408043493515)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 48 #################################
('public void load ( RandomAccessFile in ) throws IOException { requireNonNull ( in , "RandomAccessFile-cannot-be-null." ) ; md5Hash = new byte [ 16 ] ; dataInMemory = Optional . empty ( ) ; compressionType = in . readUnsignedShort ( ) ; compressedSize = in . readInt ( ) ; decompressedSize = in . readInt ( ) ; in . readFully ( md5Hash ) ; int numMetadata = in . readUnsignedShort ( ) ; dataOnDisk = Optional . of ( new byte [ compressedSize ] ) ; in . readFully ( dataOnDisk . get ( ) ) ; metadata = new MetadataList ( ) ; metadata . load ( in , numMetadata ) ; } \n', 0.29393625567164783)

('public static void compress ( Map < Character , String > binaryMap ) throws IOException { BufferedReader input = new BufferedReader ( new FileReader ( input_original ) ) ; BufferedBitWriter bitOutput = new BufferedBitWriter ( input_compressed ) ; try { int currentInt = input . read ( ) ; while ( currentInt != - 1 ) { char character = ( char ) currentInt ; String huffmanString = binaryMap . get ( character ) ; for ( int i = 0 ; i < huffmanString . length ( ) ; i ++ ) { int bit = Character . digit ( huffmanString . charAt ( i ) , 10 ) ; bitOutput . writeBit ( bit ) ; } currentInt = input . read ( ) ; } } catch ( IOException ex ) { System . out . println ( ex + "-compression-exception-occurred." ) ; } finally { input . close ( ) ; bitOutput . close ( ) ; } } \n', 0.28938954344299594)

('public static void downloadGzipCompressedFile ( URL url , File destination ) throws IOException { InputStream uStream = url . openStream ( ) ; InputStream conn = new GZIPInputStream ( uStream ) ; File tempFile = File . createTempFile ( getFilePrefix ( destination ) , "." + getFileExtension ( destination ) ) ; try { FileOutputStream outPut = new FileOutputStream ( tempFile ) ; GZIPOutputStream gzOutPut = new GZIPOutputStream ( outPut ) ; PrintWriter pw = new PrintWriter ( gzOutPut ) ; BufferedReader fileBuffer = new BufferedReader ( new InputStreamReader ( conn ) ) ; String line ; while ( ( line = fileBuffer . readLine ( ) ) != null ) { pw . println ( line ) ; } pw . flush ( ) ; pw . close ( ) ; outPut . flush ( ) ; outPut . close ( ) ; conn . close ( ) ; uStream . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; if ( conn != null ) conn . close ( ) ; if ( uStream != null ) uStream . close ( ) ; throw new IOException ( e . getMessage ( ) ) ; } copy ( tempFile , destination ) ; tempFile . delete ( ) ; } \n', 0.2862607989521391)

('public String compressCSSFile ( InputStream in ) throws IOException { String compressedFile = null ; Reader reader = new InputStreamReader ( in , "UTF-8" ) ; CssCompressor cssc = new CssCompressor ( reader ) ; reader . close ( ) ; in . close ( ) ; StringWriter out = new StringWriter ( ) ; cssc . compress ( out , linebreak ) ; compressedFile = out . toString ( ) ; return compressedFile ; } \n', 0.28116700253401317)

('private void gzipCompressFile ( String from , String to ) throws Exception { File target = new File ( to + ".gz" ) ; if ( target . exists ( ) ) { target . delete ( ) ; } new File ( from ) . renameTo ( new File ( to ) ) ; File file = new File ( to ) ; if ( file . length ( ) == 0 ) { LogLog . debug ( "CompressedDailyRollingFileAppender-gzipCompressFile-file-is-zero-bytes,-not-compressing" ) ; file . delete ( ) ; return ; } MyGZIPOutputStream gz = null ; BufferedInputStream in = null ; try { gz = new MyGZIPOutputStream ( new FileOutputStream ( target ) , GZIP_BUFFER_SIZE ) ; in = new BufferedInputStream ( new FileInputStream ( file ) , GZIP_BUFFER_SIZE ) ; byte [ ] buffer = new byte [ GZIP_BUFFER_SIZE ] ; int howMany = 0 ; while ( true ) { howMany = in . read ( buffer , 0 , buffer . length ) ; if ( howMany == - 1 ) { break ; } gz . write ( buffer , 0 , howMany ) ; } } finally { if ( gz != null ) { gz . close ( ) ; } if ( in != null ) { in . close ( ) ; } file . delete ( ) ; } } \n', 0.2702916449350114)

('public static void compressFile ( File raw , File compressed ) throws IOException { InputStream in = new FileInputStream ( raw ) ; OutputStream out = new DeflaterOutputStream ( new FileOutputStream ( compressed ) ) ; shovelInToOut ( in , out ) ; in . close ( ) ; out . close ( ) ; } \n', 0.2644623261065765)

('public Backup loadBackup ( String name ) throws IOException { File file ; file = new File ( BACKUP_FOLDER , name + FILE_EXTENSION_COMPRESSED ) ; if ( file . exists ( ) ) { return new Backup ( file , Backup . OperationMode . READ , EnumSet . of ( Flag . COMPRESSION ) ) ; } file = new File ( BACKUP_FOLDER , name + FILE_EXTENSION_UNCOMPRESSED ) ; if ( file . exists ( ) ) { return new Backup ( file , Backup . OperationMode . READ , EnumSet . noneOf ( Flag . class ) ) ; } return null ; } \n', 0.2630254228377412)

('private void writeCompressedFinalFile ( File dataFile ) throws IOException , ClassNotFoundException { File outputFile = new File ( path ) ; BlockCompressedOutputStream output = new BlockCompressedOutputStream ( outputFile ) ; header += "-" ; output . write ( header . getBytes ( ) ) ; FileInputStream fis = new FileInputStream ( dataFile ) ; GZIPInputStream gz = new GZIPInputStream ( fis ) ; ObjectInputStream ois = new ObjectInputStream ( gz ) ; boolean endOfFile = false ; while ( ! endOfFile ) { String line = null ; try { line = ( String ) ois . readObject ( ) ; output . write ( line . getBytes ( ) ) ; } catch ( EOFException e ) { endOfFile = true ; } } ois . close ( ) ; gz . close ( ) ; fis . close ( ) ; output . close ( ) ; } \n', 0.2630075686540049)

('public void compress ( ) { compressionThread . submit ( new Runnable ( ) { public void run ( ) { try { InputStream in = read ( ) ; OutputStream out = new GZIPOutputStream ( new FileOutputStream ( gz ) ) ; try { Util . copyStream ( in , out ) ; } finally { in . close ( ) ; out . close ( ) ; } file . delete ( ) ; } catch ( IOException e ) { LOGGER . log ( Level . WARNING , "Failed-to-compress-" + file , e ) ; gz . delete ( ) ; } } } ) ; } \n', 0.26166898977970454)

('protected void determineCompression ( ) { if ( null != path ) { if ( this . path . endsWith ( Compressions . GZIP_COMPRESSION . fileExtension ( ) ) ) { this . isCompressed = true ; setCompression ( Compressions . GZIP_COMPRESSION ) ; this . setUncompressedPath ( this . path . replaceAll ( ".gz$" , "" ) ) ; } else { this . setUncompressedPath ( path ) ; } } } \n', 0.25922256541949273)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 49 #################################
('public static < T > Queue < T > priorityQueue ( ) { return new PriorityQueue < T > ( ) ; } \n', 0.47266666477079416)

('protected PriorityQueue ( boolean isMinQueue ) { this . isMinQueue = isMinQueue ; this . backer = new java . util . PriorityQueue < > ( ) ; } \n', 0.4685781063521681)

('public static < E > PriorityQueue < E > priorityQueue ( SortedSet < E > elements ) { return new PriorityQueue < E > ( elements ) ; } \n', 0.46639028129097665)

('private PriorityQueue < Double > priorityQueue ( int size ) { final PriorityQueue < Double > result = new PriorityQueue < > ( size < 1 ? 1 : size ) ; for ( int i = size ; i >= 0 ; i -- ) { result . add ( rng . nextDouble ( ) ) ; } return result ; } \n', 0.46051470365928926)

('private PriorityQueue < Elem > priorityQueueKeyed ( int size ) { final PriorityQueue < Elem > result = new PriorityQueue < > ( size < 1 ? 1 : size ) ; for ( int i = size ; i >= 0 ; i -- ) { result . add ( new Elem ( rng . nextDouble ( ) , value ) ) ; } return result ; } \n', 0.45976126251242044)

('PriorityQueueSet ( int initialCapacity , Comparator < ? super E > comparator ) { this . queue = new PriorityQueue < E > ( initialCapacity , comparator ) ; } \n', 0.44859728996860515)

('public PriorityQueue < T > toPriorityQueue ( ) { PriorityQueue < T > priority = new PriorityQueue < T > ( ) ; Iterator < T > i = this . iterator ( ) ; while ( i . hasNext ( ) ) { priority . add ( i . next ( ) ) ; } return priority ; } \n', 0.4485091470949431)

('public PriorityQueue < T > toPriorityQueue ( ) { PriorityQueue < T > queue = new PriorityQueue < T > ( ) ; Iterator < T > i = this . iterator ( ) ; while ( i . hasNext ( ) ) { queue . add ( i . next ( ) ) ; } return queue ; } \n', 0.4485091470949431)

('public < E extends Comparable < E >> Queue < E > getPriorityQueue ( ) { return new PriorityQueue < E > ( ) ; } \n', 0.4468974441026809)

('public void submitPriorityUpstream ( ShareEntry entry ) { if ( entry . ourResult ) { synchronized ( qs ) { synchronized ( priorityQueue ) { priorityQueue . offerLast ( entry ) ; } qs . notifyAll ( ) ; } } } \n', 0.4443616229687312)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 50 #################################
('public static Pair < Population , Double > clusterLocalSearch ( PostProcessMethod method , Population pop , AbstractOptimizationProblem problem , double sigmaCluster , int funCalls , double keepClusterRatio , InterfaceMutation mute ) { int evalsBefore = pop . getFunctionCalls ( ) ; Population clust = ( Population ) clusterBest ( pop , new ClusteringDensityBased ( sigmaCluster , 2 ) , keepClusterRatio , KEEP_LONERS , BEST_RAND ) . clone ( ) ; double [ ] meanFit = clust . getMeanFitness ( ) ; int evalsDone = processSingleCandidates ( method , clust , funCalls , sigmaCluster / 2. , problem , mute ) ; clust . setFunctionCalls ( evalsBefore + evalsDone ) ; double improvement = EuclideanMetric . euclideanDistance ( meanFit , clust . getMeanFitness ( ) ) ; return new Pair < > ( clust , improvement ) ; } \n', 0.33347163858650053)

('public double meanLocalClusterCoeff ( ) { double sumCoeff = 0.0 ; int n = nodes . size ( ) ; if ( n == 0 ) return 0 ; for ( SimpleNode node : nodes ) { sumCoeff += node . localClusterCoeff ( ) ; } double mean = sumCoeff / n ; assert mean >= 0.0 && mean <= 1.0 ; return mean ; } \n', 0.33067760263936946)

('public static com . stromberglabs . cluster . Cluster findClosestExternalClusterToFeatureVector ( float [ ] fv , com . stromberglabs . cluster . Cluster c , com . stromberglabs . cluster . Cluster [ ] featureVectorClusters ) throws Exception { com . stromberglabs . cluster . Cluster closestExternalCluster = null ; double minimumDistanceToExternalClusterCentroid = Double . POSITIVE_INFINITY ; for ( com . stromberglabs . cluster . Cluster externalCluster : featureVectorClusters ) { if ( ! c . equals ( externalCluster ) ) { double distanceToExternalClusterCentroid = FeatureVector . L2distanceFrom ( fv , externalCluster . getClusterMean ( ) ) ; if ( distanceToExternalClusterCentroid < minimumDistanceToExternalClusterCentroid ) { minimumDistanceToExternalClusterCentroid = distanceToExternalClusterCentroid ; closestExternalCluster = externalCluster ; } } } return closestExternalCluster ; } \n', 0.32802393863979784)

('public void calculateClusters ( ) { if ( conf . getModel ( ) == Configuration . Models . ANTCLASS1 || conf . getModel ( ) == Configuration . Models . ANTCLASS2 ) { this . partition = new Cluster [ heaps . size ( ) ] ; int j = 0 ; for ( Heap h : this . heaps ) { LinkedList < Item > list = h . getItems ( ) ; partition [ j ] = new Cluster ( list . toArray ( new Item [ 0 ] ) ) ; j ++ ; } } else { TreeMap < UUID , Double > map = new TreeMap < UUID , Double > ( ) ; for ( Item it : items . values ( ) ) map . put ( it . getID ( ) , this . densityRawAt ( it . getX ( ) , it . getinitY ( ) ) ) ; map = sortByValues ( map ) ; LinkedList < UUID > list = new LinkedList < UUID > ( ) ; int i = 0 ; for ( UUID k : map . keySet ( ) ) { list . add ( k ) ; i ++ ; if ( i == conf . getntypes ( ) ) break ; } KMeans km = new KMeans ( this . conf , this . items , 0 , list , 10 , 2500 , 2 ) ; km . compute ( ) ; this . centers = km . getCenters ( ) ; this . partition = km . getClusters ( ) ; } } \n', 0.3224977146306447)

('public static Pair < Population , Double > clusterLocalSearch ( PostProcessMethod method , Population pop , AbstractOptimizationProblem problem , double sigmaCluster , int funCalls , double keepClusterRatio , InterfaceMutation mute ) { int evalsBefore = pop . getFunctionCalls ( ) ; Population clust = ( Population ) clusterBest ( pop , new ClusteringDensityBased ( sigmaCluster , 2 ) , keepClusterRatio , KEEP_LONERS , BEST_RAND ) . clone ( ) ; double [ ] meanFit = clust . getMeanFitness ( ) ; if ( TRACE ) System . out . println ( "BEF:-funcalls-done:-" + pop . getFunctionCalls ( ) + ",-now-allowed:-" + funCalls ) ; int evalsDone = processSingleCandidates ( method , clust , funCalls , sigmaCluster / 2. , problem , mute ) ; clust . SetFunctionCalls ( evalsBefore + evalsDone ) ; double improvement = EuclideanMetric . euclideanDistance ( meanFit , clust . getMeanFitness ( ) ) ; if ( TRACE ) System . out . println ( "improvement-by-" + improvement + "-funcalls-done:-" + evalsDone ) ; return new Pair < Population , Double > ( clust , improvement ) ; } \n', 0.32085961951179987)

('private T getPointFromLargestVarianceCluster ( final Collection < CentroidCluster < T >> clusters ) throws ConvergenceException { double maxVariance = Double . NEGATIVE_INFINITY ; Cluster < T > selected = null ; for ( final CentroidCluster < T > cluster : clusters ) { if ( ! cluster . getPoints ( ) . isEmpty ( ) ) { final Clusterable center = cluster . getCenter ( ) ; final Variance stat = new Variance ( ) ; for ( final T point : cluster . getPoints ( ) ) { stat . increment ( distance ( point , center ) ) ; } final double variance = stat . getResult ( ) ; if ( variance > maxVariance ) { maxVariance = variance ; selected = cluster ; } } } if ( selected == null ) { throw new ConvergenceException ( LocalizedFormats . EMPTY_CLUSTER_IN_K_MEANS ) ; } final List < T > selectedPoints = selected . getPoints ( ) ; return selectedPoints . remove ( random . nextInt ( selectedPoints . size ( ) ) ) ; } \n', 0.31968305692673543)

('public static List < List < Rates >> allPatternsMeanRates ( String training ) throws FileNotFoundException { List < List < Rates >> rates = new ArrayList < List < Rates >> ( ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { List < Rates > rate = meanRatesThroughPattern ( training , i ) ; rates . add ( rate ) ; } return rates ; } \n', 0.3132154842866285)

('private T getPointFromLargestVarianceCluster ( final Collection < Cluster < T >> clusters ) throws ConvergenceException { double maxVariance = Double . NEGATIVE_INFINITY ; Cluster < T > selected = null ; for ( final Cluster < T > cluster : clusters ) { if ( ! cluster . getPoints ( ) . isEmpty ( ) ) { final T center = cluster . getCenter ( ) ; final Variance stat = new Variance ( ) ; for ( final T point : cluster . getPoints ( ) ) { stat . increment ( point . distanceFrom ( center ) ) ; } final double variance = stat . getResult ( ) ; if ( variance > maxVariance ) { maxVariance = variance ; selected = cluster ; } } } if ( selected == null ) { throw new ConvergenceException ( LocalizedFormats . EMPTY_CLUSTER_IN_K_MEANS ) ; } final List < T > selectedPoints = selected . getPoints ( ) ; return selectedPoints . remove ( random . nextInt ( selectedPoints . size ( ) ) ) ; } \n', 0.3084643332858066)

('public void clusterSamples ( int nbClusters , String [ ] variables , String [ ] variablesToUse , SampleIterable samples , SampleWriter writer , SampleWriter centroidWriter ) { int [ ] variableIndices = getVariableIndices ( variables , variablesToUse ) ; List < Point > inputList = new ArrayList < Point > ( ) ; for ( Sample s : samples ) { inputList . add ( new Point ( s , variableIndices ) ) ; } KMeansPlusPlusClusterer < Point > c = new KMeansPlusPlusClusterer < Point > ( nbClusters , 10 ) ; List < CentroidCluster < Point >> cluster = c . cluster ( inputList ) ; try { int i = 0 ; for ( CentroidCluster < Point > cl : cluster ) { String clusterName = "cluster" + i ; if ( writer != null ) { for ( Point point : cl . getPoints ( ) ) { writer . writeSample ( new Sample ( point . s . getContent ( ) , clusterName ) ) ; } } double [ ] centroidData = cl . getCenter ( ) . getPoint ( ) ; double [ ] copyOf = Arrays . copyOf ( centroidData , centroidData . length + 1 ) ; copyOf [ centroidData . length ] = cl . getPoints ( ) . size ( ) ; if ( centroidWriter != null ) { centroidWriter . writeSample ( new Sample ( copyOf , clusterName ) ) ; } i ++ ; } } finally { IOUtils . closeQuietly ( writer ) ; IOUtils . closeQuietly ( centroidWriter ) ; } } \n', 0.30603255024926845)

('public static double calculatePopulationMeanPerformance ( Map < Agent , Double > lookup ) { double count = 0 , sum = 0 ; for ( Double d : lookup . values ( ) ) { sum += d . doubleValue ( ) ; count ++ ; } double mean = sum / count ; return mean ; } \n', 0.2988868788603335)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 51 #################################
('public Process getProcessFromId ( int id ) { for ( Process process : this . processes ) { if ( process . getId ( ) == id ) { return process ; } } return null ; } \n', 0.40742493745892844)

('private Process getProcessById ( String id ) { for ( Iterator < Process > it = processes . iterator ( ) ; it . hasNext ( ) ; ) { Process p = it . next ( ) ; if ( p . getId ( ) . equals ( id ) ) return p ; } return null ; } \n', 0.4051697039287081)

('public static long getProcessId ( ) { RuntimeMXBean bean = ManagementFactory . getRuntimeMXBean ( ) ; String jvmName = bean . getName ( ) ; long processId = Long . valueOf ( jvmName . split ( "@" ) [ 0 ] ) ; return processId ; } \n', 0.3997955653596935)

('public static int getCurrentProcessId ( ) { final Integer processId = s_currentProcess_ID . get ( ) ; if ( processId == null ) { return 0 ; } return processId ; } \n', 0.3997167528215526)

('public static long getProcessId ( ) { return Context . getCurrentContext ( ) . getProcessId ( ) ; } \n', 0.39412113969445123)

('private String getProcessId ( String externalId ) throws WorkflowException { StringTokenizer st = new StringTokenizer ( externalId , "__" ) ; if ( st . countTokens ( ) != 4 ) throw new WorkflowException ( "TaskManagerImpl.getProcessId" , "workflowEngine.EX_ERR_ILLEGAL_EXTERNALID" , "external-Id-:-" + externalId ) ; return st . nextToken ( ) ; } \n', 0.39317056920909255)

('public List < String > getAsyncProcessId ( ) { if ( asyncProcessId == null ) { asyncProcessId = new ArrayList < String > ( ) ; } return this . asyncProcessId ; } \n', 0.39243996063821707)

('public String getProcessId ( ) { int id = processList . size ( ) + 1 ; return ProcessConstants . PROCESS + "-" + id ; } \n', 0.390619116208488)

('public static int getProcessId ( ) { String processId = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; if ( processId . contains ( "@" ) ) { processId = processId . substring ( 0 , processId . indexOf ( "@" ) ) ; } return Integer . parseInt ( processId ) ; } \n', 0.38384744275922483)

('int getProcessId ( ) { return processId . intValue ( ) ; } \n', 0.38335537459745916)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 52 #################################
('private void sendConnectionInfo ( ) { try { outputBuffer . put ( ( byte ) 6 ) ; putMedInt ( outputBuffer , 3 ) ; outputBuffer . putShort ( ( short ) 0 ) ; output . write ( outputBuffer . array ( ) ) ; output . flush ( ) ; outputBuffer . clear ( ) ; outputBuffer . put ( ( byte ) 3 ) ; putMedInt ( outputBuffer , 0 ) ; outputBuffer . putShort ( ( short ) 0 ) ; output . write ( outputBuffer . array ( ) ) ; output . flush ( ) ; outputBuffer . clear ( ) ; } catch ( IOException ioex ) { ioex . printStackTrace ( ) ; } } \n', 0.3509552285960847)

('@ Override public boolean finishConnect ( ) throws IOException { synchronized ( this ) { if ( ! isOpen ( ) ) { throw new ClosedChannelException ( ) ; } if ( status == SOCKET_STATUS_CONNECTED ) { return true ; } if ( status != SOCKET_STATUS_PENDING ) { throw new NoConnectionPendingException ( ) ; } } boolean finished = false ; try { begin ( ) ; InetAddress inetAddress = connectAddress . getAddress ( ) ; int port = connectAddress . getPort ( ) ; finished = IoBridge . isConnected ( fd , inetAddress , port , 0 , 0 ) ; } catch ( ConnectException e ) { if ( isOpen ( ) ) { close ( ) ; finished = true ; } throw e ; } finally { end ( finished ) ; } synchronized ( this ) { status = ( finished ? SOCKET_STATUS_CONNECTED : status ) ; if ( finished && socket != null ) { socket . onConnect ( connectAddress . getAddress ( ) , connectAddress . getPort ( ) ) ; } } return finished ; } \n', 0.34953873813211755)

('private void serverLongData ( int parameterIndex , BindValue longData ) throws SQLException { synchronized ( this . connection . getMutex ( ) ) { MysqlIO mysql = this . connection . getIO ( ) ; Buffer packet = mysql . getSharedSendPacket ( ) ; Object value = longData . value ; if ( value instanceof byte [ ] ) { packet . clear ( ) ; packet . writeByte ( ( byte ) MysqlDefs . COM_LONG_DATA ) ; packet . writeLong ( this . serverStatementId ) ; packet . writeInt ( ( parameterIndex ) ) ; packet . writeBytesNoNull ( ( byte [ ] ) longData . value ) ; mysql . sendCommand ( MysqlDefs . COM_LONG_DATA , null , packet , true , null ) ; } else if ( value instanceof InputStream ) { storeStream ( mysql , parameterIndex , packet , ( InputStream ) value ) ; } else if ( value instanceof java . sql . Blob ) { storeStream ( mysql , parameterIndex , packet , ( ( java . sql . Blob ) value ) . getBinaryStream ( ) ) ; } else if ( value instanceof Reader ) { storeReader ( mysql , parameterIndex , packet , ( Reader ) value ) ; } else { throw SQLError . createSQLException ( Messages . getString ( "ServerPreparedStatement.18" ) + value . getClass ( ) . getName ( ) + "\'" , SQLError . SQL_STATE_ILLEGAL_ARGUMENT ) ; } } } \n', 0.34527825004801194)

('static public boolean sendPeerInfo ( String host , int port ) { Socket socket = new Socket ( ) ; String strIP = getLocalIpAddress ( ) ; boolean result = true ; Logger . d ( TAG , "sendPeerInfo,-local-ip-is:" + strIP ) ; try { Logger . d ( TAG , "Opening-client-socket---" ) ; socket . bind ( null ) ; socket . connect ( ( new InetSocketAddress ( host , port ) ) , WifiP2pConfigInfo . SOCKET_TIMEOUT ) ; Logger . d ( TAG , "Client-socket---" + socket . isConnected ( ) ) ; OutputStream stream = socket . getOutputStream ( ) ; stream . write ( WifiP2pConfigInfo . COMMAND_ID_SEND_PEER_INFO ) ; String strSend = "peer:" + strIP + "port:" + port ; stream . write ( strSend . getBytes ( ) , 0 , strSend . length ( ) ) ; Logger . d ( TAG , "Client:-Data-written-strSend:" + strSend ) ; } catch ( IOException e ) { Logger . e ( TAG , e . getMessage ( ) ) ; result = false ; } finally { if ( socket != null ) { if ( socket . isConnected ( ) ) { try { socket . close ( ) ; Logger . d ( TAG , "socket.close();" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } return result ; } \n', 0.3387051579847756)

('public boolean finishConnect ( ) throws IOException { synchronized ( readLock ) { synchronized ( writeLock ) { synchronized ( stateLock ) { if ( ! isOpen ( ) ) throw new ClosedChannelException ( ) ; if ( state == ST_CONNECTED ) return true ; if ( state != ST_PENDING ) throw new NoConnectionPendingException ( ) ; } int n = 0 ; try { try { begin ( ) ; synchronized ( blockingLock ( ) ) { synchronized ( stateLock ) { if ( ! isOpen ( ) ) { return false ; } readerThread = NativeThread . current ( ) ; } if ( ! isBlocking ( ) ) { for ( ; ; ) { n = checkConnect ( fd , false , readyToConnect ) ; if ( ( n == IOStatus . INTERRUPTED ) && isOpen ( ) ) continue ; break ; } } else { for ( ; ; ) { n = checkConnect ( fd , true , readyToConnect ) ; if ( n == 0 ) { continue ; } if ( ( n == IOStatus . INTERRUPTED ) && isOpen ( ) ) continue ; break ; } } } } finally { synchronized ( stateLock ) { readerThread = 0 ; if ( state == ST_KILLPENDING ) { kill ( ) ; n = 0 ; } } end ( ( n > 0 ) || ( n == IOStatus . UNAVAILABLE ) ) ; assert IOStatus . check ( n ) ; } } catch ( IOException x ) { close ( ) ; throw x ; } if ( n > 0 ) { synchronized ( stateLock ) { state = ST_CONNECTED ; } return true ; } return false ; } } } \n', 0.33516319921639537)

('protected static byte [ ] downloadAndSendBinary ( String u , boolean saveOnDisk , File f ) throws IOException { URL url = new URL ( u ) ; Authenticator . setDefault ( new HTTPResourceAuthenticator ( ) ) ; HTTPResourceAuthenticator . addURL ( url ) ; logger . debug ( "Retrieving-" + url . toString ( ) ) ; ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; URLConnection conn = url . openConnection ( ) ; conn . setRequestProperty ( "User-agent" , PropertiesUtil . getProjectProperties ( ) . get ( "project.name" ) + "-" + PMS . getVersion ( ) ) ; InputStream in = conn . getInputStream ( ) ; FileOutputStream fOUT = null ; if ( saveOnDisk && f != null ) { fOUT = new FileOutputStream ( f ) ; } byte [ ] buf = new byte [ 4096 ] ; int n = - 1 ; while ( ( n = in . read ( buf ) ) > - 1 ) { bytes . write ( buf , 0 , n ) ; if ( fOUT != null ) { fOUT . write ( buf , 0 , n ) ; } } in . close ( ) ; if ( fOUT != null ) { fOUT . close ( ) ; } return bytes . toByteArray ( ) ; } \n', 0.33260075707777303)

('protected byte [ ] downloadAndSendBinary ( String u , boolean saveOnDisk , File f ) throws IOException { URL url = new URL ( u ) ; PMS . info ( "Retrieving-" + url . toString ( ) ) ; ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; URLConnection conn = url . openConnection ( ) ; conn . setRequestProperty ( "User-agent" , "PS3-Media-Server-v" + PMS . VERSION ) ; InputStream in = conn . getInputStream ( ) ; FileOutputStream fOUT = null ; if ( saveOnDisk && f != null ) { fOUT = new FileOutputStream ( f ) ; } byte buf [ ] = new byte [ 4096 ] ; int n = - 1 ; while ( ( n = in . read ( buf ) ) > - 1 ) { bytes . write ( buf , 0 , n ) ; if ( fOUT != null ) fOUT . write ( buf , 0 , n ) ; } in . close ( ) ; if ( fOUT != null ) fOUT . close ( ) ; return bytes . toByteArray ( ) ; } \n', 0.3290050180706569)

('protected Socket tcpConnectForDataTransferChannel ( String host , int port ) throws IOException { Socket socket = new Socket ( ) ; socket . setSoTimeout ( readTimeout * 1000 ) ; socket . setSoLinger ( true , closeTimeout ) ; socket . setReceiveBufferSize ( 512 * 1024 ) ; socket . setSendBufferSize ( 512 * 1024 ) ; socket . connect ( new InetSocketAddress ( host , port ) , connectionTimeout * 1000 ) ; return socket ; } \n', 0.32567008911447926)

('public byte [ ] requestBinaryFile ( URL fileURL ) { byte [ ] requestedFile = null ; if ( fileURL != null ) { InputStream is = null ; try { URLConnection urlCon = fileURL . openConnection ( ) ; urlCon . setDoInput ( true ) ; urlCon . setConnectTimeout ( timoutInMs ) ; urlCon . setReadTimeout ( timoutInMs ) ; urlCon . connect ( ) ; is = urlCon . getInputStream ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( 10240 ) ; byte [ ] data = new byte [ 4096 ] ; int i = 0 ; while ( ( i = is . read ( data ) ) != - 1 ) { bos . write ( data , 0 , i ) ; } is . close ( ) ; requestedFile = bos . toByteArray ( ) ; } catch ( Exception e ) { System . out . print ( "rejected,-" ) ; System . out . println ( e . getLocalizedMessage ( ) ) ; if ( is != null ) { try { is . close ( ) ; } catch ( IOException ioe ) { } } } } else { System . out . println ( "parameter-error-(null-pointer)" ) ; } return requestedFile ; } \n', 0.32303471592280186)

('public synchronized void sendCloseConnection ( ) throws org . omg . CORBA . COMM_FAILURE { try { out_stream . write ( Messages . closeConnectionMessage ( ) ) ; out_stream . flush ( ) ; closeConnection ( ) ; } catch ( Exception e ) { throw new org . omg . CORBA . COMM_FAILURE ( ) ; } } \n', 0.321843795578085)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 53 #################################
('public void connect ( String username , String passwd , boolean autoCommit ) throws SQLException { if ( connection != null ) { throw new SQLException ( "connect:-Connection-to-database-\'" + databaseURL + "\'-already-exists!" ) ; } if ( username == null ) { connection = DriverManager . getConnection ( databaseURL ) ; } else { connection = DriverManager . getConnection ( databaseURL , username , passwd ) ; } connection . setAutoCommit ( autoCommit ) ; } \n', 0.36095931133290204)

('public final boolean connect ( ) throws Exception { if ( DBconnection == null ) { if ( ! checkDependency ( ) ) { return false ; } Class . forName ( "com.mysql.jdbc.Driver" ) . newInstance ( ) ; DBconnection = DriverManager . getConnection ( String . format ( "jdbc:mysql://%s:%s/%s?create=true,autoReconnect=true" , sql_hostName , sql_portNum , sql_database ) , sql_username , sql_password ) ; } else { if ( DBconnection . isClosed ( ) ) { DBconnection = DriverManager . getConnection ( String . format ( "jdbc:mysql://%s:%s/%s?create=true,autoReconnect=true" , sql_hostName , sql_portNum , sql_database ) , sql_username , sql_password ) ; } } return DBconnection != null && DBconnection . getCatalog ( ) != null ; } \n', 0.35873365640810106)

('private void connect ( char [ ] passwd , Properties props , boolean autoCommit ) throws SQLException { if ( connection != null ) { throw new SQLException ( "Connection-to-database-\'" + databaseURL + "\'-already-exists!" ) ; } LogService . getRoot ( ) . log ( Level . CONFIG , "com.rapidminer.tools.jdbc.DatabaseHandler.connecting_to_database" , new Object [ ] { databaseURL , this . user } ) ; DriverManager . setLoginTimeout ( 30 ) ; props . put ( "SetBigStringTryClob" , "true" ) ; if ( this . user != null && ! user . isEmpty ( ) ) { props . put ( "user" , user ) ; props . put ( "password" , new String ( passwd ) ) ; } connection = DriverManager . getConnection ( databaseURL , props ) ; connection . setAutoCommit ( autoCommit ) ; statementCreator = new StatementCreator ( connection ) ; } \n', 0.35451225933449004)

('private void connectMySql ( String url , String user , String password ) throws SQLException { LOG . info ( "Connecting-to-database" ) ; con = DriverManager . getConnection ( url , user , password ) ; con . setAutoCommit ( true ) ; LOG . info ( "Successfully-connected-to-database" ) ; } \n', 0.3539978979021882)

('public Connection connectToMySQL ( ) throws SQLException { try { Class . forName ( "com.mysql.jdbc.Driver" ) ; } catch ( ClassNotFoundException e ) { log . severe ( e . getMessage ( ) ) ; } String url = "jdbc:mysql://" + config . getSQLURL ( ) + ":" + config . getSQLPort ( ) + "/" + config . getSQLDatabaseName ( ) ; return DriverManager . getConnection ( url , config . getSQLUserName ( ) , config . getSQLPassword ( ) ) ; } \n', 0.3539415964730787)

('public boolean connect ( ) throws Exception { if ( connection != null ) return true ; if ( currentType == null || currentType == Type . NONE ) throw new Exception ( "Unknown-Connection-type" ) ; String className = "" ; if ( currentType == Type . MySQL ) { className = "com.mysql.jdbc.Driver" ; } else { className = "org.sqlite.JDBC" ; } Driver driver ; driver = ( Driver ) Class . forName ( className ) . newInstance ( ) ; Properties properties = new Properties ( ) ; if ( currentType == Type . MySQL ) { properties . put ( "autoReconnect" , "true" ) ; properties . put ( "user" , username ) ; properties . put ( "password" , password ) ; } connection = driver . connect ( "jdbc:" + currentType . toString ( ) . toLowerCase ( ) + ":" + getDatabasePath ( ) , properties ) ; if ( connection == null ) throw new NullPointerException ( "Connecting-to-database-failed:-unknown-error---using-jdbc:" + currentType . toString ( ) . toLowerCase ( ) + ":" + getDatabasePath ( ) ) ; connected = true ; return true ; } \n', 0.3494255423967468)

('public boolean connect ( ) throws Exception { if ( connection != null ) { return true ; } if ( currentType == null || currentType == Type . NONE ) { throw new Exception ( "Unknown-Connection-type" ) ; } String className = "" ; if ( currentType == Type . MySQL ) { className = "com.mysql.jdbc.Driver" ; } else { className = "org.sqlite.JDBC" ; } Driver driver ; driver = ( Driver ) Class . forName ( className ) . newInstance ( ) ; Properties properties = new Properties ( ) ; if ( currentType == Type . MySQL ) { properties . put ( "autoReconnect" , "true" ) ; properties . put ( "user" , username ) ; properties . put ( "password" , password ) ; } connection = driver . connect ( "jdbc:" + currentType . toString ( ) . toLowerCase ( ) + ":" + getDatabasePath ( ) , properties ) ; if ( connection == null ) { throw new NullPointerException ( "Connecting-to-database-failed:-unknown-error---using-jdbc:" + currentType . toString ( ) . toLowerCase ( ) + ":" + getDatabasePath ( ) ) ; } connected = true ; return true ; } \n', 0.3494255423967468)

('private void connect ( ) throws SQLException { for ( ; ; ) { try { db = DriverManager . getConnection ( "jdbc:mysql://" + host + ":" + port + "/" + schema , username , password ) ; break ; } catch ( SQLException ex ) { if ( autoCreate && isConnectionIssue ( ex ) && checkSchema ( ) ) { continue ; } throw ex ; } } stmtUpdate = db . createStatement ( ) ; stmtQuery = db . createStatement ( ResultSet . TYPE_FORWARD_ONLY , ResultSet . CONCUR_READ_ONLY ) ; stmtUpdate . execute ( "USE-`" + schema + "`" ) ; stmtQuery . execute ( "USE-`" + schema + "`" ) ; } \n', 0.3468239938478878)

('public void connect ( ) throws IOException { if ( connected ) return ; PreparedStatement stmt = null ; ResultSet rs = null ; try { stmt = SQLUtils . getDefaultConnection ( ) . prepareStatement ( "SELECT-entryName,-entryImage-FROM-sqlj.jar_entry-WHERE-entryId-=-?" ) ; stmt . setInt ( 1 , m_entryId ) ; rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { m_entryName = rs . getString ( 1 ) ; m_image = rs . getBytes ( 2 ) ; connected = true ; } else throw new FileNotFoundException ( "jarId-=-" + m_entryId ) ; } catch ( SQLException e ) { throw new IOException ( e . getMessage ( ) ) ; } finally { SQLUtils . close ( rs ) ; SQLUtils . close ( stmt ) ; } } \n', 0.3428209720501336)

('@ Override public void connect ( ) throws IOException { if ( connected ) { return ; } PreparedStatement stmt = null ; ResultSet rs = null ; try { stmt = SQLUtils . getDefaultConnection ( ) . prepareStatement ( "SELECT-entryName,-entryImage-FROM-sqlj.jar_entry-WHERE-entryId-=-?" ) ; stmt . setInt ( 1 , m_entryId ) ; rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { m_entryName = rs . getString ( 1 ) ; m_image = rs . getBytes ( 2 ) ; connected = true ; } else { throw new FileNotFoundException ( "jarId-=-" + m_entryId ) ; } } catch ( SQLException e ) { throw new IOException ( e . getMessage ( ) ) ; } finally { SQLUtils . close ( rs ) ; SQLUtils . close ( stmt ) ; } } \n', 0.3428209720501336)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 54 #################################
('public void persistRepositoryConfigurations ( ) throws IOException { for ( final RepositoryConfiguration repositoryConfig : repositories . values ( ) ) { if ( ! repositoryConfig . isPersisted ( ) ) { final File configDir = getConfigurationDirectoryForRepository ( repositoryConfig . getName ( ) ) ; if ( ! configDir . exists ( ) && ! configDir . mkdirs ( ) ) { throw new IOException ( "Unable-to-create-directory:-" + configDir . getAbsolutePath ( ) ) ; } final File configFile = new File ( configDir , configurationFilename ) ; logger . info ( "Storing-configuration:-" + configFile . getAbsolutePath ( ) ) ; FileOutputStream fileOutputStream = null ; try { fileOutputStream = new FileOutputStream ( configFile ) ; final Properties configProperties = repositoryConfig . getAsProperties ( ) ; logger . debug ( "Storing-properties:-" + configProperties ) ; configProperties . store ( fileOutputStream , "" ) ; fileOutputStream . flush ( ) ; repositoryConfig . setPersisted ( ) ; } finally { IOUtils . closeQuietly ( fileOutputStream ) ; } } } } \n', 0.31452670811026223)

('public void deletePersistentStore ( ) { try { close ( ) ; } catch ( IOException e ) { } try { deleteLogFile ( version ) ; } catch ( LogException e ) { } try { deleteSnapshot ( version ) ; } catch ( LogException e ) { } try { deleteFile ( fName ( versionFile ) ) ; } catch ( LogException e ) { } try { dir . delete ( ) ; } catch ( SecurityException e ) { } } \n', 0.3083472164892713)

('public PersistentDynamicObjectCache ( final DataModel dataModel , final File input ) throws IOException { if ( ! input . exists ( ) ) return ; final DataInputStream dataInputStream = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( input ) ) ) ; try { final int version = dataInputStream . readInt ( ) ; if ( version != 0 ) return ; final int size = dataInputStream . readInt ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final PersistentDynamicObject persistentDynamicObject = PersistentDynamicObject . read ( dataInputStream , dataModel ) ; _objectsById . put ( persistentDynamicObject . getId ( ) , persistentDynamicObject ) ; final String pid = persistentDynamicObject . getPid ( ) ; if ( pid . length ( ) > 0 ) { _objectsByPid . put ( pid , persistentDynamicObject ) ; } } } finally { dataInputStream . close ( ) ; } } \n', 0.30808911591360366)

('public void registerPersistenceDelegates ( ApplicationContext context ) { final Map < Class < ? > , PersistenceDelegate > persistentDelegates = context . getLocalStorage ( ) . getPersistentDelegates ( ) ; persistentDelegates . put ( SortKeyState . class , new DefaultPersistenceDelegate ( new String [ ] { "sortOrder" , "modelIndex" } ) ) ; persistentDelegates . put ( ColumnState . class , new DefaultPersistenceDelegate ( new String [ ] { "width" , "preferredWidth" , "modelIndex" , "visible" , "viewIndex" } ) ) ; persistentDelegates . put ( XProperties . XTableState . class , new DefaultPersistenceDelegate ( new String [ ] { "sortOrder" , "modelIndex" } ) ) ; persistentDelegates . put ( XTableState . class , new DefaultPersistenceDelegate ( new String [ ] { "columnStates" , "sortKeyState" , "horizontalScrollEnabled" } ) ) ; persistentDelegates . put ( ArrayListModel . class , new XMLEncoder ( System . out ) . getPersistenceDelegate ( List . class ) ) ; final PrimitivePersistenceDelegate primitivePersistenceDelegate = new PrimitivePersistenceDelegate ( ) ; persistentDelegates . put ( URL . class , new PrimitivePersistenceDelegate ( ) ) ; persistentDelegates . put ( File . class , primitivePersistenceDelegate ) ; } \n', 0.29195816492959387)

('public void saveToPersistent ( ) throws MLException { Gson gson = new Gson ( ) ; String jsonString = gson . toJson ( mClassifiers ) ; try { FileOutputStream fos = mContext . openFileOutput ( Constants . CLASSIFIER_STORAGE_FILE , Context . MODE_PRIVATE ) ; OutputStreamWriter osw = new OutputStreamWriter ( fos ) ; osw . write ( jsonString ) ; osw . flush ( ) ; osw . close ( ) ; } catch ( FileNotFoundException e ) { throw new MLException ( MLException . IO_FILE_NOT_FOUND_ERROR , "Classifier-file-not-found." ) ; } catch ( IOException e ) { throw new MLException ( MLException . IO_ERROR , "IO-exception-while-writing-internal-storage." ) ; } } \n', 0.29084368951892037)

('public static Map < URI , OptimisticNamedQuery > persist ( File dataDir ) throws RepositoryException { Map < URI , PersistentNamedQuery > map = PersistentNamedQuery . persist ( dataDir ) ; Map < URI , OptimisticNamedQuery > optimisticMap = new HashMap < URI , OptimisticNamedQuery > ( ) ; for ( URI uri : map . keySet ( ) ) { optimisticMap . put ( uri , new OptimisticNamedQuery ( map . get ( uri ) ) ) ; } return optimisticMap ; } \n', 0.29063117660452886)

('void persistCreationMeta ( File outputDir , long crc ) throws IOException { final File crcFile = new File ( outputDir , V1Constants . SEGMENT_CREATION_META ) ; final DataOutputStream out = new DataOutputStream ( new FileOutputStream ( crcFile ) ) ; out . writeLong ( crc ) ; long creationTime = System . currentTimeMillis ( ) ; try { long configCreationTime = Long . parseLong ( config . getCreationTime ( ) ) ; if ( 0L < configCreationTime ) { creationTime = configCreationTime ; } } catch ( Exception nfe ) { } out . writeLong ( creationTime ) ; out . close ( ) ; } \n', 0.2894427992493757)

('public final Integer numberOfCachesThatAreDiskPersistent ( ) { int count = 0 ; Set cacheConfigurations = configuration . getCacheConfigurations ( ) . entrySet ( ) ; for ( Iterator iterator = cacheConfigurations . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iterator . next ( ) ; CacheConfiguration cacheConfiguration = ( CacheConfiguration ) entry . getValue ( ) ; if ( cacheConfiguration . isDiskPersistent ( ) ) { count ++ ; } } return Integer . valueOf ( count ) ; } \n', 0.2876370188462472)

('public long flushMemoryCacheToPersistent ( File file ) throws IOException { ObjectOutputStream outputStream = null ; outputStream = new ObjectOutputStream ( new BufferedOutputStream ( new FileOutputStream ( file ) , 4096 ) ) ; outputStream . writeObject ( mHash ) ; outputStream . flush ( ) ; outputStream . close ( ) ; return file . length ( ) ; } \n', 0.28632025900366553)

('private void addPersistedFile ( long fileId ) { synchronized ( mLock ) { mPersistedFiles . add ( fileId ) ; } } \n', 0.2857388656706499)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 55 #################################
('public static String findReplaceIgnoreCase ( String searchMe , String pattern , String delimiter ) { Pattern pat = Pattern . compile ( pattern , Pattern . CASE_INSENSITIVE ) ; Matcher matcher = pat . matcher ( searchMe ) ; StringBuffer sb = new StringBuffer ( ) ; if ( matcher . find ( ) ) { matcher . appendReplacement ( sb , pattern ) ; if ( delimiter != null ) { if ( matcher . end ( ) != searchMe . length ( ) ) { sb . append ( delimiter ) ; } } matcher . appendTail ( sb ) ; return sb . toString ( ) ; } else { return searchMe ; } } \n', 0.3982900753465509)

('public static boolean containsCaseInSensitive ( String haystack , String needle ) { return Pattern . compile ( Pattern . quote ( needle ) , Pattern . CASE_INSENSITIVE ) . matcher ( haystack ) . find ( ) ; } \n', 0.3687558905881548)

('public static String caseInsensitiveSubstring ( String value , String regularExpression ) throws SQLException { try { Pattern p = Pattern . compile ( regularExpression , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( ( value == null ) ? "" : value ) ; if ( m . find ( ) ) return m . group ( 1 ) ; return "" ; } catch ( IndexOutOfBoundsException e ) { return value ; } catch ( PatternSyntaxException e ) { throw new SQLException ( "Pattern-syntax-exception:-" + e . getMessage ( ) ) ; } } \n', 0.36188210027456286)

('private Pattern getWordPattern ( final WordSearchQueryImpl searchQuery ) { final Set < Character > usedLetters = searchQuery . getUsedLetters ( ) ; final StringBuilder usedLettersRegexBuilder = new StringBuilder ( ) ; final String usedLettersRegex ; final StringBuilder regexStringBuilder = new StringBuilder ( ) ; if ( usedLetters . isEmpty ( ) ) { usedLettersRegexBuilder . append ( "." ) ; } else { usedLettersRegexBuilder . append ( "[^" ) ; for ( final char usedLetter : usedLetters ) { usedLettersRegexBuilder . append ( usedLetter ) ; } usedLettersRegexBuilder . append ( "]" ) ; } usedLettersRegex = usedLettersRegexBuilder . toString ( ) ; for ( int charIdx = 0 ; charIdx < searchQuery . getWordLength ( ) ; charIdx ++ ) { final Character knownLetter = searchQuery . getKnownLetters ( ) . get ( charIdx ) ; regexStringBuilder . append ( knownLetter != null ? knownLetter : usedLettersRegex ) ; } return Pattern . compile ( regexStringBuilder . toString ( ) , Pattern . CASE_INSENSITIVE ) ; } \n', 0.3503134772038529)

('public static boolean containsIgnoreCase ( String str , String substring ) { boolean contains = false ; if ( str != null && substring != null ) { contains = Pattern . compile ( Pattern . quote ( substring ) , Pattern . CASE_INSENSITIVE ) . matcher ( str ) . find ( ) ; } return contains ; } \n', 0.34986473245252764)

('public static Pattern caseInsensitive ( String pattern ) { return Pattern . compile ( pattern , Pattern . CASE_INSENSITIVE ) ; } \n', 0.34838204171411646)

('public Pattern getFilenamePattern ( ) { if ( filenamePattern == null && filename != null && filename . length ( ) > 0 ) { int flags = 0 ; String pattern = filename ; if ( ! filenameRegex ) { pattern = Utils . escapeRegexMetaChar ( pattern ) ; } flags |= filenameMatch ? flags : Pattern . CASE_INSENSITIVE ; filenamePattern = Pattern . compile ( pattern , flags ) ; } return filenamePattern ; } \n', 0.34571233854169936)

('public static String caseInsensitiveReplace ( String source , String target , String replacement ) { StringBuilder sbSource = new StringBuilder ( source ) ; StringBuilder sbSourceLower = new StringBuilder ( source . toLowerCase ( ) ) ; String searchString = target . toLowerCase ( ) ; int idx = 0 ; while ( ( idx = sbSourceLower . indexOf ( searchString , idx ) ) != - 1 ) { sbSource . replace ( idx , idx + searchString . length ( ) , replacement ) ; sbSourceLower . replace ( idx , idx + searchString . length ( ) , replacement ) ; idx += replacement . length ( ) ; } sbSourceLower . setLength ( 0 ) ; sbSourceLower . trimToSize ( ) ; sbSourceLower = null ; return sbSource . toString ( ) ; } \n', 0.34450632546679266)

('public static String upperCaseWordFirst ( String str ) { StringBuffer sb = new StringBuffer ( ) ; Matcher m = Pattern . compile ( "([a-z])([a-z]*)" , Pattern . CASE_INSENSITIVE ) . matcher ( str ) ; while ( m . find ( ) ) { m . appendReplacement ( sb , m . group ( 1 ) . toUpperCase ( ) + m . group ( 2 ) . toLowerCase ( ) ) ; } str = m . appendTail ( sb ) . toString ( ) ; return str ; } \n', 0.3438332003480482)

('CaseInsensitivePartialStringComparisionMatcher ( String textToMatch ) { this . textToMatch = textToMatch ; this . pattern = Pattern . compile ( Pattern . quote ( textToMatch ) , Pattern . CASE_INSENSITIVE ) ; } \n', 0.34352824198139376)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 56 #################################
('private Node selectMedian ( Graph g ) { int index = 0 ; double [ ] tempArr = new double [ nvl . length ] ; for ( int i = 0 ; i < nvl . length ; i ++ ) { tempArr [ i ] = nvl [ i ] ; } Arrays . sort ( tempArr ) ; double median = tempArr [ nvl . length / 2 ] ; for ( int i = 0 ; i < nvl . length ; i ++ ) { if ( nvl [ i ] == median ) { index = i ; break ; } } return g . getNode ( index ) ; } \n', 0.36502362156533763)

('private List < T > selectMedian ( List < T > list , int dim , int pos ) { if ( list . size ( ) == 1 ) { return list ; } int pivotIndex = ( int ) ( Math . random ( ) * list . size ( ) ) ; double pivot = list . get ( pivotIndex ) . getDimension ( dim ) ; ArrayList < T > SL = new ArrayList < T > ( ) ; ArrayList < T > SV = new ArrayList < T > ( ) ; ArrayList < T > SR = new ArrayList < T > ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( list . get ( i ) . getDimension ( dim ) < pivot ) { SL . add ( list . get ( i ) ) ; } else if ( list . get ( i ) . getDimension ( dim ) > pivot ) { SR . add ( list . get ( i ) ) ; } else { SV . add ( list . get ( i ) ) ; } } if ( pos < SL . size ( ) ) { return selectMedian ( SL , dim , pos ) ; } else if ( pos >= SL . size ( ) + SV . size ( ) ) { return selectMedian ( SR , dim , pos - SL . size ( ) - SV . size ( ) ) ; } else { return SV ; } } \n', 0.3499892140925923)

('public static int partition ( List < Integer > list , int startIndex , int endIndex ) { int pivotIndex = medianOfThree ( list , startIndex , endIndex ) ; Collections . swap ( list , pivotIndex , startIndex ) ; int i = startIndex + 1 ; for ( int j = startIndex + 1 ; j <= endIndex ; j ++ ) { if ( list . get ( j ) < list . get ( startIndex ) ) { Collections . swap ( list , j , i ) ; i ++ ; } } Collections . swap ( list , startIndex , i - 1 ) ; return i - 1 ; } \n', 0.3474377547044786)

('public static String [ ] [ ] fillInMedian ( String [ ] [ ] dataset , int columnToFill ) { ArrayList < Pair < String , Integer >> timesSeen = new ArrayList < Pair < String , Integer >> ( ) ; for ( int i = 0 ; i < dataset . length ; i ++ ) { int index = Pair . indexOfAPair ( timesSeen , dataset [ i ] [ columnToFill ] . toLowerCase ( ) . trim ( ) ) ; if ( index >= 0 ) { Pair < String , Integer > oldPair = timesSeen . get ( index ) ; Pair < String , Integer > newPair = new Pair < String , Integer > ( oldPair . left , oldPair . right + 1 ) ; timesSeen . set ( index , newPair ) ; } else { Pair < String , Integer > newPair = new Pair < String , Integer > ( dataset [ i ] [ columnToFill ] . toLowerCase ( ) . trim ( ) , 1 ) ; timesSeen . add ( newPair ) ; } } int a = 0 ; String valueToFill = "" ; for ( Pair < String , Integer > p : timesSeen ) { if ( p . right > a && ! p . left . equals ( "-" ) ) { valueToFill = p . left ; a = p . right ; } } fillInValues ( dataset , columnToFill , valueToFill ) ; return dataset ; } \n', 0.34022404571505344)

('public static double [ ] getColumnMedians ( final RealMatrix m ) { Utils . nonNull ( m , "Cannot-calculate-medians-on-a-null-matrix." ) ; final Median medianCalculator = new Median ( ) ; return IntStream . range ( 0 , m . getColumnDimension ( ) ) . boxed ( ) . mapToDouble ( i -> medianCalculator . evaluate ( m . getColumn ( i ) ) ) . toArray ( ) ; } \n', 0.33734742459301736)

('public static String [ ] [ ] fillInMedian ( String [ ] [ ] dataSet , int columnToFill ) { ArrayList < Pair < String , Integer >> timesSeen = new ArrayList < Pair < String , Integer >> ( ) ; for ( int i = 0 ; i < dataSet . length ; i ++ ) { int index = Pair . indexOfAPair ( timesSeen , dataSet [ i ] [ columnToFill ] . toLowerCase ( ) . trim ( ) ) ; if ( index >= 0 ) { Pair < String , Integer > oldPair = timesSeen . get ( index ) ; Pair < String , Integer > newPair = new Pair < String , Integer > ( oldPair . left , oldPair . right + 1 ) ; timesSeen . set ( index , newPair ) ; } else { Pair < String , Integer > newPair = new Pair < String , Integer > ( dataSet [ i ] [ columnToFill ] . toLowerCase ( ) . trim ( ) , 1 ) ; timesSeen . add ( newPair ) ; } } int a = 0 ; String valueToFill = "" ; for ( Pair < String , Integer > p : timesSeen ) { if ( p . right > a && ! p . left . equals ( "-" ) ) { valueToFill = p . left ; a = p . right ; } } fillInValues ( dataSet , columnToFill , valueToFill ) ; return dataSet ; } \n', 0.33565105809579093)

('private static Object findMedian ( List list ) { if ( list . size ( ) < 1 ) { return null ; } Object median ; Collections . sort ( list ) ; int index = - 1 ; index = ( int ) list . size ( ) / 2 ; if ( ( list . size ( ) % 2 ) == 0 ) { Object input1 = list . get ( index - 1 ) ; Object input2 = list . get ( index ) ; if ( ( input1 instanceof Number ) && ( input2 instanceof Number ) ) { Number num1 = ( Number ) input1 ; Number num2 = ( Number ) input2 ; Number [ ] numbers = new Number [ 2 ] ; numbers [ 0 ] = num1 ; numbers [ 1 ] = num2 ; median = CalcUtil . average ( numbers ) ; } else { List newList = new ArrayList ( ) ; newList . add ( input1 ) ; newList . add ( input2 ) ; median = newList ; } } else { median = list . get ( index ) ; } return median ; } \n', 0.33309998744468805)

('private double Median ( Hashtable < SensorType , ArrayList < Double >> data , SensorType sensor , ObjectSegmentation index ) { double median = 0 ; ArrayList < Double > d = new ArrayList < Double > ( ) ; for ( int i = index . start ; i <= index . finish ; i ++ ) if ( ! Double . isNaN ( data . get ( sensor ) . get ( i ) ) ) d . add ( data . get ( sensor ) . get ( i ) ) ; Collections . sort ( d ) ; if ( d . size ( ) % 2 == 0 ) median = ( d . get ( d . size ( ) / 2 ) + d . get ( ( d . size ( ) / 2 ) - 1 ) ) / 2 ; else median = d . get ( d . size ( ) / 2 ) ; return median ; } \n', 0.3325986515741872)

('public void compressMatrixByRowDescriptions ( ) { List < List < Double >> newValList = new ArrayList < List < Double >> ( rowDescrIndexMap . keySet ( ) . size ( ) ) ; List < String > newRowNames = new ArrayList < String > ( rowDescrIndexMap . keySet ( ) . size ( ) ) ; for ( String descr : rowDescrIndexMap . keySet ( ) ) { List < Integer > descrIdxs = rowDescrIndexMap . get ( descr ) ; List < Double > medianValues = new ArrayList < Double > ( data . getColumnDimension ( ) ) ; newValList . add ( medianValues ) ; newRowNames . add ( descr ) ; double [ ] columnValues = new double [ descrIdxs . size ( ) ] ; for ( int j = 0 ; j < data . getColumnDimension ( ) ; j ++ ) { for ( int i = 0 ; i < columnValues . length ; i ++ ) { columnValues [ i ] = data . get ( descrIdxs . get ( i ) , j ) ; } medianValues . add ( Statistics . median ( columnValues ) ) ; } } init ( newValList , newRowNames , getColumnNames ( ) ) ; } \n', 0.33125632673154687)

('static public double median ( double [ ] input ) { double res = 0 ; int [ ] index = new int [ input . length ] ; int len = input . length ; for ( int i = 0 ; i < len ; i ++ ) index [ i ] = i ; bubbleSort ( input , index ) ; if ( ( len % 2 ) == 1 ) { res = input [ len / 2 ] ; } else { res = ( input [ len / 2 ] + input [ len / 2 - 1 ] ) / 2 ; } return res ; } \n', 0.32827979992804535)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 57 #################################
('private byte [ ] filter ( byte [ ] unfiltered , FilterType filterType ) throws InvalidFormatException { ByteHolder filtered = new ByteHolder ( unfiltered . length + 1 ) ; switch ( filterMethod ) { case ADAPTIVE : filtered . add ( ( byte ) filterType . dataValue ( ) ) ; filtered . add ( filterType . filter ( unfiltered , lastData , getBpp ( ) ) ) ; break ; default : throw new InvalidFormatException ( "Bad-filter-method!" , "png" ) ; } lastData = unfiltered ; return filtered . toArray ( ) ; } \n', 0.3764645501302265)

('public static Object [ ] filterArray ( Object [ ] array ) { ArrayList < Object > list = new ArrayList < > ( array . length ) ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( ! filterItem ( array [ i ] ) ) { list . add ( array [ i ] ) ; } } return list . toArray ( ( Object [ ] ) Array . newInstance ( array . getClass ( ) . getComponentType ( ) , list . size ( ) ) ) ; } \n', 0.3757407422281108)

('public static Object [ ] filterArray ( Object [ ] array ) { ArrayList list = new ArrayList ( array . length ) ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( ! filterItem ( array [ i ] ) ) { list . add ( array [ i ] ) ; } } return list . toArray ( ( Object [ ] ) Array . newInstance ( array . getClass ( ) . getComponentType ( ) , array . length ) ) ; } \n', 0.37256239287363657)

('public static < T > Object [ ] filter ( T [ ] elems , Filter < T > filter ) { List < T > filtered = new ArrayList < T > ( ) ; for ( int i = 0 ; i < elems . length ; i ++ ) { if ( filter . accept ( elems [ i ] ) ) { filtered . add ( elems [ i ] ) ; } } return ( filtered . toArray ( ( Object [ ] ) Array . newInstance ( elems . getClass ( ) . getComponentType ( ) , filtered . size ( ) ) ) ) ; } \n', 0.37039968787237343)

('public ArrayList < Object > filter ( Object filter ) { ArrayList < Object > filtered = new ArrayList < Object > ( ) ; for ( Object c : index ) { if ( matchesFilter ( c , filter ) ) { filtered . add ( c ) ; } } return filtered ; } \n', 0.36520151488308883)

('protected Object [ ] filter ( ViewerFilter [ ] filters , Object [ ] elements ) { if ( filters != null ) { ArrayList filtered = new ArrayList ( elements . length ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { boolean add = true ; for ( int j = 0 ; j < filters . length ; j ++ ) { add = filters [ j ] . select ( null , null , elements [ i ] ) ; if ( ! add ) break ; } if ( add ) filtered . add ( elements [ i ] ) ; } return filtered . toArray ( ) ; } return elements ; } \n', 0.36435890097828266)

('protected Object [ ] filter ( Object [ ] elements ) { if ( filters != null ) { ArrayList filtered = new ArrayList ( elements . length ) ; Object root = getRoot ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { boolean add = true ; for ( int j = 0 ; j < filters . size ( ) ; j ++ ) { add = ( ( ViewerFilter ) filters . get ( j ) ) . select ( this , root , elements [ i ] ) ; if ( ! add ) { break ; } } if ( add ) { filtered . add ( elements [ i ] ) ; } } return filtered . toArray ( ) ; } return elements ; } \n', 0.35531489327755744)

('public final Object [ ] filter ( final Object [ ] objects ) { final Collection filtered = filter ( Arrays . asList ( objects ) ) ; try { return filtered . toArray ( ( Object [ ] ) Array . newInstance ( objects . getClass ( ) , filtered . size ( ) ) ) ; } catch ( ArrayStoreException ase ) { Log log = LogFactory . getLog ( Filter . class ) ; log . warn ( "Error-converting-to-array---using-default-approach" , ase ) ; } return filtered . toArray ( ) ; } \n', 0.35243756676107674)

('public static Parameter [ ] filter ( final Parameter [ ] parameters , final Set < InjectableParameter > filters ) { if ( filters != null && ! filters . isEmpty ( ) ) { boolean firstMethodFiltered = false ; final List < Parameter > filterList = new ArrayList < > ( parameters . length ) ; for ( final Parameter parameter : parameters ) { boolean omit = false ; for ( final InjectableParameter injectableParameter : filters ) { omit = canInject ( parameter , injectableParameter ) ; switch ( injectableParameter ) { case CURRENT_TEST_METHOD : if ( omit && ! firstMethodFiltered ) { firstMethodFiltered = true ; } else { omit = false ; } break ; default : break ; } if ( omit ) { break ; } } if ( ! omit ) { filterList . add ( parameter ) ; } } final Parameter [ ] filteredArray = new Parameter [ filterList . size ( ) ] ; return filterList . toArray ( filteredArray ) ; } else { return parameters ; } } \n', 0.35206271455992644)

('public static < E > Object [ ] filter ( E [ ] elems , Filter < E > filter ) { List < E > filtered = new ArrayList < E > ( ) ; for ( E elem : elems ) { if ( filter . accept ( elem ) ) { filtered . add ( elem ) ; } } return ( filtered . toArray ( ( Object [ ] ) Array . newInstance ( elems . getClass ( ) . getComponentType ( ) , filtered . size ( ) ) ) ) ; } \n', 0.35087673133606845)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 58 #################################
('public static List < ItemAllocatable > getRandomItemFromContainer ( InventoryHolder inventory , Random rand , Block block , List < AllocatorBlock > alLst , Allocator thePlugin ) { List < ItemAllocatable > items = new ArrayList < ItemAllocatable > ( ) ; if ( inventory == null ) { return items ; } int startAt = 0 ; List < ItemStack > itemsTemp = new ArrayList < ItemStack > ( ) ; if ( inventory instanceof Furnace ) { startAt = 2 ; } for ( int k = startAt ; k < inventory . getInventory ( ) . getSize ( ) ; k ++ ) { if ( inventory . getInventory ( ) . getItem ( k ) != null ) { boolean passingFilter = true ; for ( Iterator < AllocatorBlock > iterator = alLst . iterator ( ) ; passingFilter && iterator . hasNext ( ) ; ) { passingFilter = iterator . next ( ) . isPassingFilter ( inventory . getInventory ( ) . getItem ( k ) ) ; } if ( passingFilter ) { itemsTemp . add ( inventory . getInventory ( ) . getItem ( k ) ) ; } } } while ( ! itemsTemp . isEmpty ( ) ) { int r = ( int ) Math . floor ( Math . random ( ) * itemsTemp . size ( ) ) ; items . add ( new ItemAllocatableFromInventory ( itemsTemp . get ( r ) , inventory ) ) ; itemsTemp . remove ( r ) ; } return items ; } \n', 0.4183443039123915)

('static < T > void moveItemsBetweenLists ( final int [ ] indicesOfItemsToMove , final List < T > fromList , final List < T > toList ) { List < T > tmpList = new ArrayList < > ( indicesOfItemsToMove . length ) ; int moveIndexIndex ; for ( moveIndexIndex = 0 ; indicesOfItemsToMove [ moveIndexIndex ] < 0 && moveIndexIndex < indicesOfItemsToMove . length ; ++ moveIndexIndex ) { } int fromListIndex = 0 ; for ( Iterator < T > fromIter = fromList . iterator ( ) ; fromIter . hasNext ( ) && moveIndexIndex < indicesOfItemsToMove . length ; fromListIndex ++ ) { T item = fromIter . next ( ) ; if ( fromListIndex == indicesOfItemsToMove [ moveIndexIndex ] ) { fromIter . remove ( ) ; moveIndexIndex ++ ; tmpList . add ( item ) ; } } for ( T item : tmpList ) { toList . add ( item ) ; } } \n', 0.35226048832250684)

('public Sequence extractItem ( String s ) { Sequence extractSeq = this . copySeqence ( ) ; ItemSet itemSet ; ArrayList < String > items ; ArrayList < ItemSet > deleteItemSets = new ArrayList < > ( ) ; ArrayList < String > tempItems = new ArrayList < > ( ) ; for ( int k = 0 ; k < extractSeq . itemSetList . size ( ) ; k ++ ) { itemSet = extractSeq . itemSetList . get ( k ) ; items = itemSet . getItems ( ) ; if ( items . size ( ) == 1 && items . get ( 0 ) . equals ( s ) ) { extractSeq . itemSetList . remove ( k ) ; break ; } else if ( items . size ( ) > 1 && ! items . get ( 0 ) . equals ( "_" ) ) { if ( items . contains ( s ) ) { int index = items . indexOf ( s ) ; for ( int j = index ; j < items . size ( ) ; j ++ ) { tempItems . add ( items . get ( j ) ) ; } tempItems . set ( 0 , "_" ) ; if ( tempItems . size ( ) == 1 ) { deleteItemSets . add ( itemSet ) ; } else { extractSeq . itemSetList . set ( k , new ItemSet ( tempItems ) ) ; } break ; } else { deleteItemSets . add ( itemSet ) ; } } else { deleteItemSets . add ( itemSet ) ; } } extractSeq . itemSetList . removeAll ( deleteItemSets ) ; return extractSeq ; } \n', 0.33331571838016594)

('private void buildDaysList ( Calendar dateIn , JComboBox < Integer > daysList , JComboBox < Integer > monthsList ) { daysList . removeAllItems ( ) ; dateIn . set ( Calendar . MONTH , monthsList . getSelectedIndex ( ) ) ; int lastDay = startDate . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; for ( int dayCount = 1 ; dayCount <= lastDay ; dayCount ++ ) daysList . addItem ( dayCount ) ; } \n', 0.3329400679474434)

('@ SuppressWarnings ( "unchecked" ) public void moveItemToOtherList ( ListDisplay < String > listDisplay , ListDisplay < String > destDisplay , ListDisplay < String > ... noDuplicatesDisplays ) { String sel = listDisplay . getSelection ( ) ; if ( sel . isEmpty ( ) ) return ; java . util . ArrayList < String > allItems = ( ArrayList < String > ) ( ( ArrayList < String > ) destDisplay . getAll ( ) ) . clone ( ) ; for ( int li = 0 ; li < allItems . size ( ) ; li ++ ) { allItems . set ( li , allItems . get ( li ) . split ( ARGUMENTSSDELIMITER ) [ 0 ] ) ; } if ( allItems . contains ( sel . split ( ARGUMENTSSDELIMITER ) [ 0 ] ) ) { SWTHelper . alert ( StringTool . leer , Messages . Leistungscodes_definitionAlreadyExistsInDestination ) ; return ; } for ( ListDisplay < String > noDuplicatesList : noDuplicatesDisplays ) { java . util . ArrayList < String > allItems2 = ( ArrayList < String > ) ( ( ArrayList < String > ) noDuplicatesList . getAll ( ) ) . clone ( ) ; for ( int li = 0 ; li < allItems2 . size ( ) ; li ++ ) { allItems2 . set ( li , allItems2 . get ( li ) . split ( ARGUMENTSSDELIMITER ) [ 0 ] ) ; } if ( allItems2 . contains ( sel . split ( ARGUMENTSSDELIMITER ) [ 0 ] ) ) { SWTHelper . alert ( StringTool . leer , Messages . Leistungscodes_definitionAlreadyExistsSomewhere ) ; return ; } } destDisplay . add ( sel ) ; listDisplay . remove ( sel ) ; } \n', 0.33034907666107943)

('protected List < List < PromotableCandidateItemOffer >> buildItemOfferPermutations ( List < PromotableCandidateItemOffer > offers ) { List < List < PromotableCandidateItemOffer >> listOfOfferLists = new ArrayList < List < PromotableCandidateItemOffer >> ( ) ; listOfOfferLists . add ( offers ) ; if ( offers . size ( ) > 1 ) { List < PromotableCandidateItemOffer > qtyOneOffers = new ArrayList < PromotableCandidateItemOffer > ( offers ) ; Collections . sort ( qtyOneOffers , ItemOfferQtyOneComparator . INSTANCE ) ; for ( int i = 0 ; i < qtyOneOffers . size ( ) ; i ++ ) { if ( qtyOneOffers . get ( i ) != offers . get ( i ) ) { listOfOfferLists . add ( qtyOneOffers ) ; break ; } } } if ( offerListStartsWithNonCombinable ( offers ) ) { List < PromotableCandidateItemOffer > listWithoutTotalitarianOrNonCombinables = new ArrayList < PromotableCandidateItemOffer > ( offers ) ; Iterator < PromotableCandidateItemOffer > offerIterator = listWithoutTotalitarianOrNonCombinables . iterator ( ) ; while ( offerIterator . hasNext ( ) ) { PromotableCandidateItemOffer offer = offerIterator . next ( ) ; if ( offer . getOffer ( ) . isTotalitarianOffer ( ) || ! offer . getOffer ( ) . isCombinableWithOtherOffers ( ) ) { offerIterator . remove ( ) ; } } if ( listWithoutTotalitarianOrNonCombinables . size ( ) > 0 ) { listOfOfferLists . add ( listWithoutTotalitarianOrNonCombinables ) ; } } return listOfOfferLists ; } \n', 0.32619160511526113)

('public static Item [ ] itemsFromBytes ( byte [ ] bytes ) { Item [ ] recoveredItems ; ByteArrayInputStream bs = new ByteArrayInputStream ( bytes ) ; try { ObjectInputStream ois = new ObjectInputStream ( bs ) ; recoveredItems = ( Item [ ] ) ois . readObject ( ) ; } catch ( IOException e ) { throw new RuntimeException ( "Failed-to-recover-items-array-from-bytes." ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( "Failed-to-recover-items-array-from-bytes." ) ; } return recoveredItems ; } \n', 0.3184285331953264)

('public static List < Integer > removeItemsToSplitListEvenly ( final List < Integer > inputList , int maxContiguous ) { List < Integer > itemsToRemove = new ArrayList < Integer > ( ) ; int contiguousCount = inputList . size ( ) ; if ( contiguousCount > maxContiguous ) { int numToRemove = contiguousCount / ( maxContiguous + 1 ) ; int numRuns = numToRemove + 1 ; int numItemsLeft = contiguousCount - numToRemove ; int floorOfEachRun = numItemsLeft / numRuns ; int numOfRunsWithExtra = numItemsLeft - ( floorOfEachRun * numRuns ) ; int offset = 0 ; for ( int i = 0 ; i < numToRemove ; ++ i ) { offset += floorOfEachRun ; if ( i < numOfRunsWithExtra ) offset ++ ; itemsToRemove . add ( inputList . get ( offset ) ) ; offset ++ ; } } return itemsToRemove ; } \n', 0.3146449882623836)

('private Collection < String > extractItemsFromList ( final String s ) { final Collection < String > results = new ArrayList < String > ( ) ; for ( final String item : s . split ( "," ) ) { results . add ( item . trim ( ) ) ; } return results ; } \n', 0.3113652803382277)

('private static void moveListItems ( JList fromList , JList toList , boolean selected ) { DefaultListModel fromModel = ( DefaultListModel ) fromList . getModel ( ) ; DefaultListModel toModel = ( DefaultListModel ) toList . getModel ( ) ; if ( selected ) { int [ ] index = fromList . getSelectedIndices ( ) ; for ( int i = 0 ; i < index . length ; i ++ ) { Object item = fromModel . getElementAt ( index [ i ] ) ; toModel . addElement ( item ) ; } for ( int i = index . length - 1 ; i >= 0 ; i -- ) { fromModel . removeElementAt ( index [ i ] ) ; } } else { Enumeration items = fromModel . elements ( ) ; while ( items . hasMoreElements ( ) ) { toModel . addElement ( items . nextElement ( ) ) ; } fromModel . clear ( ) ; } } \n', 0.30987494877246924)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 59 #################################
('public static String encryptPasswordWithSymmetricEncryption ( String password , String passPhrase ) throws Exception { Cipher aes = Cipher . getInstance ( ALGORITHM_MODE_PADDING ) ; MessageDigest digest = MessageDigest . getInstance ( SHA1_ALGORITHM ) ; digest . update ( passPhrase . getBytes ( ENCODING ) ) ; byte [ ] key = Arrays . copyOf ( digest . digest ( ) , 16 ) ; SecretKeySpec secretKeySpec = new SecretKeySpec ( key , ALGORITHM ) ; aes . init ( Cipher . ENCRYPT_MODE , secretKeySpec , DEFAULT_IV_SPEC ) ; byte [ ] b = aes . doFinal ( password . getBytes ( ENCODING ) ) ; return Base64 . encodeBase64String ( b ) ; } \n', 0.3641564435089455)

('public static String encryptByAes ( String text ) throws NubeException { try { return new String ( Base64 . getEncoder ( ) . encode ( aesCipherForEncrypt . doFinal ( text . getBytes ( ) ) ) ) ; } catch ( Exception e ) { throw new NubeException ( 603 , "encryption_error" , e ) ; } } \n', 0.3589272870927365)

('private static String encryptString ( String message , String passcode ) { String encryptedMessage = "" ; try { byte [ ] encryptMessage = DESEncryptionHelper . encryptMessage ( passcode . getBytes ( ) , message . getBytes ( ) ) ; encryptedMessage = Utilities . getBase64EncodedString ( encryptMessage ) ; } catch ( Exception e ) { } return encryptedMessage ; } \n', 0.3586979737600001)

('public static String decryptPasswordWithSymmetricDecryption ( String encryptedPassword , String passPhrase ) throws Exception { Cipher aes = Cipher . getInstance ( ALGORITHM_MODE_PADDING ) ; MessageDigest digest = MessageDigest . getInstance ( SHA1_ALGORITHM ) ; digest . update ( passPhrase . getBytes ( ENCODING ) ) ; byte [ ] key = Arrays . copyOf ( digest . digest ( ) , 16 ) ; System . err . println ( "key-" + Arrays . toString ( key ) + "-pass-" + passPhrase ) ; SecretKeySpec secretKeySpec = new SecretKeySpec ( key , ALGORITHM ) ; aes . init ( Cipher . DECRYPT_MODE , secretKeySpec , DEFAULT_IV_SPEC ) ; byte [ ] b = aes . doFinal ( Base64 . decodeBase64 ( encryptedPassword ) ) ; return new String ( b , ENCODING ) ; } \n', 0.3573494022457)

('public String encrypt ( String text ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , IllegalBlockSizeException , BadPaddingException , UnsupportedEncodingException , InvalidAlgorithmParameterException { byte [ ] input = text . getBytes ( "UTF-8" ) ; byte [ ] output = null ; int offset = 0 ; byte [ ] iv = null ; switch ( mode ) { case AES : offset = 16 ; break ; case DES : offset = 8 ; break ; default : break ; } iv = new byte [ offset ] ; ( new Random ( ) ) . nextBytes ( iv ) ; Cipher cipher = getCipher ( iv , Cipher . ENCRYPT_MODE ) ; output = cipher . doFinal ( input ) ; int total = output . length + offset ; byte [ ] outputWithIV = new byte [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { if ( i < offset ) { outputWithIV [ i ] = iv [ i ] ; } else { outputWithIV [ i ] = output [ i - offset ] ; } } String ret = Base64 . getEncoder ( ) . encodeToString ( outputWithIV ) ; return ret ; } \n', 0.3572409112937861)

('public synchronized String decryptPassword ( String encryptedPswd ) { String password = null ; if ( encryptedPswd != null ) { ObjectInputStream ois = null ; try { byte [ ] bytePassword = Helper . buildBytesFromHexString ( encryptedPswd ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( bytePassword ) ; CipherInputStream cis = new CipherInputStream ( bais , decryptCipherAES ) ; ois = new ObjectInputStream ( cis ) ; password = ( String ) ois . readObject ( ) ; } catch ( Exception ex ) { try { byte [ ] bytePassword = Helper . buildBytesFromHexString ( encryptedPswd ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( bytePassword ) ; CipherInputStream cis = new CipherInputStream ( bais , decryptCipherDES ) ; ois = new ObjectInputStream ( cis ) ; password = ( String ) ois . readObject ( ) ; ois . close ( ) ; } catch ( IOException e ) { password = encryptedPswd ; } catch ( ArrayIndexOutOfBoundsException e ) { password = encryptedPswd ; } catch ( ConversionException e ) { password = encryptedPswd ; } catch ( Exception e ) { throw ValidationException . errorDecryptingPassword ( e ) ; } } finally { try { if ( ois != null ) { ois . close ( ) ; } } catch ( IOException ioexception ) { } } } return password ; } \n', 0.3515704016993962)

('public static String aes256Decrypt ( String encrypted , String encryptionKey ) { String decrypted = "" ; try { decrypted = AES . decrypt ( HexTobyte ( encrypted ) , encryptionKey ) ; } catch ( Exception e ) { LOGGER . pushErrors ( e , "Decryption-failed." ) ; } return decrypted . split ( "~" ) [ 0 ] ; } \n', 0.34866146634843953)

('public void encryptStream ( InputStream clearInputStream , OutputStream encryptedOutputStream ) throws IOException , MissingParameterException { byte [ ] clearBytes = IOUtils . toByteArray ( clearInputStream ) ; byte [ ] cipherBytes = encryptionProvider . encrypt ( clearBytes ) ; encryptedOutputStream . write ( cipherBytes ) ; encryptedOutputStream . flush ( ) ; encryptedOutputStream . close ( ) ; } \n', 0.3433673032853409)

('public static String decryptNoEC ( String passphrase , byte [ ] encryptedKey ) throws UnsupportedEncodingException , GeneralSecurityException { byte [ ] addressHash = Arrays . copyOfRange ( encryptedKey , 3 , 7 ) ; byte [ ] scryptKey = SCrypt . scrypt ( passphrase . getBytes ( "UTF8" ) , addressHash , 16384 , 8 , 8 , 64 ) ; byte [ ] derivedHalf1 = Arrays . copyOfRange ( scryptKey , 0 , 32 ) ; byte [ ] derivedHalf2 = Arrays . copyOfRange ( scryptKey , 32 , 64 ) ; byte [ ] encryptedHalf1 = Arrays . copyOfRange ( encryptedKey , 7 , 23 ) ; byte [ ] encryptedHalf2 = Arrays . copyOfRange ( encryptedKey , 23 , 39 ) ; byte [ ] k1 = Utils . AESDecrypt ( encryptedHalf1 , derivedHalf2 ) ; byte [ ] k2 = Utils . AESDecrypt ( encryptedHalf2 , derivedHalf2 ) ; byte [ ] keyBytes = new byte [ 32 ] ; for ( int i = 0 ; i < 16 ; i ++ ) { keyBytes [ i ] = ( byte ) ( k1 [ i ] ^ derivedHalf1 [ i ] ) ; keyBytes [ i + 16 ] = ( byte ) ( k2 [ i ] ^ derivedHalf1 [ i + 16 ] ) ; } boolean compressed = ( encryptedKey [ 2 ] & ( byte ) 0x20 ) == 0x20 ; ECKey k = new ECKey ( new BigInteger ( 1 , keyBytes ) , null , compressed ) ; return k . getPrivateKeyEncoded ( params ) . toString ( ) ; } \n', 0.34214446804738186)

('public static String decryptAES ( String cipherText ) { String decryptedText = cipherText ; try { Cipher aesCipher = Cipher . getInstance ( "AES" ) ; aesCipher . init ( Cipher . DECRYPT_MODE , secretKey ) ; InputStream b64is = MimeUtility . decode ( new ByteArrayInputStream ( cipherText . getBytes ( ) ) , "base64" ) ; byte [ ] tmp = new byte [ cipherText . getBytes ( ) . length ] ; int size = b64is . read ( tmp ) ; byte [ ] res = new byte [ size ] ; System . arraycopy ( tmp , 0 , res , 0 , size ) ; decryptedText = new String ( aesCipher . doFinal ( res ) ) ; } catch ( Exception ex ) { Logger . getLogger ( Encryptor . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return decryptedText ; } \n', 0.3419812768684669)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 60 #################################
('@ Override public String getUniqueElementId ( HttpServletRequest request , String namespace , String elementId ) { String uniqueElementId = elementId ; Set < String > uniqueElementIds = ( Set < String > ) request . getAttribute ( WebKeys . UNIQUE_ELEMENT_IDS ) ; if ( uniqueElementIds == null ) { uniqueElementIds = new ConcurrentHashSet < > ( ) ; request . setAttribute ( WebKeys . UNIQUE_ELEMENT_IDS , uniqueElementIds ) ; } else { int i = 1 ; while ( uniqueElementIds . contains ( namespace . concat ( uniqueElementId ) ) ) { if ( Validator . isNull ( elementId ) || elementId . endsWith ( StringPool . UNDERLINE ) ) { uniqueElementId = elementId . concat ( String . valueOf ( i ) ) ; } else { uniqueElementId = elementId . concat ( StringPool . UNDERLINE ) . concat ( String . valueOf ( i ) ) ; } i ++ ; } } uniqueElementIds . add ( namespace . concat ( uniqueElementId ) ) ; return uniqueElementId ; } \n', 0.3425084308880108)

('public static Object uniqueElement ( List list ) throws NonUniqueResultException { int size = list . size ( ) ; if ( size == 0 ) return null ; Object first = list . get ( 0 ) ; for ( int i = 1 ; i < size ; i ++ ) { if ( list . get ( i ) != first ) { throw new NonUniqueResultException ( list . size ( ) ) ; } } return first ; } \n', 0.33576616880834353)

('protected Vector keysForRemovedElement ( Object element ) { if ( count == 0 ) { return null ; } if ( element == null ) { throw new NullPointerException ( ) ; } if ( elements == null ) { return null ; } Vector removedKeys = new Vector ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { Object tmp = elements [ i ] ; if ( tmp != null && tmp != DeletedMarker && element . equals ( tmp ) ) { removedKeys . add ( keys [ i ] ) ; if ( keys . length <= linearSearchThreshold ) { int lastActive = count - 1 ; elements [ i ] = elements [ lastActive ] ; keys [ i ] = keys [ lastActive ] ; elements [ lastActive ] = null ; keys [ lastActive ] = null ; i -- ; } else { keys [ i ] = DeletedMarker ; elements [ i ] = DeletedMarker ; } count -- ; } } return removedKeys ; } \n', 0.3252118382854597)

('protected Tag getUniqueTag ( ItemBase item ) throws OpsException { for ( Tag tag : item . getTags ( ) ) { if ( tag . getKey ( ) . equals ( Tag . UNIQUE_ID ) ) { return tag ; } } throw new OpsException ( "Cannot-find-unique-tag-for-item:-" + item ) ; } \n', 0.32198387166842546)

('public static Set getUniqueElementsAncestry ( Set elementSet ) { assert elementSet != null ; Iterator it = elementSet . iterator ( ) ; EObject container = null ; while ( it . hasNext ( ) ) { container = ( ( EObject ) it . next ( ) ) . eContainer ( ) ; while ( container != null ) { if ( elementSet . contains ( container ) ) { it . remove ( ) ; break ; } container = container . eContainer ( ) ; } } return elementSet ; } \n', 0.3196462764911048)

('private static Set getUniqueElementsAncestry ( Set elementSet ) { Iterator it = elementSet . iterator ( ) ; EObject container = null ; while ( it . hasNext ( ) ) { container = ( ( EObject ) it . next ( ) ) . eContainer ( ) ; while ( container != null ) { if ( elementSet . contains ( container ) ) { it . remove ( ) ; break ; } container = container . eContainer ( ) ; } } return elementSet ; } \n', 0.3196462764911048)

('public Element getUniqueElementByTagName ( Node parent , String childElementTagName ) { List < Element > childElements = getElementsByTagName ( parent , childElementTagName ) ; if ( childElements == null || childElements . size ( ) == 0 ) { return null ; } return ( Element ) childElements . get ( 0 ) ; } \n', 0.31099235216497)

('public static Element getUniqueElement ( Element parent , String tagName ) throws IllegalArgumentException , XMLException { Iterator elements = getElementsByTagName ( parent , tagName ) . iterator ( ) ; if ( elements . hasNext ( ) ) { Element element = ( Element ) elements . next ( ) ; if ( elements . hasNext ( ) ) { throw new XMLException ( "Only-one-"" + tagName + ""-element-expected" ) ; } return element ; } else { throw new XMLException ( "The-"" + tagName + ""-element-was-not-found" ) ; } } \n', 0.3107438083742511)

('public static Object [ ] unique ( Object [ ] elements ) { Hashtable h = new Hashtable ( ) ; Object o = new Object ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { h . put ( elements [ i ] , o ) ; } Object [ ] el2 = new Object [ h . size ( ) ] ; Enumeration e = h . keys ( ) ; int i = 0 ; while ( e . hasMoreElements ( ) ) { el2 [ i ++ ] = e . nextElement ( ) ; } return el2 ; } \n', 0.3071582449664343)

('public static String generateUniqueID ( UIXRenderingContext context ) { MutableInt countObj = ( MutableInt ) getRenderingProperty ( context , _UNIQUE_ID_COUNT_PROPERTY ) ; int count ; if ( countObj == null ) { countObj = new MutableInt ( ) ; count = _getUniqueIDStartingCount ( context ) ; context . setProperty ( MARLIN_NAMESPACE , _UNIQUE_ID_COUNT_PROPERTY , countObj ) ; } else { count = countObj . value ; } countObj . value = count + 1 ; if ( count == 0 ) return _UNIQUE_ID_PREFIX ; StringBuffer buffer = new StringBuffer ( _UNIQUE_ID_PREFIX . length ( ) + 5 ) ; buffer . append ( _UNIQUE_ID_PREFIX ) ; _appendIntAsReversedChars ( buffer , count ) ; return new String ( buffer ) ; } \n', 0.3017649802902319)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 61 #################################
('public static String [ ] [ ] doubleMatrixToStringMatrix ( final double [ ] [ ] matrix ) { String [ ] [ ] ret = new String [ matrix . length ] [ matrix [ 0 ] . length ] ; for ( int i = 0 ; i < matrix . length ; i ++ ) { ret [ i ] = doubleArrayToStringArray ( matrix [ i ] ) ; } return ret ; } \n', 0.3907435150451702)

('public static ArrayList < ArrayList < Integer >> stringMatrixToIntegerMatrix ( ArrayList < ArrayList < String >> matrix ) { ArrayList < ArrayList < Integer >> output = new ArrayList < > ( ) ; for ( ArrayList < String > stringsRow : matrix ) { ArrayList < Integer > row = new ArrayList < > ( ) ; for ( String s : stringsRow ) { Integer i = Integer . parseInt ( s ) ; row . add ( i ) ; } output . add ( row ) ; } return output ; } \n', 0.3847877105659962)

('public static IMatrix < Double > readDoubleMatrix ( BufferedReader reader , IMatrix < Double > example_matrix ) throws IOException { String [ ] numbers = reader . readLine ( ) . split ( "-" ) ; int dim1 = Integer . parseInt ( numbers [ 0 ] ) ; int dim2 = Integer . parseInt ( numbers [ 1 ] ) ; IMatrix < Double > matrix = example_matrix . createMatrix ( dim1 , dim2 ) ; int length = dim1 * dim2 ; for ( int n = 0 ; n < length ; n ++ ) { String line = reader . readLine ( ) ; numbers = line . split ( "-" ) ; if ( numbers . length != 3 ) throw new IOException ( "Expected-three-fields:-" + line ) ; int i = Integer . parseInt ( numbers [ 0 ] ) ; int j = Integer . parseInt ( numbers [ 1 ] ) ; double v = Double . parseDouble ( numbers [ 2 ] ) ; if ( i >= dim1 ) throw new IOException ( "i-=-" + i + "->=-" + dim1 ) ; if ( j >= dim2 ) throw new IOException ( "j-=-" + j + "->=-" + dim2 ) ; matrix . set ( i , j , v ) ; } return matrix ; } \n', 0.38314522535497575)

('public static PPMatrix readPPMatrixFromRawFile ( String s ) { BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( s ) ) ; PPMatrix ret = readPPMatrixFromBufferedReader ( in ) ; in . close ( ) ; return ret ; } catch ( Exception e ) { throw new RuntimeException ( "File-" + s + "-not-found!" ) ; } } \n', 0.3800591674085436)

('public double [ ] [ ] confusionMatrix ( ) { double [ ] [ ] newMatrix = new double [ m_ConfusionMatrix . length ] [ 0 ] ; for ( int i = 0 ; i < m_ConfusionMatrix . length ; i ++ ) { newMatrix [ i ] = new double [ m_ConfusionMatrix [ i ] . length ] ; System . arraycopy ( m_ConfusionMatrix [ i ] , 0 , newMatrix [ i ] , 0 , m_ConfusionMatrix [ i ] . length ) ; } return newMatrix ; } \n', 0.3778165088808644)

('public static IMatrix < Float > readFloatMatrix ( BufferedReader reader , IMatrix < Float > example_matrix ) throws IOException { String [ ] numbers = reader . readLine ( ) . split ( "-" ) ; int dim1 = Integer . parseInt ( numbers [ 0 ] ) ; int dim2 = Integer . parseInt ( numbers [ 1 ] ) ; IMatrix < Float > matrix = example_matrix . createMatrix ( dim1 , dim2 ) ; int length = dim1 * dim2 ; for ( int n = 0 ; n < length ; n ++ ) { String line = reader . readLine ( ) ; numbers = line . split ( "-" ) ; if ( numbers . length != 3 ) throw new IOException ( "Expected-three-fields:-" + line ) ; int i = Integer . parseInt ( numbers [ 0 ] ) ; int j = Integer . parseInt ( numbers [ 1 ] ) ; Float v = Float . parseFloat ( numbers [ 2 ] ) ; if ( i >= dim1 ) throw new IOException ( "i-=-" + i + "->=-" + dim1 ) ; if ( j >= dim2 ) throw new IOException ( "j-=-" + j + "->=-" + dim2 ) ; matrix . set ( i , j , v ) ; } return matrix ; } \n', 0.37528398014981385)

('public String [ ] [ ] intMatrixToString ( int [ ] [ ] intMatrix ) { String [ ] [ ] stringMatrix = new String [ size ] [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { stringMatrix [ i ] [ j ] = Integer . toString ( intMatrix [ i ] [ j ] ) ; } } return stringMatrix ; } \n', 0.375227688339704)

('public static RealMatrix toRotationMatrix ( List < Double > angles ) { double dimDouble = ( 1.0 + sqrt ( 1.0 + 8.0 * angles . size ( ) ) ) / 2.0 ; int dim = ( int ) Math . floor ( dimDouble ) ; RealMatrix left , right ; left = MatrixTools . identity ( dim ) ; right = new Array2DRowRealMatrix ( dim , dim ) ; int k = 0 ; for ( int j = dim - 2 ; j >= 0 ; j -- ) for ( int i = j + 1 ; i < dim ; i ++ ) { right = elementary ( dim , i , j , angles . get ( k ) ) ; left = left . multiply ( right ) ; k ++ ; } return left ; } \n', 0.37488638614306)

('static public IMatrix < Integer > readIntegerMatrix ( BufferedReader reader , IMatrix < Integer > example_matrix ) throws IOException { String [ ] numbers = reader . readLine ( ) . split ( "-" ) ; int dim1 = Integer . parseInt ( numbers [ 0 ] ) ; int dim2 = Integer . parseInt ( numbers [ 1 ] ) ; IMatrix < Integer > matrix = example_matrix . createMatrix ( dim1 , dim2 ) ; int length = dim1 * dim2 ; for ( int n = 0 ; n < length ; n ++ ) { String line = reader . readLine ( ) ; numbers = line . split ( "-" ) ; if ( numbers . length != 3 ) throw new IOException ( "Expected-three-fields:-" + line ) ; int i = Integer . parseInt ( numbers [ 0 ] ) ; int j = Integer . parseInt ( numbers [ 1 ] ) ; Integer v = Integer . parseInt ( numbers [ 2 ] ) ; if ( i >= dim1 ) throw new IOException ( "i-=-" + i + "->=-" + dim1 ) ; if ( j >= dim2 ) throw new IOException ( "j-=-" + j + "->=-" + dim2 ) ; matrix . set ( i , j , v ) ; } return matrix ; } \n', 0.3744685408713302)

('public static final Complex [ ] fromMatrixToArray ( final Complex [ ] [ ] matrix , int maxRow , int maxCol ) { Complex [ ] returnValue = new Complex [ maxRow * maxCol ] ; for ( int i = 0 ; i < maxRow ; i ++ ) { System . arraycopy ( matrix [ i ] , 0 , returnValue , i * maxCol , maxCol ) ; } return returnValue ; } \n', 0.3731603198675082)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 62 #################################
('public static String htmlEscapeAllowEntities ( String text ) { StringBuilder escaped = new StringBuilder ( ) ; boolean firstSegment = true ; for ( String segment : text . split ( "&" , - 1 ) ) { if ( firstSegment ) { firstSegment = false ; escaped . append ( htmlEscape ( segment ) ) ; continue ; } int entityEnd = segment . indexOf ( \';\' ) ; if ( entityEnd > 0 && segment . substring ( 0 , entityEnd ) . matches ( HTML_ENTITY_REGEX ) ) { escaped . append ( "&" ) . append ( segment . substring ( 0 , entityEnd + 1 ) ) ; escaped . append ( htmlEscape ( segment . substring ( entityEnd + 1 ) ) ) ; } else { escaped . append ( "&amp;" ) . append ( htmlEscape ( segment ) ) ; } } return escaped . toString ( ) ; } \n', 0.42727888843847994)

('public static RawData escapeHtml ( Object o ) { return escapeHTML ( o ) ; } \n', 0.41458440169359856)

('public static String htmlEscapeAllowEntities ( String text ) { StringBuilder escaped = new StringBuilder ( ) ; boolean firstSegment = true ; for ( String segment : text . split ( "&" , - 1 ) ) { if ( firstSegment ) { firstSegment = false ; escaped . append ( htmlEscape ( segment ) ) ; continue ; } int entityEnd = segment . indexOf ( \';\' ) ; if ( entityEnd > 0 && segment . substring ( 0 , entityEnd ) . matches ( HTML_ENTITY_REGEX ) ) { escaped . append ( "&" ) . append ( segment . substring ( 0 , entityEnd + 1 ) ) ; escaped . append ( htmlEscape ( segment . substring ( entityEnd + 1 ) ) ) ; } else { escaped . append ( "&amp;" ) . append ( htmlEscape ( segment ) ) ; } } return escaped . toString ( ) ; } \n', 0.40953367441935956)

('public static String escapeProblemHtmlCharacters ( String string , String secondaryReplacementString ) { String [ ] charactersToReplace = { "<p>" , "</p>" , "<br>" , "<li>" , "</li>" , "<ul>" , "</ul>" , "<br/>" , "<h1>" , "</h1>" , "<h2>" , "</h2>" , "<h3>" , "</h3>" , "<h4>" , "</h4>" , "-" } ; String [ ] replacementCharacters = { "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" } ; string = nullToBlank ( string ) ; secondaryReplacementString = nullToBlank ( secondaryReplacementString ) ; string = blankToString ( string , secondaryReplacementString ) ; for ( int i = 0 ; i < charactersToReplace . length ; i ++ ) { string = replace ( string , charactersToReplace [ i ] , replacementCharacters [ i ] ) ; } return string ; } \n', 0.4075402221432307)

('protected String escapeHtmlEntities ( CharSequence orig ) { StringBuffer buff = new StringBuffer ( orig ) ; EntityTable defaultEntityTable = EntityTable . getDefaultEntityTable ( ) ; Matcher matcher = Pattern . compile ( "|&|w+|;" ) . matcher ( orig ) ; int delta = 0 ; while ( matcher . find ( ) ) { String name = matcher . group ( ) . substring ( 0 , matcher . group ( ) . length ( ) - 1 ) ; int code = defaultEntityTable . entityCode ( name ) ; if ( 0 != code ) { String replacement = "&#" + code + ";" ; buff . replace ( matcher . start ( ) - delta , matcher . end ( ) - delta , replacement ) ; delta = delta + matcher . group ( ) . length ( ) - replacement . length ( ) ; } } return buff . toString ( ) ; } \n', 0.40569205517143747)

('private String escapeHTMLEntities ( String buf ) { StringBuilder tmpBuf = new StringBuilder ( buf . length ( ) + 20 ) ; for ( int i = 0 ; i < buf . length ( ) ; i ++ ) { char ch = buf . charAt ( i ) ; if ( ch == \'<\' ) { tmpBuf . append ( "&lt;" ) ; } else if ( ch == \'>\' ) { tmpBuf . append ( "&gt;" ) ; } else if ( ch == \'|"\' ) { tmpBuf . append ( "&quot;" ) ; } else if ( ch == \'&\' ) { boolean isEntity = false ; StringBuilder entityBuf = new StringBuilder ( ) ; if ( i < buf . length ( ) - 1 ) { for ( int j = i ; j < buf . length ( ) ; j ++ ) { char ch2 = buf . charAt ( j ) ; if ( Character . isLetterOrDigit ( ch2 ) || ( ch2 == \'#\' && j == i + 1 ) || ch2 == \';\' || ch2 == \'&\' ) { entityBuf . append ( ch2 ) ; if ( ch2 == \';\' ) { isEntity = true ; break ; } } else { break ; } } } if ( isEntity ) { tmpBuf . append ( entityBuf ) ; i = i + entityBuf . length ( ) - 1 ; } else { tmpBuf . append ( "&amp;" ) ; } } else { tmpBuf . append ( ch ) ; } } return tmpBuf . toString ( ) ; } \n', 0.4030646843078586)

('public static String replaceHTMLEntities ( String s ) { if ( s == null ) { return null ; } else { if ( s != null ) { for ( int i = 0 ; i < HTML_ENTITIES . length ; i ++ ) { s = s . replace ( HTML_ENTITIES [ i ] [ 1 ] , HTML_ENTITIES [ i ] [ 0 ] ) ; } } return s ; } } \n', 0.40287934249499124)

('public static String escapeHTML ( String s , boolean escapeAmpersand ) { return Utilities . escapeHTML ( s , escapeAmpersand ) ; } \n', 0.4027289649127028)

('public static final String htmlEscape ( String nonHTMLsrc ) { if ( nonHTMLsrc == null ) return null ; StringBuffer res = new StringBuffer ( ) ; int l = nonHTMLsrc . length ( ) ; int idx ; char c ; for ( int i = 0 ; i < l ; i ++ ) { c = nonHTMLsrc . charAt ( i ) ; idx = entityMap . indexOf ( c ) ; if ( idx == - 1 ) { res . append ( c ) ; } else { res . append ( quickEntities [ idx ] ) ; } } return res . toString ( ) ; } \n', 0.4023647189441713)

('public static String unescapeHTML ( String str ) { StringBuilder rtn = new StringBuilder ( ) ; int posStart = - 1 ; int posFinish = - 1 ; while ( ( posStart = str . indexOf ( \'&\' , posStart ) ) != - 1 ) { int last = posFinish + 1 ; posFinish = str . indexOf ( \';\' , posStart ) ; if ( posFinish == - 1 ) break ; rtn . append ( str . substring ( last , posStart ) ) ; if ( posStart + 1 < posFinish ) { rtn . append ( unescapeHTMLEntity ( str . substring ( posStart + 1 , posFinish ) ) ) ; } else { rtn . append ( "&;" ) ; } posStart = posFinish + 1 ; } rtn . append ( str . substring ( posFinish + 1 ) ) ; return rtn . toString ( ) ; } \n', 0.4004434456967965)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 63 #################################
('public static String convertJSONToXML ( String rawJSON , String rootName , String encoding ) { XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( rawJSON ) ; serializer . setRootName ( rootName ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json , encoding ) ; return xml ; } \n', 0.4520262156989096)

('public static String convertAmeticJSONToXML ( String rawJSON , String encoding ) { String jsonData = fixDateFormats ( rawJSON ) ; XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( jsonData ) ; serializer . setRootName ( "AmeticEvent" ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json , encoding ) ; return xml ; } \n', 0.44469413235706723)

('public static String jsonToXml ( String xmlString , String rootElement ) throws Exception { try { JSONObject jso = new JSONObject ( xmlString ) ; rootElement = Val . chkStr ( rootElement ) ; if ( "" . equals ( rootElement ) ) { rootElement = "gptJsonXml" ; } String xml = XML . toString ( jso , "gptJsonXml" ) ; StreamSource source = new StreamSource ( new StringReader ( xml ) ) ; StringWriter writer = new StringWriter ( ) ; StreamResult result = new StreamResult ( writer ) ; Transformer transformer = TransformerFactory . newInstance ( ) . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . ENCODING , "UTF-8" ) ; transformer . setOutputProperty ( OutputKeys . INDENT , "yes" ) ; transformer . transform ( source , result ) ; return Val . chkStr ( writer . toString ( ) ) ; } catch ( Exception e ) { throw e ; } } \n', 0.44160544192714646)

('public static JSONObject xmlToJSON ( String xml ) { return ( ( JSONObject ) new XMLSerializer ( ) . read ( xml ) ) ; } \n', 0.4410089235442416)

('private JSON xmlToJson ( String xml ) throws JSONException { XMLSerializer xmlSerializer = new XMLSerializer ( ) ; xmlSerializer . setRemoveNamespacePrefixFromElements ( true ) ; xmlSerializer . setSkipNamespaces ( true ) ; return xmlSerializer . read ( xml ) ; } \n', 0.4357251399372226)

('@ Deprecated public String ConvertToXML ( String jsonData ) { XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( jsonData ) ; serializer . setRootName ( "xmlOutput" ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json ) ; return xml ; } \n', 0.43323196962330557)

('@ Deprecated private String ConvertToXML ( String jsonData ) { XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( jsonData ) ; serializer . setRootName ( "xmlOutput" ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json ) ; return xml ; } \n', 0.43323196962330557)

('private JSON _contentAsXML ( ) { try { XMLSerializer xmlSerializer = new XMLSerializer ( ) ; JSON json = xmlSerializer . read ( contentAsString ( ) ) ; return json ; } catch ( Exception e ) { throw new ArgumentErrorException ( "???json?" ) ; } } \n', 0.4227697900738613)

('protected Object serializeArgumentToJson ( Object pArg ) { if ( pArg == null ) { return null ; } else if ( pArg instanceof JSONAware ) { return pArg ; } else if ( pArg . getClass ( ) . isArray ( ) ) { return serializeArray ( pArg ) ; } else if ( pArg instanceof Map ) { return serializeMap ( ( Map ) pArg ) ; } else if ( pArg instanceof Collection ) { return serializeCollection ( ( Collection ) pArg ) ; } else { return pArg instanceof Number || pArg instanceof Boolean ? pArg : pArg . toString ( ) ; } } \n', 0.422628344427562)

('public static JsonObject xmlToJson ( @ NotNull String xml ) throws TransformerException { StringWriter out = new StringWriter ( xml . length ( ) ) ; Transformer transformer = TRANSFORMER_FACTORY . newTransformer ( new StreamSource ( new StringReader ( XSLT ) ) ) ; transformer . transform ( new StreamSource ( new StringReader ( xml ) ) , new StreamResult ( out ) ) ; return new JsonObject ( out . toString ( ) ) ; } \n', 0.4210437901093837)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 64 #################################
('private static String urlEncode ( String source ) { try { return URLEncoder . encode ( source , Charsets . UTF_8 . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( "Unsupported-charset-(UTF-8)." , e ) ; } } \n', 0.4475508042801667)

('public static String urlEncode ( String str ) { try { return URLEncoder . encode ( str , Charsets . UTF_8 . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { return str ; } } \n', 0.4472848651582435)

('public static String urlEncode ( String value ) { try { return URLEncoder . encode ( value , Charsets . UTF_8 . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { return value ; } } \n', 0.44532310042932566)

('public static String urlEncode ( String s ) { try { return URLEncoder . encode ( s , StandardCharsets . UTF_8 . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( "get-a-jdk-that-actually-supports-utf-8" , e ) ; } } \n', 0.4431191350546038)

('public static String urlEncode ( String value ) { if ( value == null ) { return "" ; } try { return URLEncoder . encode ( value , CharEncoding . UTF_8 ) ; } catch ( UnsupportedEncodingException ex ) { throw new RuntimeException ( ex ) ; } } \n', 0.44189882521155727)

('public static String urlEncode ( String s , String format ) { String encodedString = s ; if ( s != null ) { try { encodedString = URLEncoder . encode ( s , format ) ; } catch ( UnsupportedEncodingException e ) { encodedString = s ; } } return encodedString ; } \n', 0.4418923042367976)

('public static String urlEncode ( String url , String charset ) { try { return URLEncoder . encode ( url , charset ) ; } catch ( UnsupportedEncodingException uee ) { try { return URLEncoder . encode ( url , "us-ascii" ) ; } catch ( UnsupportedEncodingException uee2 ) { log . error ( "URL-could-not-be-encoded!-This-should-NOT-happen!!!" ) ; return url ; } } } \n', 0.4416388855880166)

('public static String urlEncode ( String str ) throws UnsupportedEncodingException { if ( str == null ) { return null ; } else { return URLEncoder . encode ( str , CHARSET ) ; } } \n', 0.4416388855880166)

('public static String urlEncode ( String string ) { if ( string == null ) return null ; try { return URLEncoder . encode ( string , ENCODING_CHARSET ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( "Platform-doesn\'t-support-" + ENCODING_CHARSET , e ) ; } } \n', 0.44127133459642315)

('static String urlEncode ( String string ) { if ( string == null ) return null ; try { return URLEncoder . encode ( string , ENCODING_CHARSET ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( "Platform-doesn\'t-support-" + ENCODING_CHARSET , e ) ; } } \n', 0.44127133459642315)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 65 #################################
('public static Point2D fromYXtoWorldFieldCoordinates ( int y , int x ) { return new Point2D ( x , y + 1 ) ; } \n', 0.33476985860052266)

('private Coordinate displaceFromCornerAwayFromArms ( Coordinate nearPt , Coordinate p1 , Coordinate p2 , double dist ) { Coordinate [ ] corner = orientCorner ( nearPt , p1 , p2 ) ; boolean isInsideCorner = isInsideCorner ( vertexPt , nearPt , corner [ 0 ] , corner [ 1 ] ) ; Vector2D u1 = Vector2D . create ( nearPt , corner [ 0 ] ) . normalize ( ) ; Vector2D u2 = Vector2D . create ( nearPt , corner [ 1 ] ) . normalize ( ) ; double cornerAng = u1 . angle ( u2 ) ; double maxAngToBisec = maxAngleToBisector ( cornerAng ) ; Vector2D bisec = u2 . rotate ( cornerAng / 2 ) ; if ( ! isInsideCorner ) { bisec = bisec . multiply ( - 1 ) ; double outerAng = 2 * Math . PI - cornerAng ; maxAngToBisec = maxAngleToBisector ( outerAng ) ; } Vector2D pointwiseDisplacement = Vector2D . create ( nearPt , vertexPt ) . normalize ( ) ; double stretchAng = pointwiseDisplacement . angleTo ( bisec ) ; double stretchAngClamp = MathUtil . clamp ( stretchAng , - maxAngToBisec , maxAngToBisec ) ; Vector2D cornerDisplacement = bisec . rotate ( - stretchAngClamp ) . multiply ( dist ) ; return cornerDisplacement . translate ( vertexPt ) ; } \n', 0.3219687602258792)

('public int [ ] calculateOffsetCoordinates ( int ... coordinates ) { return calculateOffsetCoordinates ( coordinateOffset , coordinates ) ; } \n', 0.32111453836459225)

('public Point addToCoordinates ( final double longitude , final double latitude ) { this . getCoordinates ( ) . add ( new Coordinate ( longitude , latitude ) ) ; return this ; } \n', 0.3200740154715396)

('public static RegionCoordinates fromPosition ( Position position ) { return new RegionCoordinates ( position . getTopLeftRegionX ( ) , position . getTopLeftRegionY ( ) ) ; } \n', 0.3195258080813394)

('public Point addToCoordinates ( final double longitude , final double latitude , final double altitude ) { this . getCoordinates ( ) . add ( new Coordinate ( longitude , latitude , altitude ) ) ; return this ; } \n', 0.31326811808324717)

('private void flickFromCenter ( WebDriverLikeRequest request , Dimension screenSize , double speedX , double speedY ) { Point fromPoint = CoordinateUtils . getScreenCenter ( screenSize ) ; double duration = Math . min ( fromPoint . getX ( ) / Math . abs ( speedX ) , fromPoint . getY ( ) / Math . abs ( speedY ) ) ; Point toPoint = new Point ( ( int ) ( fromPoint . getX ( ) + speedX * duration ) , ( int ) ( fromPoint . getY ( ) + speedY * duration ) ) ; toPoint = CoordinateUtils . forcePointOnScreen ( toPoint , screenSize ) ; setJS ( fromToTemplate . generate ( request . getSession ( ) , fromPoint . getX ( ) , fromPoint . getY ( ) , toPoint . getX ( ) , toPoint . getY ( ) , duration ) ) ; } \n', 0.31306554824237653)

('public Point addToCoordinates ( final String coordinates ) { this . getCoordinates ( ) . add ( new Coordinate ( coordinates ) ) ; return this ; } \n', 0.31251306740730983)

('public static List fromCoordinateArrays ( List coordArrays , GeometryFactory fact ) { List geomList = new ArrayList ( ) ; for ( Iterator i = coordArrays . iterator ( ) ; i . hasNext ( ) ; ) { Coordinate [ ] coords = ( Coordinate [ ] ) i . next ( ) ; Geometry geom = toLineOrPoint ( coords , fact ) ; geomList . add ( geom ) ; } return geomList ; } \n', 0.3123007462082899)

('private static Coordinate [ ] toCoordinates ( Collection < TDWay > linestrings ) { Coordinate [ ] [ ] temp = new Coordinate [ linestrings . size ( ) ] [ ] ; int i = 0 ; int n = 0 ; for ( TDWay tdWay : linestrings ) { temp [ i ] = JTSUtils . toCoordinates ( tdWay ) ; n += temp [ i ] . length ; ++ i ; } Coordinate [ ] res = new Coordinate [ n ] ; int pos = 0 ; for ( i = 0 ; i < temp . length ; i ++ ) { System . arraycopy ( temp [ i ] , 0 , res , pos , temp [ i ] . length ) ; pos += temp [ i ] . length ; } return res ; } \n', 0.31051143958064464)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 66 #################################
('private void copyFiles ( ) { File newEmoticonDir = new File ( Spark . getLogDirectory ( ) . getParentFile ( ) , "xtra/emoticons" ) . getAbsoluteFile ( ) ; newEmoticonDir . mkdirs ( ) ; File [ ] files = EMOTICON_DIRECTORY . listFiles ( ) ; for ( File file : files ) { if ( file . isFile ( ) ) { try { File newFile = new File ( newEmoticonDir , file . getName ( ) ) ; long installerFile = file . lastModified ( ) ; long copiedFile = newFile . lastModified ( ) ; int endIndex = file . getName ( ) . indexOf ( ".zip" ) ; if ( endIndex > 0 ) { String unzipURL = file . getName ( ) . substring ( 0 , endIndex ) ; File unzipFile = new File ( newEmoticonDir , unzipURL ) ; if ( ! unzipFile . exists ( ) ) { expandNewPack ( newFile , newEmoticonDir ) ; } } } catch ( Exception e ) { Log . error ( e ) ; } } } EMOTICON_DIRECTORY = newEmoticonDir ; } \n', 0.2991665008913623)

('protected String addCrawlJobBasedonJar ( final File jarFile , final String name , final String description , final String seeds ) throws IOException , FatalConfigurationException { if ( jarFile == null || ! jarFile . exists ( ) ) { throw new FileNotFoundException ( jarFile . getAbsolutePath ( ) ) ; } File dir = File . createTempFile ( Heritrix . class . getName ( ) , ".expandedjar" , TMPDIR ) ; dir . delete ( ) ; dir . mkdir ( ) ; try { org . archive . crawler . util . IoUtils . unzip ( jarFile , dir ) ; File orderFile = new File ( dir , "order.xml" ) ; if ( ! orderFile . exists ( ) ) { throw new IOException ( "Missing-order:-" + orderFile . getAbsolutePath ( ) ) ; } CrawlJob job = createCrawlJobBasedOn ( orderFile , name , description , seeds ) ; File seedsFile = new File ( dir , "seeds.txt" ) ; if ( seedsFile . exists ( ) ) { FileUtils . copyFiles ( seedsFile , new File ( job . getDirectory ( ) , seedsFile . getName ( ) ) ) ; } addCrawlJob ( job ) ; return job . getUID ( ) ; } catch ( RuntimeException e ) { logger . severe ( "problem-adding-crawl-job-from-order-jar-" + jarFile + ":-" + e ) ; throw new FatalConfigurationException ( e . toString ( ) ) ; } finally { org . archive . util . FileUtils . deleteDir ( dir ) ; } } \n', 0.29900933202829005)

('private static void cleanupTempDirectory ( String appUnzipDir ) { File tempDirector = new File ( appUnzipDir ) ; if ( tempDirector . isDirectory ( ) ) { File [ ] entries = tempDirector . listFiles ( ) ; int size = entries . length ; for ( int i = 0 ; i < size ; i ++ ) { try { FileUtils . deleteDirectory ( entries [ i ] ) ; } catch ( IOException e ) { log . warn ( "Could-not-build-lib-artifact-for-path-:-" + entries [ i ] . getAbsolutePath ( ) ) ; } } } } \n', 0.29515348243912104)

('@ Override public void storeFiles ( Subject subject , File filesZip ) throws Exception { String zipFileName = filesZip . getName ( ) ; File tmpDir = new File ( System . getProperty ( "java.io.tmpdir" ) ) ; File dir = FileUtil . createTempDirectory ( zipFileName . substring ( 0 , zipFileName . indexOf ( "." ) ) , null , tmpDir ) ; dir . mkdir ( ) ; ZipUtil . unzipFile ( filesZip , dir ) ; for ( File file : dir . listFiles ( ) ) { JPADriftFile driftFile = new JPADriftFile ( file . getName ( ) ) ; try { JPADriftServer . persistDriftFileData ( driftFile , new FileInputStream ( file ) , file . length ( ) ) ; } catch ( Exception e ) { LogFactory . getLog ( getClass ( ) ) . info ( "Skipping-bad-drift-file" , e ) ; } } for ( File file : dir . listFiles ( ) ) { file . delete ( ) ; } boolean deleted = dir . delete ( ) ; if ( ! deleted ) { LogFactory . getLog ( getClass ( ) ) . info ( "Unable-to-delete-" + dir . getAbsolutePath ( ) + ".-This-directory-and-" + "its-contents-are-no-longer-needed.-It-can-be-deleted." ) ; } } \n', 0.2948309104641362)

('@ Override public void saveChangeSetFiles ( final Subject subject , final File changeSetFilesZip ) throws Exception { String zipFileName = changeSetFilesZip . getName ( ) ; File tmpDir = new File ( System . getProperty ( "java.io.tmpdir" ) ) ; File dir = FileUtil . createTempDirectory ( zipFileName . substring ( 0 , zipFileName . indexOf ( "." ) ) , null , tmpDir ) ; dir . mkdir ( ) ; ZipUtil . unzipFile ( changeSetFilesZip , dir ) ; for ( File file : dir . listFiles ( ) ) { fileDAO . save ( file ) ; file . delete ( ) ; } } \n', 0.2948201679455823)

('public static void copyTemplatesAndMaybeGlobusFolder ( ) throws Exception { if ( ! TEMPLATES_AVAILABLE_DIR . exists ( ) || ! GRISU_DIRECTORY . exists ( ) ) { createGrisuDirectories ( ) ; } if ( TEMPLATES_AVAILABLE_DIR . list ( ) . length == 0 ) { myLogger . debug ( "Filling-templates_available-folder-with-a-set-of-base-templates..." ) ; int BUFFER_SIZE = 8192 ; int count ; byte data [ ] = new byte [ BUFFER_SIZE ] ; InputStream in = Init . class . getResourceAsStream ( "/templates_available.zip" ) ; ZipInputStream zipStream = new ZipInputStream ( in ) ; BufferedOutputStream dest = null ; try { ZipEntry entry = null ; while ( ( entry = zipStream . getNextEntry ( ) ) != null ) { if ( ! entry . isDirectory ( ) ) { myLogger . debug ( "Template-name:-" + entry . getName ( ) ) ; File vomses_file = new File ( TEMPLATES_AVAILABLE_DIR , entry . getName ( ) ) ; FileOutputStream fos = new FileOutputStream ( vomses_file ) ; dest = new BufferedOutputStream ( fos , BUFFER_SIZE ) ; while ( ( count = zipStream . read ( data , 0 , BUFFER_SIZE ) ) != - 1 ) { dest . write ( data , 0 , count ) ; } dest . flush ( ) ; dest . close ( ) ; } } } catch ( Exception e ) { myLogger . error ( e ) ; } } else { myLogger . debug ( "Templates-folder-already-contains-files.-Not-copying-any-into-it..." ) ; } try { if ( ! GLOBUS_CONFIG_DIR . exists ( ) ) { unzipFileToDir ( "/globus.zip" , GRISU_DIRECTORY ) ; } } catch ( Exception e ) { myLogger . error ( e ) ; } } \n', 0.2901862537452612)

('private void copyFiles ( ) { File newEmoticonDir = new File ( Spark . getLogDirectory ( ) . getParentFile ( ) , "xtra/emoticons" ) . getAbsoluteFile ( ) ; newEmoticonDir . mkdirs ( ) ; File [ ] files = EMOTICON_DIRECTORY . listFiles ( ) ; for ( File file : files ) { if ( file . isFile ( ) ) { try { File newFile = new File ( newEmoticonDir , file . getName ( ) ) ; long installerFile = file . lastModified ( ) ; long copiedFile = newFile . lastModified ( ) ; if ( installerFile > copiedFile ) { int endIndex = file . getName ( ) . indexOf ( ".zip" ) ; if ( endIndex > 0 ) { String unzipURL = file . getName ( ) . substring ( 0 , endIndex ) ; File unzipFile = new File ( newEmoticonDir , unzipURL ) ; if ( ! unzipFile . exists ( ) ) { URLFileSystem . copy ( file . toURI ( ) . toURL ( ) , newFile ) ; expandNewPack ( newFile , newEmoticonDir ) ; } } } } catch ( IOException e ) { Log . error ( e ) ; } } } EMOTICON_DIRECTORY = newEmoticonDir ; } \n', 0.28792109643281044)

('protected void loadImplementationsInJar ( String parent , InputStream stream , ClassLoader loader , File parentFile ) throws IOException { Set < String > classFiles = classFilesByLocation . get ( parentFile . toString ( ) ) ; if ( classFiles == null ) { classFiles = new HashSet < String > ( ) ; classFilesByLocation . put ( parentFile . toString ( ) , classFiles ) ; JarInputStream jarStream = null ; if ( stream instanceof JarInputStream ) { jarStream = ( JarInputStream ) stream ; } else { jarStream = new JarInputStream ( stream ) ; } JarEntry entry ; while ( ( entry = jarStream . getNextJarEntry ( ) ) != null ) { String name = entry . getName ( ) ; if ( name != null ) { if ( name . endsWith ( ".jar" ) ) { log . debug ( "Found-nested-jar-" + name ) ; File unzippedParent = unzippedJars . get ( parentFile ) ; if ( unzippedParent == null ) { unzippedParent = FileUtil . unzip ( parentFile ) ; unzippedJars . put ( parentFile , unzippedParent ) ; } File nestedJar = new File ( unzippedParent , name ) ; JarInputStream nestedJarStream = new JarInputStream ( new FileInputStream ( nestedJar ) ) ; try { loadImplementationsInJar ( parent , nestedJarStream , loader , nestedJar ) ; } finally { nestedJarStream . close ( ) ; } } else if ( ! entry . isDirectory ( ) && name . endsWith ( ".class" ) ) { classFiles . add ( name . trim ( ) ) ; } } } } for ( String name : classFiles ) { if ( name . contains ( parent ) ) { loadClass ( name , loader ) ; } } } \n', 0.28718065229908685)

('private void unpackPlugins ( ServletContext context ) throws IOException { File pluginsDir = PluginRegistry . getPluginsDir ( ) ; File [ ] archives = pluginsDir . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { if ( name . contains ( "plugin" ) ) return true ; else return false ; } } ) ; File webappDir = new File ( context . getRealPath ( "/" ) ) ; if ( archives != null ) for ( File archive : archives ) { System . out . println ( "Unpack-plugin-" + archive . getName ( ) ) ; ZipUtil . unzip ( archive . getPath ( ) , webappDir . getPath ( ) ) ; FileUtils . forceDelete ( archive ) ; needRestart = true ; } } \n', 0.2842440602430236)

('public static File [ ] unpackAllFiles ( File root , File dest ) { List < File > dirs = new ArrayList < File > ( ) ; files = root . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { return name . toLowerCase ( ) . endsWith ( ".osz" ) ; } } ) ; if ( files == null || files . length < 1 ) { files = null ; return new File [ 0 ] ; } BeatmapWatchService ws = ( Options . isWatchServiceEnabled ( ) ) ? BeatmapWatchService . get ( ) : null ; if ( ws != null ) ws . pause ( ) ; for ( File file : files ) { fileIndex ++ ; String dirName = file . getName ( ) . substring ( 0 , file . getName ( ) . lastIndexOf ( \'.\' ) ) ; File songDir = new File ( dest , dirName ) ; if ( ! songDir . isDirectory ( ) ) { songDir . mkdir ( ) ; unzip ( file , songDir ) ; file . delete ( ) ; dirs . add ( songDir ) ; } } if ( ws != null ) ws . resume ( ) ; fileIndex = - 1 ; files = null ; return dirs . toArray ( new File [ dirs . size ( ) ] ) ; } \n', 0.2775969127386193)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 67 #################################
('private static long convertAlldayUtcToLocal ( Time recycle , long utcTime , String tz ) { if ( recycle == null ) { recycle = new Time ( ) ; } recycle . timezone = Time . TIMEZONE_UTC ; recycle . set ( utcTime ) ; recycle . timezone = tz ; return recycle . normalize ( true ) ; } \n', 0.4081797321872943)

('public static long convertAlldayUtcToLocal ( Time recycle , long utcTime , String tz ) { if ( recycle == null ) { recycle = new Time ( ) ; } recycle . timezone = Time . TIMEZONE_UTC ; recycle . set ( utcTime ) ; recycle . timezone = tz ; return recycle . normalize ( true ) ; } \n', 0.4081797321872943)

('public static long convertTimeToUtc ( long millis , String localTimeZone ) { if ( millis < 0 ) return 0 ; return millis - TimeZone . getTimeZone ( localTimeZone ) . getRawOffset ( ) ; } \n', 0.39784536771297285)

('private long convertUtcToLocal ( Time recycle , long utcTime ) { if ( recycle == null ) { recycle = new Time ( ) ; } recycle . timezone = Time . TIMEZONE_UTC ; recycle . set ( utcTime ) ; recycle . timezone = mTimeZone . getID ( ) ; return recycle . normalize ( true ) ; } \n', 0.391907596766565)

('private long convertExpirationTimeToSeconds ( String expirationTimeString , TimeUnitConfig . Enum timeUnit ) throws IllegalArgumentException { long expirationTime ; try { expirationTime = Long . valueOf ( expirationTimeString . trim ( ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Manual-expiration-time-cannot-be-parsed-due-to-invalid-characters." + "Please-review-it-and-make-sure-it-is-set-correctly." , e ) ; } if ( timeUnit . equals ( TimeUnitConfig . HOURS ) ) { return expirationTime * 3600 ; } else if ( timeUnit . equals ( TimeUnitConfig . MINUTES ) ) { return expirationTime * 60 ; } else { return expirationTime ; } } \n', 0.38973441656693186)

('public static DateTime convertSFTimeToDateTime ( XMLGregorianCalendar soapTime ) { return new DateTime ( soapTime . getYear ( ) , soapTime . getMonth ( ) , soapTime . getDay ( ) , soapTime . getHour ( ) , soapTime . getMinute ( ) , soapTime . getSecond ( ) , soapTime . getMillisecond ( ) , DateTimeZone . UTC ) ; } \n', 0.38831936157506997)

('public long convertUTCto ( TimeZone timeZoneToConvertTo , long timeToConvert ) { int millisecondsFromUTC = timeZoneToConvertTo . getRawOffset ( ) ; return timeToConvert + millisecondsFromUTC ; } \n', 0.3838242434455176)

('private DateTime convertToUTCIfNecessary ( DateTime date ) { if ( ! date . isUtc ( ) && isUTC ) { if ( date . getTimeZone ( ) != null ) { try { DateTime newDT = new DateTime ( date . toString ( ) , date . getTimeZone ( ) ) ; newDT . setUtc ( true ) ; return newDT ; } catch ( ParseException e ) { } } else { try { DateTime newDT = null ; if ( timezone == null ) newDT = new DateTime ( date . toString ( ) ) ; else newDT = new DateTime ( date . toString ( ) , timezone ) ; newDT . setUtc ( true ) ; return newDT ; } catch ( ParseException e ) { } } } return date ; } \n', 0.3834629614130143)

('public static Date convertNumericToDate ( long dateNumeric , boolean unixEpoch ) { if ( ! unixEpoch ) { long d = 116444736000000000L ; dateNumeric = ( dateNumeric - d ) / 10000000 ; } return convertNumericToDate ( dateNumeric ) ; } \n', 0.38205280971082145)

('public static ZonedDateTime convertToZonedDateTime ( long instant , ZoneId zone ) { if ( instant == Long . MAX_VALUE ) { return LocalDateTime . MAX . atZone ( zone ) ; } if ( instant == Long . MIN_VALUE ) { return LocalDateTime . MIN . atZone ( zone ) ; } return Instant . ofEpochSecond ( 0 , instant ) . atZone ( zone ) ; } \n', 0.38164093338543814)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 68 #################################
('public synchronized long getCurrentIntervalValue ( ) { lock . lock ( ) ; try { return currentValue ; } finally { lock . unlock ( ) ; } } \n', 0.30011086269466253)

('public int getCurrentIntervalValue ( ) { lock . lock ( ) ; try { return currentValue ; } finally { lock . unlock ( ) ; } } \n', 0.30011086269466253)

('private void teardownObservers ( ) { for ( Object o : list ) { if ( o instanceof Observable ) { ( ( Observable ) o ) . deleteObserver ( this ) ; } } } \n', 0.2819221109157162)

('private void notifyObservers ( ) { if ( observable != null ) { observable . notifyObservers ( this ) ; } } \n', 0.28033015523059623)

('public void notifyObservers ( Object obj ) { if ( ! hasChanged ( ) ) return ; Set s ; synchronized ( this ) { s = ( Set ) observers . clone ( ) ; } int i = s . size ( ) ; Iterator iter = s . iterator ( ) ; while ( -- i >= 0 ) ( ( Observer ) iter . next ( ) ) . update ( this , obj ) ; clearChanged ( ) ; } \n', 0.26196278403004414)

('private void notifyAllObservers ( Observable observable ) { observable . notifyObservers ( ) ; this . notifyObservers ( ) ; } \n', 0.2556195964926081)

('public Collection getCurrentValues ( ) { return Collections . unmodifiableCollection ( this . currentValues ) ; } \n', 0.2373326435599319)

('public static IObservable [ ] runAndMonitor ( Runnable runnable , IChangeListener changeListener , IStaleListener staleListener ) { Set < IObservable > lastObservableSet = currentGetterCalledSet . get ( ) ; IChangeListener lastChangeListener = currentChangeListener . get ( ) ; IStaleListener lastStaleListener = currentStaleListener . get ( ) ; Integer lastIgnore = currentIgnoreCount . get ( ) ; Set < IObservable > observableSet = new IdentitySet < > ( ) ; currentGetterCalledSet . set ( observableSet ) ; currentChangeListener . set ( changeListener ) ; currentStaleListener . set ( staleListener ) ; currentIgnoreCount . set ( null ) ; try { runnable . run ( ) ; } finally { currentGetterCalledSet . set ( lastObservableSet ) ; currentChangeListener . set ( lastChangeListener ) ; currentStaleListener . set ( lastStaleListener ) ; checkUnmatchedIgnore ( runnable ) ; currentIgnoreCount . set ( lastIgnore ) ; } return observableSet . toArray ( new IObservable [ observableSet . size ( ) ] ) ; } \n', 0.23242251724607488)

('@ SuppressWarnings ( "unchecked" ) public void notifyObservers ( Object data ) { if ( hasChanged ( ) ) { Vector < Observer > clone = ( Vector < Observer > ) observers . clone ( ) ; int size = clone . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { clone . elementAt ( i ) . update ( this , data ) ; } clearChanged ( ) ; } } \n', 0.2298132212208058)

('public ObservableDoubleValue getLatestObservationObservable ( T type ) { return data . get ( type ) . getObservableLastObservation ( ) ; } \n', 0.21000044845798024)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 69 #################################
('public void printTestAPIComponentsSummary ( ClassDoc [ ] testAPIComponents ) { mOut . println ( "<P>" ) ; mOut . println ( "<TABLE-BORDER="1"-WIDTH="100%"-CELLPADDING="3"-CELLSPACING="0"-SUMMARY="">" ) ; mOut . println ( "<TR-BGCOLOR="#CCCCFF"><TH-ALIGN="left"-COLSPAN="2"><FONT-SIZE="+2"><B>Components-Summary</B></FONT></TH></TR>" ) ; for ( int c = 0 ; c < testAPIComponents . length ; c ++ ) { ClassDoc classDoc = testAPIComponents [ c ] ; String componentName = classDoc . name ( ) ; mOut . print ( "<TR><TD-WIDTH="1%"><CODE><B><A-HREF="components/" + componentName + ".html">" + componentName + "</A></B></CODE></TD><TD>" ) ; printInlineTags ( classDoc . firstSentenceTags ( ) , classDoc ) ; mOut . println ( "</TD>" ) ; } mOut . println ( "</TABLE>" ) ; } \n', 0.3891342518266092)

('private void printModelElements ( Configuration config , String comment ) { LOGGER . debug ( "-------------------" ) ; LOGGER . debug ( comment ) ; for ( IDecisionVariable variable : config ) { printModelElement ( variable ) ; } } \n', 0.3833187258629118)

('public static String printModel ( Node root ) { final StringBuilder builder = new StringBuilder ( ) ; printModel ( builder , root ) ; return builder . toString ( ) ; } \n', 0.3692760377840447)

('private static void printOverallSummaryHeadings ( Writer overallsummary ) { try { overallsummary . write ( "==================-" ) ; overallsummary . write ( "Test-Summary-" ) ; overallsummary . write ( "==================-" ) ; overallsummary . write ( "Scenario-" + "Pass" + "-" + "Fail" + "-" + "Total-" ) ; overallsummary . flush ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } \n', 0.3621442182595307)

('public void printSummary ( PrintWriter out , int numWords ) throws IOException { Formatter buffer = new Formatter ( ) ; ArrayList < TreeSet < IDSorter >> topicSortedWords = model . getSortedWords ( ) ; buffer . format ( "[" ) ; for ( int topic = 0 ; topic < model . numTopics ; topic ++ ) { TreeSet < IDSorter > sortedWords = topicSortedWords . get ( topic ) ; int word = 0 ; Iterator < IDSorter > iterator = sortedWords . iterator ( ) ; buffer . format ( "{"topic":%d,-"smoothing":%f,-"words":{" , topic , model . alpha [ topic ] ) ; while ( iterator . hasNext ( ) && word < numWords ) { IDSorter info = iterator . next ( ) ; buffer . format ( ""%s":-%f" , model . alphabet . lookupObject ( info . getID ( ) ) , info . getWeight ( ) ) ; if ( iterator . hasNext ( ) && word < numWords - 1 ) { buffer . format ( "," ) ; } word ++ ; } buffer . format ( "}}" ) ; if ( topic < model . numTopics - 1 ) { buffer . format ( "," ) ; } } buffer . format ( "]" ) ; out . println ( buffer ) ; } \n', 0.36028248291606924)

('public void printSummary ( ) throws Exception { _logger . info ( _eval . toSummaryString ( "-" + _folds + "-fold-Cross-validation-" , false ) ) ; try { _logger . info ( "-" + _eval . toMatrixString ( ) ) ; } catch ( Exception e ) { _logger . info ( "Can-not-create-confusion-matrix-for-" + _config . _classifier + "-using-" + _config . _classValue ) ; } } \n', 0.35876872178288044)

('public void printSummary ( File file , int numWords ) throws IOException { PrintWriter out = new PrintWriter ( new FileWriter ( file ) ) ; printSummary ( out , numWords ) ; out . close ( ) ; } \n', 0.35772023130605385)

('private final void printTableModel ( String jobName ) throws PrinterException { PrinterJob job = PrinterJob . getPrinterJob ( ) ; PageFormat pageFormat = new PageFormat ( ) ; Paper paper = new Paper ( ) ; paper . setSize ( 8.27 * 72 , 11.69 * 72 ) ; paper . setImageableArea ( 0 , 0 , paper . getWidth ( ) , paper . getHeight ( ) ) ; pageFormat . setPaper ( paper ) ; if ( this . gui . jGTIRadioButtonPortrait . isSelected ( ) ) { pageFormat . setOrientation ( PageFormat . PORTRAIT ) ; } else { pageFormat . setOrientation ( PageFormat . LANDSCAPE ) ; } this . pageWidth = ( int ) pageFormat . getWidth ( ) ; this . pageHeight = ( int ) pageFormat . getHeight ( ) ; this . pageCount = getPageCount ( ) ; job . setPrintable ( this , pageFormat ) ; job . setPrintService ( ( PrintService ) this . gui . jGTIComboBoxPrinter . getSelectedItem ( ) ) ; job . setJobName ( jobName ) ; logger . debug ( "handlePrint" , "printing" ) ; job . print ( ) ; logger . debug ( "handlePrint" , "printed" ) ; } \n', 0.35091098598336057)

('private static void printOverallSummaryErrorHeadings ( Writer overallsummary ) { try { overallsummary . write ( "==================-" ) ; overallsummary . write ( "Test-Summary-Errors-" ) ; overallsummary . write ( "==================-" ) ; overallsummary . write ( "Scenario-" + "Error-" ) ; overallsummary . flush ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } \n', 0.3492126045504176)

('public static void printModel ( Object model ) throws Exception { JAXBContext jaxbContext = JAXBContext . newInstance ( "gov.medicaid.domain.model" ) ; Marshaller marshaller = jaxbContext . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , Boolean . TRUE ) ; marshaller . marshal ( model , System . out ) ; } \n', 0.34697913515971546)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 70 #################################
('private static LinearFormula getLinearFormula ( List < PageLinkInfo > allLinkInfo ) { if ( allLinkInfo . size ( ) < MIN_LINKS_TO_JUSTIFY_LINEAR_MAP ) return null ; final PageLinkInfo firstLink = allLinkInfo . get ( 0 ) ; final PageLinkInfo secondLink = allLinkInfo . get ( 1 ) ; if ( allLinkInfo . size ( ) == 2 && Math . max ( firstLink . mPageNum , secondLink . mPageNum ) > 4 ) { return null ; } int deltaX = secondLink . mPageNum - firstLink . mPageNum ; if ( deltaX == 0 ) return null ; int deltaY = secondLink . mPageParamValue - firstLink . mPageParamValue ; int coefficient = deltaY / deltaX ; if ( coefficient == 0 ) return null ; int delta = firstLink . mPageParamValue - coefficient * firstLink . mPageNum ; if ( delta != 0 && delta != - coefficient ) return null ; for ( int i = 2 ; i < allLinkInfo . size ( ) ; i ++ ) { final PageLinkInfo link = allLinkInfo . get ( i ) ; if ( link . mPageParamValue != coefficient * link . mPageNum + delta ) return null ; } return new LinearFormula ( coefficient , delta ) ; } \n', 0.34977611066413006)

('@ Override public void getLinearISA ( Project project , List < PerlNamespaceDefinition > namespaceDefinitions , HashSet < String > recursionMap , ArrayList < String > result ) { for ( PerlNamespaceDefinition namespaceDefinition : namespaceDefinitions ) { String packageName = namespaceDefinition . getPackageName ( ) ; if ( ! recursionMap . contains ( packageName ) ) { recursionMap . add ( packageName ) ; result . add ( packageName ) ; namespaceDefinition . getLinearISA ( recursionMap , result ) ; } } } \n', 0.3237897380121101)

('public static double [ ] solveLinearEquationSymmetric ( double [ ] [ ] matrix , double [ ] vector ) { boolean isUseApacheCommonsMath = true ; if ( isUseApacheCommonsMath ) { DecompositionSolver solver = new CholeskyDecomposition ( new Array2DRowRealMatrix ( matrix , false ) ) . getSolver ( ) ; return solver . solve ( new ArrayRealVector ( vector ) ) . toArray ( ) ; } else { return solveLinearEquation ( matrix , vector ) ; } } \n', 0.32020519177090173)

('private static List < LinearFilterRepresentation > getLinearRepList ( HashMap < SIRStream , LinearFilterRepresentation > kidMap , List < SIRStream > kidList ) { List < LinearFilterRepresentation > repList = new LinkedList < LinearFilterRepresentation > ( ) ; Iterator < SIRStream > kidIter = kidList . iterator ( ) ; while ( kidIter . hasNext ( ) ) { repList . add ( kidMap . get ( kidIter . next ( ) ) ) ; } return repList ; } \n', 0.3098637138764637)

('private Integer linearScore ( String peptide , List < Integer > spectrum ) { Integer rto = 0 ; List < Integer > parsed = new ArrayList < Integer > ( ) ; List < Integer > peptLinearSpect = Arrays . asList ( linearSpectrum ( peptide ) ) ; Map < Integer , Integer > multMapPeptide = multiplicities ( peptLinearSpect ) ; Map < Integer , Integer > multMapSpectrum = multiplicities ( spectrum ) ; for ( Integer mass : peptLinearSpect ) { for ( Integer specValue : spectrum ) { if ( ! parsed . contains ( specValue ) && specValue . intValue ( ) == mass . intValue ( ) ) { parsed . add ( specValue ) ; if ( multMapPeptide . get ( mass ) < multMapSpectrum . get ( mass ) ) { rto += multMapPeptide . get ( mass ) ; } else if ( multMapPeptide . get ( mass ) > multMapSpectrum . get ( mass ) ) { rto += multMapSpectrum . get ( mass ) ; } else { rto += multMapPeptide . get ( mass ) ; } } } } return rto ; } \n', 0.3061118131017878)

('public Quaternion sphericalLinearInterpolation ( Quaternion dest , float lerpFactor , boolean shortest ) { final float EPSILON = 1e3f ; float cos = this . dot ( dest ) ; Quaternion correctedDest = dest ; if ( shortest && cos < 0 ) { cos = - cos ; correctedDest = new Quaternion ( - dest . getX ( ) , - dest . getY ( ) , - dest . getZ ( ) , - dest . getW ( ) ) ; } if ( Math . abs ( cos ) >= 1 - EPSILON ) return normalLinearInterpolation ( correctedDest , lerpFactor , false ) ; float sin = ( float ) Math . sqrt ( 1.0f - cos * cos ) ; float angle = ( float ) Math . atan2 ( sin , cos ) ; float invSin = 1.0f / sin ; float srcFactor = ( float ) Math . sin ( ( 1.0f - lerpFactor ) * angle ) * invSin ; float destFactor = ( float ) Math . sin ( ( lerpFactor ) * angle ) * invSin ; return this . mul ( srcFactor ) . add ( correctedDest ) . mul ( destFactor ) ; } \n', 0.30247990864930363)

('protected List < Double > getCorrelationCoefficients ( final double [ ] [ ] data ) { int n = data . length ; int m = data [ 0 ] . length ; List < Double > correlationCoefficients = new LinkedList < Double > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { double [ ] [ ] x = new double [ n - 1 ] [ m ] ; int k = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) { x [ k ++ ] = data [ j ] ; } } double [ ] [ ] xT = new Array2DRowRealMatrix ( x ) . transpose ( ) . getData ( ) ; correlationCoefficients . add ( MathUtil . createLinearRegression ( xT , data [ i ] ) . calculateRSquared ( ) ) ; } return correlationCoefficients ; } \n', 0.30068454349374457)

('public List < Object > getDefineOrLinear ( ) { if ( defineOrLinear == null ) { defineOrLinear = new ArrayList < Object > ( ) ; } return this . defineOrLinear ; } \n', 0.2989074495383164)

('public static String [ ] getParseLinearDistribution ( String linearDist ) { Matcher m = LINEAR_DISTRIUBTION_PARTS . matcher ( linearDist ) ; if ( ! m . matches ( ) ) { return null ; } List < String > result = new ArrayList < String > ( ) ; for ( int i = 1 ; i <= 5 ; i ++ ) { result . add ( m . group ( i ) ) ; } return CollectionUtils . toArray ( result , String . class ) ; } \n', 0.29719601066351353)

('public LinearGaussian ( Gaussian dist ) throws Exception { this . basemu = dist . getExpectedValue ( ) ; this . coefficients = DoubleFactory2D . dense . make ( 1 , 0 ) ; this . gaussian = ( Gaussian ) dist . copy ( ) ; this . stateLayout = new int [ 1 ] ; for ( int i = 0 ; i < stateLayout . length ; i ++ ) { stateLayout [ i ] = - 1 ; } this . numberDimensions = dist . numberDimensions ; this . numberDiscreteParentDimensions = dist . numberDiscreteParentDimensions ; this . numberDiscreteParentStates = dist . numberDiscreteParentStates ; this . numberStates = dist . numberStates ; this . numberContinuousParentDimensions = dist . numberContinuousParentDimensions ; } \n', 0.2971431149757252)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 71 #################################
('public static String convertFormattedHtmlTextToExcelPlaintext ( String htmlText ) { if ( htmlText == null ) return "" ; htmlText = htmlText . replaceAll ( "<p>" , "" ) ; htmlText = htmlText . replaceAll ( "-" , "" ) ; htmlText = htmlText . replaceAll ( "</p>" , BreakMark ) ; htmlText = htmlText . replaceAll ( "<p-/>" , BreakMark ) ; htmlText = htmlText . replaceAll ( "<br-/>" , BreakMark ) ; htmlText = FormattedText . convertFormattedTextToPlaintext ( htmlText ) ; StringBuilder sb = new StringBuilder ( ) ; int begin_pos = 0 ; int find_pos = 0 ; while ( find_pos > - 1 && find_pos < htmlText . length ( ) ) { find_pos = htmlText . indexOf ( BreakMark , begin_pos ) ; if ( find_pos > - 1 ) { sb . append ( htmlText . subSequence ( begin_pos , find_pos ) ) ; sb . append ( LINEBREAK_EXCEL ) ; find_pos += BreakMark . length ( ) ; begin_pos = find_pos ; } } if ( begin_pos < htmlText . length ( ) ) { sb . append ( htmlText . subSequence ( begin_pos , htmlText . length ( ) - 1 ) ) ; } htmlText = htmlText . replaceAll ( BreakMark , LINEBREAK_EXCEL ) ; return htmlText ; } \n', 0.36534099759716676)

('public String convertSWFToHTML ( InputStream in ) throws Exception { StringWriter out1 = new StringWriter ( ) ; output = new PrintWriter ( out1 ) ; TagParser parser = new TagParser ( this ) ; SWFReader reader = new SWFReader ( parser , in ) ; reader . readFile ( ) ; in . close ( ) ; sizeCount = reader . size ; final String ret = "<html>" + ( headerstr . isEmpty ( ) ? "<body>" : "<header>" + headerstr + "</header><body>" ) + out1 . toString ( ) + "</body></html>" ; return ret ; } \n', 0.3523894391694895)

('public static byte [ ] convertToMSCfHtml ( String html ) throws UnsupportedEncodingException { html = "<!--StartFragment-->" + html + "<!--EndFragment-->-\x00" ; byte [ ] bHtml = html . getBytes ( "UTF-8" ) ; int htmlLen = bHtml . length ; StringBuffer buf = new StringBuffer ( HTML_CLIPBOARD_FORMAT_HEADER ) ; setValueInHeader ( buf , "StartHTML" , HEADER_LENGTH - 1 ) ; setValueInHeader ( buf , "EndHTML" , HEADER_LENGTH + htmlLen - 1 ) ; setValueInHeader ( buf , "StartFragment" , HEADER_LENGTH - 1 ) ; setValueInHeader ( buf , "EndFragment" , HEADER_LENGTH + htmlLen - 1 ) ; byte [ ] bHeader = buf . toString ( ) . getBytes ( "UTF-8" ) ; byte result [ ] = new byte [ HEADER_LENGTH + htmlLen ] ; System . arraycopy ( bHeader , 0 , result , 0 , bHeader . length ) ; System . arraycopy ( bHtml , 0 , result , bHeader . length , bHtml . length ) ; return result ; } \n', 0.34589779562592804)

("public String convertHTML ( String filename , String inString , String startPattern , String endPattern , Hashtable properties ) { m_tempString = new StringBuffer ( ) ; m_write = true ; m_filename = filename . replace ( '|' , '/' ) ; Reader in = new StringReader ( inString ) ; Writer out = new StringWriter ( ) ; convertHTML ( in , out , startPattern , endPattern , properties ) ; return out . toString ( ) ; } \n", 0.3386896179274002)

('public static String convertToPlainTextNoHTML ( String text ) { String converted = text . replaceAll ( "&amp;" , "&" ) ; for ( Map . Entry < String , String > e : safeHtmlCharacterMap . entrySet ( ) ) { converted = converted . replaceAll ( e . getKey ( ) , e . getValue ( ) ) ; } converted = converted . replaceAll ( "(<br/>)|(<br>)|(</div>)|(</[p|P]>)" , "-" ) ; converted = RemoveTagsPattern . matcher ( converted ) . replaceAll ( "" ) ; return converted ; } \n', 0.3385505302464936)

('public static String convertHtmlTags ( String html ) { html = html . replaceAll ( "<code>" , "<tt>" ) . replaceAll ( "</code>" , "</tt>" ) ; int preIndex = html . indexOf ( "<pre>" ) ; int preEndIndex = - 6 ; StringBuilder bodyConverted = new StringBuilder ( ) ; while ( preIndex != - 1 ) { bodyConverted = bodyConverted . append ( html . substring ( preEndIndex + 6 , preIndex ) ) ; preEndIndex = html . indexOf ( "</pre>" , preIndex ) ; bodyConverted = bodyConverted . append ( html . substring ( preIndex , preEndIndex ) . replaceAll ( "-" , "<br>" ) ) . append ( "</pre>" ) ; preIndex = html . indexOf ( "<pre>" , preEndIndex ) ; } html = bodyConverted . append ( html . substring ( preEndIndex + 6 ) ) . toString ( ) ; html = html . replaceAll ( "<li>(<p>)?" , "&#8226;-" ) . replaceAll ( "(</p>)?</li>" , "<br>" ) ; html = html . replaceAll ( "<strong>" , "<b>" ) . replaceAll ( "</strong>" , "</b>" ) . replaceAll ( "<em>" , "<i>" ) . replaceAll ( "</em>" , "</i>" ) ; return html ; } \n', 0.3382200236142136)

('public static void htmlToPdfFile ( File htmlIn , File pdfOut ) throws Exception { Scanner scanner = new Scanner ( htmlIn ) . useDelimiter ( "|Z" ) ; String htmlContents = scanner . next ( ) ; CYaHPConverter converter = new CYaHPConverter ( ) ; try ( FileOutputStream out = new FileOutputStream ( pdfOut ) ) { Map properties = new HashMap ( ) ; List headerFooterList = new ArrayList ( ) ; properties . put ( IHtmlToPdfTransformer . PDF_RENDERER_CLASS , IHtmlToPdfTransformer . FLYINGSAUCER_PDF_RENDERER ) ; converter . convertToPdf ( htmlContents , IHtmlToPdfTransformer . A3L , headerFooterList , "file:///temp/html/" , out , properties ) ; out . flush ( ) ; } } \n', 0.33444535259530817)

('public static String convertNewLinesToHtml ( String rawString ) { StringBuffer convertedString = new StringBuffer ( rawString . length ( ) ) ; String newLine = "<br>" ; char currChar ; char nextChar ; for ( int i = 0 ; i < rawString . length ( ) ; i ++ ) { currChar = rawString . charAt ( i ) ; if ( ( i + 1 ) < rawString . length ( ) ) { nextChar = rawString . charAt ( i + 1 ) ; } else { nextChar = rawString . charAt ( i ) ; } if ( currChar == 13 ) { convertedString . append ( newLine ) ; if ( nextChar == 10 ) { i ++ ; } } else { convertedString . append ( currChar ) ; } } return convertedString . toString ( ) ; } \n', 0.3338966045504148)

('private void convertDivsToParagraphs ( Document doc , String domType ) { logger . debug ( "Starting-to-replace-bad-divs..." ) ; int divIndex = 0 ; int badDivs = 0 ; int convertedTextNodes = 0 ; Elements divs = doc . getElementsByTag ( domType ) ; for ( Element div : divs ) { try { Matcher divToPElementsMatcher = divToPElementsPattern . matcher ( div . html ( ) . toLowerCase ( ) ) ; if ( divToPElementsMatcher . find ( ) == false ) { replaceElementsWithPara ( doc , div ) ; badDivs += 1 ; } else { ArrayList < Node > replaceNodes = getReplacementNodes ( doc , div ) ; for ( Element child : div . children ( ) ) { child . remove ( ) ; } for ( Node node : replaceNodes ) { try { div . appendChild ( node ) ; } catch ( Exception e ) { logger . error ( e ) ; } } } } catch ( NullPointerException e ) { logger . error ( e . toString ( ) ) ; } divIndex += 1 ; } logger . debug ( "Found-" + divs . size ( ) + "-total-divs-with-" + badDivs + "-bad-divs-replaced-and-" + convertedTextNodes + "-textnodes-converted-inside-divs" ) ; } \n', 0.3250213464225964)

('public static String convertTextToHtml ( String text ) { StringBuilder sb = new StringBuilder ( ) ; text = text . replaceAll ( "-" , "" ) . replaceAll ( "-*" , "-" ) ; for ( int index = 0 ; index < text . length ( ) ; index += 2 ) { int start = index ; index = text . indexOf ( "-" , start ) ; if ( index < 0 ) { index = text . length ( ) ; } String para = text . substring ( start , index ) ; if ( para . length ( ) > 0 ) { sb . append ( "<p>" ) ; sb . append ( convertUrlsToLinks ( para . replace ( "-" , "<br-/>-" ) ) ) ; sb . append ( "</p>-" ) ; } } return sb . toString ( ) ; } \n', 0.3236340532176676)

FRank:   | P@1:   | P@5:   | P@10: 

Mean sims: 0.3712