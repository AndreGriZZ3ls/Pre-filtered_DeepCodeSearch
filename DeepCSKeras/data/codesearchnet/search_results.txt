########################## 1 #################################
('public Cookie createCookie ( String name , String value ) { return new HttpCookie ( name , value ) ; } \n', 0.45034232760405984)

('public static HttpCookie makeCookie ( String name , String value ) { return new HttpCookie ( true , name , value ) ; } \n', 0.43871818473299606)

('TestHttpCookie ( String cHeader ) { this . cHeader = cHeader ; try { List < HttpCookie > cookies = HttpCookie . parse ( cHeader ) ; this . cookies = cookies ; } catch ( IllegalArgumentException ignored ) { cookies = null ; } } \n', 0.4329659311465684)

('TestHttpCookie ( String cHeader ) { assert cHeader != null ; this . cHeader = cHeader ; try { List < HttpCookie > cookies = HttpCookie . parse ( cHeader ) ; this . cookies = cookies ; } catch ( IllegalArgumentException ignored ) { cookies = null ; } } \n', 0.4329659311465684)

('public String createAndStoreCookie ( AuthenticationContext context , long expires , String ipAddr ) { String encodedCookieValue = encodeCookieValue ( context , expires , ipAddr ) ; UUID uuid = UUID . randomUUID ( ) ; COOKIE_CACHE . put ( uuid . toString ( ) , encodedCookieValue ) ; return uuid . toString ( ) ; } \n', 0.43058113089070693)

('private HttpCookie ( Builder builder ) { this ( builder . name , builder . value ) ; setBuilder ( builder ) ; } \n', 0.42757066252267956)

('public static Cookie createCookiePsnTicket ( String psnId ) { psnId = rightPad ( Base64 . encodeToString ( psnId . getBytes ( ) , false ) . replaceAll ( "=" , "" ) . replaceAll ( "=" , "" ) , 40 , \'A\' ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "MQAAAAAAAQcwAAC7AAgAFMAzj73%2FkeHsYc7s%2F2mIW0yw8KbaAAEABAAAAQAABwAIAAABOjiuhlEA%0ABwAIAAABOj3U36AAAgAIMWuXSWuxj08ABAAg" ) . append ( psnId ) . append ( "%0AAAAACAAEdXMAAQAEAARiNgAAAAgAGElWMDAwMS1OUFhTMDEwMDRfMDAAAAAAADARAAQHwgwfAAEA%0ABBkAAgAwEAAAAAAAADACAEQACAAEyS7rGwAIADgwNQIYC0htxjeTFvBo7nPpSPJCwAWjRtzfVa5f%0AAhkAwjEzsDCC0XZBjPz%2FKko5ogByHFzFXnx%2FAA%3D%3D" ) ; return new Builder ( ) . setName ( "PSNS2STICKET" ) . setDomain ( ".playstation.com" ) . setValue ( sb . toString ( ) ) . setMaxAge ( - 1 ) . build ( ) ; } \n', 0.42403311009959266)

('public static Cookie createCookieTicket ( String psnId ) { psnId = rightPad ( Base64 . encodeToString ( psnId . getBytes ( ) , false ) . replaceAll ( "=" , "" ) . replaceAll ( "=" , "" ) , 40 , \'A\' ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "MQAAAAAAAQcwAAC7AAgAFMAzj73%2FkeHsYc7s%2F2mIW0yw8KbaAAEABAAAAQAABwAIAAABOjiuhlEA%0ABwAIAAABOj3U36AAAgAIMWuXSWuxj08ABAAg" ) . append ( psnId ) . append ( "%0AAAAACAAEdXMAAQAEAARiNgAAAAgAGFVQOTAwMi1OUFdBMDAwMzVfMDAAAAAAADARAAQHwgwfAAEA%0ABBkAAgAwEAAPBlNUUkhXSwAAATPOWLloAAAAADACAEQACAAE2%2B8LsgAIADgwNgIZAOCdX0tizuh0%0AaKpHe%2BtLap6jQMmNHw4pnAIZAJnz9fvKhnuM9uUbR5MHrq3i4ALOvWlUoA%3D%3D" ) ; return new Builder ( ) . setName ( "TICKET" ) . setDomain ( ".playstation.com" ) . setValue ( sb . toString ( ) ) . setMaxAge ( - 1 ) . build ( ) ; } \n', 0.4238306956421599)

('public static Cookie createCookie ( String cookieName , @ Sensitive String cookieValue , HttpServletRequest req ) { return createCookie ( cookieName , cookieValue , - 1 , req ) ; }\n', 0.4225020510805666)

('public CookiePolicy createCookiePolicy ( ) { return new CookiePolicy ( ) ; } \n', 0.41722688339928077)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 2 #################################
('public static Properties readPropertiesFromFile ( File file ) throws IOException { try ( FileInputStream fis = new FileInputStream ( file ) ) { Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } }\n', 0.479946652211277)

('void readPropertiesFile ( ) throws PersistitException { readPropertiesFile ( getProperty ( CONFIG_FILE_PROPERTY_NAME , DEFAULT_CONFIG_FILE ) ) ; } \n', 0.4728902416095277)

('public static Properties readPropertiesFromFile ( String propertiesFile ) { try { InputStream in = new FileInputStream ( new File ( propertiesFile ) ) ; return readPropertiesFromInputStream ( new BufferedInputStream ( in ) ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( "File-" + propertiesFile + "-not-found." , e ) ; } } \n', 0.4713664557430076)

('public static void parsePropertiesFile ( String app_properties_file ) throws Exception { Properties props = new Properties ( ) ; try { FileInputStream fis = new FileInputStream ( app_properties_file ) ; props . load ( fis ) ; fis . close ( ) ; } catch ( FileNotFoundException ex ) { System . out . println ( ex ) ; } catch ( IOException ex ) { System . out . println ( ex ) ; } model_path = props . getProperty ( "app.output.path" ) ; if ( null == model_path ) { throw new Exception ( "Can\'t-find-the-model-output-path-in-the-properites-file!" ) ; } schema = props . getProperty ( "tv.floe.metronome.neuralnetwork.conf.InputRecordSchema" ) ; if ( null == schema ) { throw new Exception ( "Can\'t-find-the-input-record-schema-in-the-properites-file!" ) ; } src_input_data_path = props . getProperty ( "tv.floe.metronome.neuralnetwork.conf.evaluate.dataset.path" ) ; if ( null == src_input_data_path ) { throw new Exception ( "Can\'t-find-the-eval/test-recordset-in-the-properites-file!" ) ; } } \n', 0.471041984013634)

('public void readPropertiesFromFile ( File file ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; while ( true ) { Property property = new Property ( ) ; if ( ! property . getFromFile ( reader ) ) { break ; } property . unsetDeprecated ( ) ; add ( property ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } \n', 0.47021665187427897)

('public void readBuildPropertiesFile ( final Properties buildMetaDataProperties ) throws MojoExecutionException { InputStream inStream = null ; try { inStream = new BufferedInputStream ( new FileInputStream ( propertiesOutputFile ) ) ; buildMetaDataProperties . load ( inStream ) ; } catch ( final IOException e ) { throw new MojoExecutionException ( "Cannot-read-provided-properties-file:-" + propertiesOutputFile . getAbsolutePath ( ) , e ) ; } finally { IOUtil . close ( inStream ) ; } } \n', 0.4700649897251628)

('public static Properties readPropertiesFile ( File file ) { Properties prop = null ; InputStream is = null ; try { is = new FileInputStream ( file ) ; prop = new Properties ( ) ; prop . load ( is ) ; } catch ( Exception e ) { prop = null ; } finally { try { if ( is != null ) is . close ( ) ; } catch ( IOException e ) { } } return prop ; } \n', 0.469608291345612)

('public static Properties readPropertiesFile ( File file , Properties defaultConfig ) { if ( ! file . exists ( ) ) { throw new FileDoesNotExistsException ( file ) ; } BufferedInputStream stream = null ; final Properties formatterOptions ; try { stream = new BufferedInputStream ( new FileInputStream ( file ) ) ; formatterOptions = new Properties ( defaultConfig ) ; formatterOptions . load ( stream ) ; } catch ( IOException e ) { throw new RuntimeException ( "config-file-read-error" , e ) ; } finally { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { } } } return formatterOptions ; } \n', 0.46926823182434524)

('ExtendedProperties readPropertiesFromFile ( String fileName ) throws FileNotFoundException , IOException { ExtendedProperties p = new ExtendedProperties ( ) ; FileInputStream in = new FileInputStream ( fileName ) ; p . load ( in ) ; in . close ( ) ; return p ; } \n', 0.4690757293540833)

('private static Properties readProperties ( ) { XMLDecoder d ; Properties p = null ; try { FileInputStream in = new FileInputStream ( "properties.xml" ) ; d = new XMLDecoder ( in ) ; p = ( Properties ) d . readObject ( ) ; d . close ( ) ; in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return p ; } \n', 0.46906955490684893)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 3 #################################
('public String getLoggingConfigurationPath ( ) { String path = System . getProperty ( LOGGING_CONFIGURATION_PATH ) ; if ( path == null || path . trim ( ) . length ( ) == 0 ) { path = DEFAULT_LOGGING_CONFIGURATION_PATH ; } return path ; } \n', 0.4074745154865668)

('public static String getJavawExecutablePath ( ) { if ( java == null ) { java = System . getProperty ( "java.home" ) ; if ( java . endsWith ( "/" ) || java . endsWith ( "|" ) ) java = java . substring ( 0 , java . length ( ) - 2 ) ; java += separator + "bin" + separator + "javaw" ; } return java ; } \n', 0.40298426187641123)

('protected File getExecutableFromPath ( String name ) throws IOException { if ( SystemUtils . IS_OS_WINDOWS ) { name = name + ".exe" ; } String systemPath = System . getenv ( "PATH" ) ; if ( systemPath == null ) { systemPath = System . getenv ( "path" ) ; } if ( systemPath == null ) { throw new IOException ( "Path-is-not-set,-cannot-locate-" + name ) ; } String [ ] paths = systemPath . split ( File . pathSeparator ) ; for ( String pathDir : paths ) { File file = new File ( pathDir , name ) ; if ( file . exists ( ) && file . isFile ( ) && file . canExecute ( ) ) { return file ; } } throw new IOException ( "Could-not-locate-executable-(or-could-locate,-but-does-not-have-execution-rights):-" + name ) ; } \n', 0.40266258349057465)

('private static String getHelpPath ( String appName ) { if ( ( appName == null ) || ( appName . length ( ) == 0 ) ) { return HTML_DIR ; } else { if ( pathPrefix == null ) { return appName ; } else { return ( appName + URL_SEPARATOR + pathPrefix ) ; } } } \n', 0.39933069429492873)

('public static String getScriptDirectory ( ) { return Utils . getProperty ( H2_SCRIPT_DIRECTORY , "" ) ; } \n', 0.3979067887237002)

('public String getDefaultHelpSetPath ( ) { StringBuffer buffer = new StringBuffer ( 1024 ) ; buffer . append ( getLocalizedHelpPath ( ) ) . append ( DEFAULT_HELPSET_NAME ) ; return buffer . toString ( ) ; } \n', 0.397564151599572)

('private String getFullExecutablePath ( ) { StringBuffer pathBuf = new StringBuffer ( ) ; String optionalExecutablePath = getServerProps ( ) . getProperty ( EXECUTABLE_PATH_KEY ) ; if ( optionalExecutablePath == null ) { String basedir = getServerProps ( ) . getProperty ( BASEDIR_KEY ) ; pathBuf . append ( basedir ) ; if ( ! basedir . endsWith ( File . separator ) ) { pathBuf . append ( File . separatorChar ) ; } if ( runningOnWindows ( ) ) { pathBuf . append ( "bin" ) ; } else { pathBuf . append ( "libexec" ) ; } pathBuf . append ( File . separatorChar ) ; } else { pathBuf . append ( optionalExecutablePath ) ; if ( ! optionalExecutablePath . endsWith ( File . separator ) ) { pathBuf . append ( File . separatorChar ) ; } } String executableName = getServerProps ( ) . getProperty ( EXECUTABLE_NAME_KEY , "mysqld" ) ; pathBuf . append ( executableName ) ; return pathBuf . toString ( ) ; } \n', 0.3935444546000719)

('public static URL getHelpURL ( final AtomPlugin atom , final String filename ) { URL urlFile ; String strFilePath ; urlFile = null ; if ( ( atom != null ) && ( filename != null ) ) { strFilePath = \'/\' + atom . getClass ( ) . getPackage ( ) . getName ( ) ; strFilePath = strFilePath . replace ( \'.\' , \'/\' ) ; strFilePath = strFilePath + "/" + InstallationFolder . HELP . getName ( ) + "/" + filename ; strFilePath = strFilePath . replace ( System . getProperty ( "file.separator" ) . charAt ( 0 ) , \'/\' ) ; urlFile = atom . getClass ( ) . getResource ( strFilePath ) ; } return ( urlFile ) ; } \n', 0.39133140023148816)

("private String getSafeIncludePathForOS ( String path ) { String safePath = path . replace ( '|' , '/' ) ; return safePath ; } \n", 0.39035794245484245)

('public static String getApplicationPath ( ) { if ( app_path != null ) { return ( app_path ) ; } String temp_app_path = System . getProperty ( "azureus.install.path" , System . getProperty ( "user.dir" ) ) ; if ( ! temp_app_path . endsWith ( SEP ) ) { temp_app_path += SEP ; } app_path = temp_app_path ; return ( app_path ) ; } \n', 0.38787840564388165)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 4 #################################
('public void betOne ( int nrOfChips , int bettingNr ) { bets . add ( new Bet ( nrOfChips , Arrays . asList ( bettingNr ) ) ) ; } \n', 0.4344953730250949)

('public void betEven ( int nrOfChips ) { List < Integer > result = new ArrayList < > ( ) ; for ( int i = 2 ; i < 37 ; i += 2 ) { result . add ( i ) ; } bets . add ( new Bet ( nrOfChips , result ) ) ; } \n', 0.42455172549332615)

('public void betOdd ( int nrOfChips ) { List < Integer > result = new ArrayList < > ( ) ; for ( int i = 1 ; i < 37 ; i += 2 ) { result . add ( i ) ; } bets . add ( new Bet ( nrOfChips , result ) ) ; } \n', 0.4135569102253577)

('private void generatAllPermutation ( Startup source , List < Startup > newlist , List < Startup > startupList ) { if ( startupList . size ( ) == 0 ) { newlist . add ( 0 , source ) ; graph . add ( newlist ) ; return ; } for ( int i = 0 ; i < startupList . size ( ) ; i ++ ) { List < Startup > tempList2 = new ArrayList < Startup > ( newlist ) ; tempList2 . add ( startupList . get ( i ) ) ; List < Startup > tempList = new ArrayList < Startup > ( startupList ) ; tempList . remove ( i ) ; generatAllPermutation ( source , tempList2 , tempList ) ; } } \n', 0.410642952921933)

('public void reorderGuardians ( ) { for ( int i = 1 ; i <= guardianList . size ( ) ; i ++ ) { GuardianExtended currentGuardian = guardianList . get ( i - 1 ) ; currentGuardian . setGuardianOrder ( i ) ; } } \n', 0.4104969438667138)

('protected final List < int [ ] > partitions ( int total , int dimension ) { ArrayList < int [ ] > result = new ArrayList < int [ ] > ( ) ; if ( dimension == 1 ) { result . add ( new int [ ] { total } ) ; } else { for ( int i = 0 ; i <= total ; i ++ ) { List < int [ ] > pi = partitions ( total - i , dimension - 1 ) ; result . addAll ( insertBefore ( i , pi ) ) ; } } return result ; } \n', 0.4098594697956568)

('public static < T > List < T > josephusPermutation ( final List < T > items , final int k ) { List < T > result = new ArrayList < > ( ) ; while ( items . size ( ) > 0 ) { for ( int i = 0 ; i < k - 1 ; i ++ ) items . add ( items . remove ( 0 ) ) ; result . add ( items . remove ( 0 ) ) ; } return result ; } \n', 0.4072697981339923)

('public void forAllTeams ( UnaryOperator < MGTeamsModifier > operator ) { team_actions . add ( operator ) ; } \n', 0.40436375338914976)

('private void reorder ( ) { Collections . shuffle ( subControllersAndSamplers ) ; } \n', 0.40372844539186215)

('static public List < CoreMap > reorderBuckets ( List < CoreMap > results , int sentenceTooShort , int nerTooFew ) { List < CoreMap > newResults = new ArrayList < CoreMap > ( ) ; List < CoreMap > goodBucket = new ArrayList < CoreMap > ( ) ; List < CoreMap > crappyBucket = new ArrayList < CoreMap > ( ) ; for ( CoreMap result : results ) { if ( sentenceLength ( result ) <= sentenceTooShort || countNER ( result ) <= nerTooFew ) crappyBucket . add ( result ) ; else goodBucket . add ( result ) ; } newResults . addAll ( goodBucket ) ; newResults . addAll ( crappyBucket ) ; return newResults ; } \n', 0.4026625067342088)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 5 #################################
('public String printRegDate ( ) { return this . regDate == null ? "" : DateTools . df . format ( this . regDate ) ; } \n', 0.39125353912851485)

('protected String formattedDate ( Date date ) { DateFormat df = new SimpleDateFormat ( "d-MMM-yyyy" ) ; return df . format ( date ) ; } \n', 0.3809174238213261)

('private String printDate ( Calendar cal , boolean isTimeUsed ) { SimpleDateFormat df = new SimpleDateFormat ( ) ; if ( isTimeUsed ) { df . applyPattern ( "dd/MM/yyyy-HH:mm" ) ; } else df . applyPattern ( "dd/MM/yyyy" ) ; return df . format ( cal . getTime ( ) ) ; } \n', 0.38036108928528334)

('public static String printFedoraDateString ( Date date ) { return FEDORA_DATE_FORMAT . format ( date ) ; } \n', 0.37852495145447823)

('@ SuppressWarnings ( "deprecation" ) @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( 29 ) ; format ( ( getYear ( ) + 1900 ) , 4 , sb ) ; sb . append ( \'-\' ) ; format ( ( getMonth ( ) + 1 ) , 2 , sb ) ; sb . append ( \'-\' ) ; format ( getDate ( ) , 2 , sb ) ; sb . append ( \'-\' ) ; format ( getHours ( ) , 2 , sb ) ; sb . append ( \':\' ) ; format ( getMinutes ( ) , 2 , sb ) ; sb . append ( \':\' ) ; format ( getSeconds ( ) , 2 , sb ) ; sb . append ( \'.\' ) ; if ( nanos == 0 ) { sb . append ( \'0\' ) ; } else { format ( nanos , 9 , sb ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == \'0\' ) { sb . setLength ( sb . length ( ) - 1 ) ; } } return sb . toString ( ) ; } \n', 0.378023270364543)

('public static String formatDate ( Date date ) { SimpleDateFormat formatter = new SimpleDateFormat ( "yyyyMMdd" ) ; String strDate = formatter . format ( date ) ; return strDate ; } \n', 0.3779962076611085)

('private String formattedDate ( Date d ) { return d == null ? "" : SIMPLE_DATE_FORMAT . format ( d ) ; } \n', 0.37716139068304977)

('private String formatDate ( Date date ) { SimpleDateFormat dateFormat = new SimpleDateFormat ( DATE_FMT_STR ) ; return dateFormat . format ( date ) ; } \n', 0.37705930877034444)

('public static String formatDate ( String dateFormat , String date , String toFormat ) { String formatted = "" ; java . text . DateFormat formatter = new SimpleDateFormat ( dateFormat ) ; try { Date dateStr = formatter . parse ( date ) ; formatted = formatter . format ( dateStr ) ; Date formatDate = formatter . parse ( formatted ) ; formatter = new SimpleDateFormat ( toFormat ) ; formatted = formatter . format ( formatDate ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return formatted ; } \n', 0.37686581634906047)

('private String formatDate ( String epochString ) { if ( epochString == null || epochString . trim ( ) . length ( ) == 0 ) return "" ; long epochSeconds = Long . parseLong ( epochString ) ; return dateFormat . format ( new Date ( epochSeconds ) ) ; } \n', 0.3757318903384274)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 6 #################################
('public void tblMouseClickAction ( MouseEvent me ) { if ( me . getClickCount ( ) >= 2 ) { editWindow . show ( tblViewTable . getItems ( ) . get ( tblViewTable . getSelectionModel ( ) . getSelectedIndex ( ) ) , btnRefresh ) ; } } \n', 0.409048137793748)

('public void widgetSelected ( SelectionEvent e ) { if ( control instanceof Button && ( control . getStyle ( ) & ( SWT . RADIO | SWT . CHECK | SWT . TOGGLE ) ) != 0 ) { if ( ( ( Button ) control ) . getSelection ( ) ) { state = true ; } else { state = false ; } } else if ( control == null || e . item == control ) { state = ! state ; } set . setEnabled ( state ) ; } \n', 0.40252358373903474)

('private void setupVariableCheckboxToolTip ( ) { if ( variableCheckbox != null ) { if ( variableCheckbox . getSelection ( ) ) variableCheckbox . setToolTipText ( IDEWorkbenchMessages . ImportTypeDialog_importElementsAsTooltipSet ) ; else variableCheckbox . setToolTipText ( IDEWorkbenchMessages . ImportTypeDialog_importElementsAsTooltip ) ; } } \n', 0.4018512555822971)

('private void advancedCheckBoxActionPerformed ( ActionEvent evt ) { boolean showAdvanced = advancedCheckBox . isSelected ( ) ; announceProgramUpdatesCheckBox . setVisible ( showAdvanced ) ; unstableUpdatesCheckBox . setVisible ( showAdvanced ) ; windowCenteredCheckBox . setVisible ( showAdvanced ) ; startMinimizedCheckBox . setVisible ( showAdvanced ) ; tipsCheckBox . setVisible ( showAdvanced ) ; debugCheckBox . setVisible ( showAdvanced ) ; advancedControlsCheckBox . setVisible ( showAdvanced ) ; toolbarVisibleCheckBox . setVisible ( showAdvanced ) ; tabbedPane . setEnabledAt ( tabbedPane . indexOfComponent ( privacyPanel ) , showAdvanced ) ; tabbedPane . setEnabledAt ( tabbedPane . indexOfComponent ( connectionPanel ) , showAdvanced ) ; invalidate ( ) ; validate ( ) ; } \n', 0.4004117446116905)

('public Builder longClickViews ( @ NonNull View ... longClickViews ) { for ( int i = 0 ; i < longClickViews . length ; i ++ ) { this . longClickViews . add ( longClickViews [ i ] ) ; } return this ; } \n', 0.4000489045485901)

('@ Override public void widgetSelected ( SelectionEvent e ) { for ( int i = 0 ; i < controls . length ; i ++ ) { Control control = controls [ i ] ; control . setEnabled ( ! control . getEnabled ( ) ) ; } validate ( ) ; } \n', 0.39921649342748344)

('public void widgetSelected ( SelectionEvent e ) { for ( int i = 0 ; i < controls . length ; i ++ ) { Control control = controls [ i ] ; control . setEnabled ( ! control . getEnabled ( ) ) ; } validate ( ) ; } \n', 0.39921649342748344)

('protected void booleanOptionChanged ( BooleanFontOption option ) { AbstractButton checkbox = ( AbstractButton ) fontOptionCheckBoxes . get ( option ) ; checkbox . setSelected ( option . getValue ( ) ) ; fireStateChanged ( ) ; } \n', 0.3977609175671304)

('private void dialogChanged ( ) { if ( servletButton != null ) { if ( deploymentModelType . value == STANDALONE_DEPLOY . ordinal ( ) ) { servletButton . setSelection ( false ) ; servletButton . setEnabled ( false ) ; servletButton . setText ( "Servlet-transport-disabled,-only-supported-with-war-deploy-model" ) ; } else { servletButton . setSelection ( true ) ; servletButton . setEnabled ( true ) ; servletButton . setText ( "Servlet" ) ; } } updateStatus ( null ) ; } \n', 0.3977046698642534)

('private void noneCheckboxSelected ( boolean state ) { editButton . setEnabled ( ! state ) ; showPasswordCheckbox . setEnabled ( ! state ) ; } \n', 0.3965265495204018)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 7 #################################
('public static void sortIntegerArray ( Integer [ ] a , int fromIndex , int toIndex ) { int middle ; if ( a == null ) return ; if ( fromIndex + 1 < toIndex ) { middle = ( fromIndex + toIndex ) / 2 ; sortIntegerArray ( a , fromIndex , middle ) ; sortIntegerArray ( a , middle , toIndex ) ; mergeIntegerArray ( a , fromIndex , toIndex ) ; } } \n', 0.4567916208067464)

('public static void sortFloatArray ( Float [ ] a , int fromIndex , int toIndex ) { int middle ; if ( a == null ) return ; if ( fromIndex + 1 < toIndex ) { middle = ( fromIndex + toIndex ) / 2 ; sortFloatArray ( a , fromIndex , middle ) ; sortFloatArray ( a , middle , toIndex ) ; mergeFloatArray ( a , fromIndex , toIndex ) ; } } \n', 0.456238416259239)

('@ CheckReturnValue public static int [ ] countingSort ( int [ ] nums ) { int n = nums . length ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int num : nums ) { min = Math . min ( min , num ) ; max = Math . max ( max , num ) ; } int k = max - min + 1 ; int [ ] countArr = new int [ k ] ; for ( int num : nums ) { ++ countArr [ num - min ] ; } int [ ] sortedNums = new int [ n ] ; for ( int i = 0 , j = 0 ; i < k ; ++ i ) { while ( countArr [ i ] -- > 0 ) { sortedNums [ j ++ ] = i + min ; } } return sortedNums ; } \n', 0.4552922992142242)

('public int [ ] countingSort ( int [ ] A ) { int max = Integer . MIN_VALUE , min = Integer . MAX_VALUE ; for ( int num : A ) { max = Math . max ( max , num ) ; min = Math . min ( min , num ) ; } int K = max - min + 1 , N = A . length ; int [ ] C = new int [ K ] ; for ( int num : A ) C [ num - min ] ++ ; for ( int i = 1 ; i < K ; i ++ ) C [ i ] += C [ i - 1 ] ; int [ ] res = new int [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int countIndex = A [ i ] - min ; res [ -- C [ countIndex ] ] = A [ i ] ; } return res ; } \n', 0.45250637464429994)

('public static < T extends Comparable < ? super T > > int [ ] sort ( T [ ] arr ) { int [ ] order = new int [ arr . length ] ; for ( int i = 0 ; i < order . length ; i ++ ) { order [ i ] = i ; } sort ( arr , order ) ; return order ; }\n', 0.4509236000661915)

('public static final int sort ( long [ ] values ) { final int len = values . length ; java . util . Arrays . sort ( values , 0 , len ) ; int nneg = java . util . Arrays . binarySearch ( values , 0 ) ; if ( nneg < 0 ) { nneg = - ( nneg + 1 ) ; } final int npos = len - nneg ; final int rots = nneg - npos ; final int rfrom = rots >= 0 ? 0 : nneg ; final int rto = rots >= 0 ? nneg : len ; Arrays . rotate ( values , rots , rfrom , rto ) ; final int swaps = rots >= 0 ? npos : nneg ; for ( int i = 0 ; i < swaps ; i ++ ) { Arrays . swap ( values , i , len - swaps + i ) ; } return npos ; } \n', 0.44834793604865275)

('public Builder sortOrder ( Comparator < Release > value ) { this . sortOrder = Objects . requireNonNull ( value ) ; return this ; } \n', 0.44750857622652496)

('public static DoubleArray sort ( int dim , DoubleArray x , DoubleComparator comparator ) { DoubleArray c = x . copy ( ) ; int vectors = c . vectors ( dim ) ; for ( int i = 0 ; i < vectors ; i ++ ) { c . getVector ( dim , i ) . sort ( comparator ) ; } return c ; } \n', 0.4473307866986901)

('@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) public static Vector sortIntegerVector ( Vector toSort ) { if ( toSort == null ) { return new Vector ( ) ; } int size = toSort . size ( ) ; if ( size == 0 ) { return toSort ; } Vector sorted = new Vector ( ) ; Integer [ ] elements = new Integer [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { elements [ i ] = ( Integer ) toSort . elementAt ( i ) ; } integerQuicksort ( elements , 0 , size - 1 ) ; for ( int i = 0 ; i < size ; i ++ ) { sorted . add ( elements [ i ] ) ; } return sorted ; } \n', 0.4409520400535205)

('private static void sortNegZeroAndNaN ( double [ ] a , int left , int right ) { final long NEGATIVE_ZERO = Double . doubleToLongBits ( - 0.0d ) ; int numNegativeZeros = 0 ; int n = right ; for ( int k = left ; k <= n ; k ++ ) { double ak = a [ k ] ; if ( ak == 0.0d && NEGATIVE_ZERO == Double . doubleToLongBits ( ak ) ) { a [ k ] = 0.0d ; numNegativeZeros ++ ; } else if ( ak != ak ) { a [ k -- ] = a [ n ] ; a [ n -- ] = Double . NaN ; } } doSort ( a , left , n ) ; if ( numNegativeZeros == 0 ) { return ; } int zeroIndex = findAnyZero ( a , left , n ) ; for ( int i = zeroIndex - 1 ; i >= left && a [ i ] == 0.0d ; i -- ) { zeroIndex = i ; } for ( int i = zeroIndex , m = zeroIndex + numNegativeZeros ; i < m ; i ++ ) { a [ i ] = - 0.0d ; } } \n', 0.43928322517806684)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 8 #################################
('public static String formatDate ( Date date , String format ) { if ( date == null ) return "" ; else { DateFormatter dateFormatter = new DateFormatter ( ) ; dateFormatter . setFormat ( format ) ; dateFormatter . setDate ( date ) ; return dateFormatter . getFormattedDate ( ) ; } } \n', 0.4164182879557735)

('public static String formatDate ( Date date , String pattern ) { if ( date == null ) throw new IllegalArgumentException ( "date-is-null" ) ; if ( pattern == null ) throw new IllegalArgumentException ( "pattern-is-null" ) ; SimpleDateFormat formatter = new SimpleDateFormat ( pattern , Locale . US ) ; formatter . setTimeZone ( GMT ) ; return formatter . format ( date ) ; } \n', 0.41535550937543564)

('public String formatDate ( Date date ) { String dateStr = "" ; switch ( this . dateFormat . getDateFormat ( ) ) { case DateFormat . MMDDYYYY : dateStr = formatDate_MMDDYYYY ( date ) ; break ; case DateFormat . DDMMYYYY : dateStr = formatDate_DDMMYYYY ( date ) ; break ; case DateFormat . DDMONYYYY : dateStr = formatDate_DDMONYYYY ( date ) ; break ; } return dateStr ; } \n', 0.4152858754339449)

('private String formatDate ( Locale locale ) { String datePattern = "" ; DateFormat dateFormat = SimpleDateFormat . getDateInstance ( DateFormat . SHORT , locale ) ; datePattern = ( ( SimpleDateFormat ) dateFormat ) . toPattern ( ) ; if ( ! datePattern . contains ( "yy" ) ) { datePattern = datePattern . replaceAll ( "y" , "yy" ) ; } if ( ! datePattern . contains ( "yyyy" ) ) { datePattern = datePattern . replaceAll ( "yy" , "yyyy" ) ; } if ( ! datePattern . contains ( "dd" ) ) { datePattern = datePattern . replaceAll ( "d" , "dd" ) ; } if ( ! datePattern . contains ( "MM" ) ) { datePattern = datePattern . replaceAll ( "M" , "MM" ) ; } return datePattern ; } \n', 0.4151325751308394)

('public String formatDate ( Date date ) { if ( date == null ) { return "" ; } DateFormat format = SimpleDateFormat . getDateInstance ( SimpleDateFormat . SHORT , locale ) ; format . setTimeZone ( timeZone ) ; return format . format ( date ) ; } \n', 0.4142441650462083)

('private String formatDate ( long date ) { DateFormat dateFormat = new SimpleDateFormat ( DATE_FORMATS [ 0 ] , Locale . US ) ; dateFormat . setTimeZone ( GMT ) ; return dateFormat . format ( new Date ( date ) ) ; } \n', 0.4141397734516934)

('public static String formatDate ( final Date date , final String pattern ) { if ( date == null ) { throw new IllegalArgumentException ( "date-is-null" ) ; } if ( pattern == null ) { throw new IllegalArgumentException ( "pattern-is-null" ) ; } final SimpleDateFormat formatter = new SimpleDateFormat ( pattern , Locale . US ) ; formatter . setTimeZone ( GMT ) ; return formatter . format ( date ) ; } \n', 0.41351179011415085)

('public synchronized static String formatDateInUTC ( String pattern , java . util . Date date ) { DateFormat format = FastDateParser . getInstance ( pattern ) ; format . setTimeZone ( TimeZone . getTimeZone ( "UTC" ) ) ; return format . format ( date ) ; } \n', 0.4133600123888584)

('public static String formatDate ( Calendar calendar , String dateFormat ) { StringBuffer buffer = new StringBuffer ( dateFormat . length ( ) ) ; formatDate ( calendar , buffer , dateFormat ) ; return buffer . toString ( ) ; } \n', 0.412710079751942)

('public static String formatDateUTC ( Long dataLong ) { SimpleDateFormat sf = new SimpleDateFormat ( DATE_FORMAT ) ; sf . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; return sf . format ( new Date ( dataLong ) ) ; } \n', 0.41256968190500815)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 9 #################################
('public static Date currentDate ( ) { return instance . currentClockDate ( ) ; } \n', 0.38097598357095946)

('public String getCurrentDate ( ) { return this . getCurrentDate ( SHORT_FORMAT ) ; } \n', 0.37570775791795535)

('public static Date getBiggerDate ( Date date1 , Date date2 ) { return date1 . after ( date2 ) ? date1 : date2 ; } \n', 0.37246453163375226)

('public long getTime ( ) { return timestamp . getTime ( ) ; } \n', 0.37175242109663953)

('private Date getNewestDate ( final Date date1 , final Date date2 ) { if ( date1 == null && date2 == null ) { return null ; } else if ( date1 == null ) { return date2 ; } else if ( date2 == null ) { return date1 ; } if ( date1 . before ( date2 ) ) { return date2 ; } else if ( date1 . after ( date2 ) ) { return date1 ; } else { return date1 ; } } \n', 0.37134194071726945)

('public static String getCurrentDate ( int nDelta ) throws RemoteException { java . util . Date currentDate = new java . util . Date ( ) ; currentDate . setDate ( currentDate . getDate ( ) + nDelta ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( "MM/dd/yy" ) ; String dateString = dateFormat . format ( currentDate ) ; return dateString ; } \n', 0.3712414400539603)

('public Date getCompletionTime ( String timeNeeded ) { int seconds = timeToSeconds ( timeNeeded ) ; Calendar time = new GregorianCalendar ( ) ; time . add ( Calendar . SECOND , seconds ) ; return time . getTime ( ) ; } \n', 0.3703556204794894)

('@ Override public Date getCurrentDate ( ) { return calendar . getDate ( ) ; } \n', 0.3703136323697893)

('public static long getCurrentTime ( ) { java . util . Date date = new java . util . Date ( ) ; return ( ( new Timestamp ( date . getTime ( ) ) ) . getTime ( ) / 1000 ) ; } \n', 0.37026236093781534)

('public static String getNiceTime ( Timestamp time ) { if ( time == null ) { return "" ; } java . util . Date now = new java . util . Date ( ) ; return getNiceTime ( now . getTime ( ) , time . getTime ( ) ) ; } \n', 0.3701976500160501)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 10 #################################
('public Card getRandomCard ( List < Card > possibleCards ) { return possibleCards . get ( rand . nextInt ( cards . size ( ) ) ) . copy ( ) ; } \n', 0.4589322016213847)

('public Card getRandomCard ( ) { return cards . get ( rand . nextInt ( cards . size ( ) ) ) . copy ( ) ; } \n', 0.4549695816187266)

('public static TextureRegion loadRandomProjectile ( ) { Random rnd = new Random ( ) ; int index = rnd . nextInt ( projectiles . size ( ) ) ; TextureRegion projectile = projectiles . get ( index ) ; return projectile ; } \n', 0.4515574256691365)

('public void nextCardCzar ( ) throws Card_Czar_Exception { if ( first ) { Random a = new Random ( ) ; int start = a . nextInt ( players . size ( ) ) ; if ( ! players . get ( start ) . getRandoCard ( ) ) { players . get ( start ) . isCard_Czar ( ) ; } else { start ++ ; start = players . size ( ) - ( start % players . size ( ) ) ; players . get ( start ) . isCard_Czar ( ) ; } CzarCount = start ; first = false ; } else { if ( ! players . get ( CzarCount ) . getRandoCard ( ) ) { players . get ( CzarCount ) . isCard_Czar ( ) ; } else { CzarCount ++ ; CzarCount = players . size ( ) - CzarCount % players . size ( ) ; players . get ( CzarCount ) . isCard_Czar ( ) ; } CzarCount ++ ; CzarCount = players . size ( ) - ( CzarCount % players . size ( ) ) ; } } \n', 0.45087789137268036)

('@ Override public CardImpl getRandomCard ( int box ) { CardImpl theCard = null ; ArrayList < CardImpl > cardsForBox = new ArrayList < CardImpl > ( ) ; cardsForBox = getCards ( box ) ; if ( cardsForBox . size ( ) > 0 ) { Random random = new Random ( ) ; int min = 1 ; int max = cardsForBox . size ( ) ; int rndNumb = random . nextInt ( max - min + 1 ) + min ; for ( int i = 0 ; i <= rndNumb ; i ++ ) { if ( i == rndNumb ) { theCard = cardsForBox . get ( i - 1 ) ; } } return theCard ; } return null ; } \n', 0.4501104323051893)

('public static long [ ] getRandomSongListForCursor ( Cursor cursor ) { if ( cursor == null ) { return sEmptyList ; } int len = cursor . getCount ( ) ; long [ ] list = new long [ len ] ; cursor . moveToFirst ( ) ; int colidx = - 1 ; try { colidx = cursor . getColumnIndexOrThrow ( Audio . Playlists . Members . AUDIO_ID ) ; } catch ( IllegalArgumentException ex ) { colidx = cursor . getColumnIndexOrThrow ( BaseColumns . _ID ) ; } for ( int i = 0 ; i < len ; i ++ ) { list [ i ] = cursor . getLong ( colidx ) ; cursor . moveToNext ( ) ; } int index ; Random random = new Random ( ) ; for ( int i = list . length - 1 ; i > 0 ; i -- ) { index = random . nextInt ( i + 1 ) ; if ( index != i ) { list [ index ] ^= list [ i ] ; list [ i ] ^= list [ index ] ; list [ index ] ^= list [ i ] ; } } return list ; } \n', 0.44774155208418787)

('public int nextCard ( ) { if ( index == cards . length ) { for ( int i = cards . length - 1 ; i >= 0 ; i -- ) { int j = random . nextInt ( i + 1 ) ; int temp = cards [ i ] ; cards [ i ] = cards [ j ] ; cards [ j ] = temp ; } index = 0 ; } int result = cards [ index ] ; index ++ ; return result ; } \n', 0.4443900183531317)

('public synchronized Card pickRandomCard ( ) { return gCards [ position + r . nextInt ( NUM_CARDS - position ) ] ; } \n', 0.4424255661082913)

('protected SamplePermutation getOneRandomSamplePermutation ( ) { ArrayList < Integer > controlPositions = new ArrayList < Integer > ( ) ; int numControlsAssigned = 0 ; while ( numControlsAssigned < numControls ) { Integer randPos = Integer . valueOf ( random . nextInt ( numSamples ) ) ; if ( controlPositions . contains ( randPos ) ) { continue ; } controlPositions . add ( randPos ) ; numControlsAssigned ++ ; } return new SamplePermutation ( controlPositions ) ; } \n', 0.44238084833511165)

('private int selectRandomArm ( ) { return rang . nextInt ( armsCount . length ) ; } \n', 0.44048163815725216)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 11 #################################
('@ Override void deserialize ( final Map < String , Object > source ) { super . deserialize ( source ) ; if ( source . containsKey ( JsonSchema . KEY_DATE_PATTERN ) ) { this . datePattern = ( String ) source . get ( JsonSchema . KEY_DATE_PATTERN ) ; } } \n', 0.4187842304303746)

('@ Override public Integer deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { Map map = jp . readValueAs ( Map . class ) ; return map . containsKey ( "count" ) ? Integer . valueOf ( String . valueOf ( map . get ( "count" ) ) ) : 0 ; } \n', 0.41830595468776277)

('@ Override public Entry deserialize ( @ Nullable byte [ ] bytes ) { if ( bytes == null ) { return null ; } return GSON . get ( ) . fromJson ( new String ( bytes ) , Entry . class ) ; } \n', 0.4106041816504033)

('public static Object decodeObject ( String str ) throws KVException { Object obj = null ; try { byte [ ] decoded = DatatypeConverter . parseBase64Binary ( str ) ; ObjectInputStream is = new ObjectInputStream ( new ByteArrayInputStream ( decoded ) ) ; obj = is . readObject ( ) ; is . close ( ) ; } catch ( IOException e ) { throw new KVException ( new KVMessage ( "resp" , "Unknown-Error:-Unable-to-decode-object" ) ) ; } catch ( ClassNotFoundException e ) { throw new KVException ( new KVMessage ( "resp" , "Unknown-Error:-Decoding-object-class-not-found" ) ) ; } return obj ; } \n', 0.40677286290109904)

('public static CryptoAlgorithm deserialize ( final short value ) { final CryptoAlgorithm result = ID_MAPPING . get ( value ) ; return result ; } \n', 0.4056744712203677)

('private void deserialize ( ObjectInputStream in , String version ) throws IOException , ClassNotFoundException { if ( version . equals ( CURRENT_VERSION ) ) { int size = ( ( Integer ) in . readObject ( ) ) . intValue ( ) ; fs = new HashMap < String , ByteArrayOutputStream > ( ( size * 4 ) / 3 ) ; for ( int i = 0 ; i < size ; i ++ ) { String key = ( String ) in . readObject ( ) ; byte [ ] buf = ( byte [ ] ) in . readObject ( ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( buf . length ) ; out . write ( buf ) ; fs . put ( key , out ) ; } } else { throw new IOException ( "version:-" + version + "-not-supported" ) ; } } \n', 0.40477758242944395)

("public void serialize ( OutputStream serializedGraph , Graph tc , String formatIdentifier ) throws UnsupportedFormatException { String deParameterizedIdentifier ; int semicolonPos = formatIdentifier . indexOf ( ';' ) ; if ( semicolonPos > - 1 ) { deParameterizedIdentifier = formatIdentifier . substring ( 0 , semicolonPos ) ; } else { deParameterizedIdentifier = formatIdentifier ; } SerializingProvider provider = providerMap . get ( deParameterizedIdentifier ) ; if ( provider == null ) { throw new UnsupportedSerializationFormatException ( formatIdentifier ) ; } provider . serialize ( serializedGraph , tc , formatIdentifier ) ; } \n", 0.4041031595450415)

('@ SuppressWarnings ( "unchecked" ) @ Override public TS deserialize ( final byte [ ] data ) throws SerializationException { ArrayList < TS > info = null ; if ( data != null ) { final String jsonData = new String ( data ) ; try { info = objectMapper . readValue ( jsonData , ArrayList . class ) ; } catch ( final Exception e ) { throw new SerializationException ( "Error-occured-while-deserializing-data-" + jsonData , e ) ; } } return ( info != null && info . size ( ) > 0 ) ? info . get ( 0 ) : null ; } \n', 0.40244103573914625)

('@ Override public void deserialize ( final InputStream inputStream ) throws IOException { try { final KeyFactory keyFactory = KeyFactory . getInstance ( "RSA" ) ; final BigInteger modulus = UtilIO . readBigInteger ( inputStream ) ; final BigInteger exponent = UtilIO . readBigInteger ( inputStream ) ; final RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec ( modulus , exponent ) ; this . publicKey = keyFactory . generatePublic ( publicKeySpec ) ; } catch ( final Exception exception ) { throw new IOException ( "Deserialize-problem" , exception ) ; } } \n', 0.40180519154171335)

('public String serialize ( ) { String sparam = key . toString ( ) ; if ( value instanceof String ) { sparam += value ; } else { if ( value instanceof Integer ) { sparam += Integer . toString ( ( ( Integer ) value ) . intValue ( ) ) ; } else { if ( value instanceof ArrayList ) { boolean isfirst = true ; for ( Object param : ( ArrayList < Object > ) value ) { if ( isfirst ) { isfirst = false ; } else { sparam += Tokens . TK_VALUE ; } if ( param instanceof String ) { sparam += param ; } else { if ( param instanceof Integer ) { sparam += Integer . toString ( ( ( Integer ) param ) . intValue ( ) ) ; } } } } } } return sparam ; } \n', 0.40135760563043604)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 12 #################################
('public static void copyToClipboard ( final String string ) { Preconditions . checkNotNull ( string , "Error:-String-argument-can-not-be-null" ) ; final Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipboard . setContents ( new StringSelection ( string ) , new ClipboardOwner ( ) { @ Override public void lostOwnership ( final Clipboard clipboard , final Transferable contents ) { } } ) ; } \n', 0.4804960994490237)

('public static void copyToClipboard ( final String text ) { StringSelection selection = new StringSelection ( text == null ? "" : text ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; if ( clipboard != null ) { clipboard . setContents ( selection , selection ) ; } else { BeamLogManager . getSystemLogger ( ) . severe ( "failed-to-obtain-clipboard-instance" ) ; } } \n', 0.47947588439425187)

('public static void copyToClipboard ( final String text ) { final StringSelection selection = new StringSelection ( text == null ? "" : text ) ; final Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; if ( clipboard != null ) { clipboard . setContents ( selection , selection ) ; } else { BeamLogManager . getSystemLogger ( ) . severe ( "failed-to-obtain-clipboard-instance" ) ; } } \n', 0.47947588439425187)

('public static void copyToClipboard ( String s ) { Display display = Display . findDisplay ( Thread . currentThread ( ) ) ; Clipboard clipboard = new Clipboard ( display ) ; TextTransfer textTransfer = TextTransfer . getInstance ( ) ; clipboard . setContents ( new Object [ ] { s } , new Transfer [ ] { textTransfer } ) ; clipboard . dispose ( ) ; } \n', 0.4792785853476912)

('public static void copyToClipboard ( String str ) { Toolkit kit = Toolkit . getDefaultToolkit ( ) ; Clipboard clipboard = kit . getSystemClipboard ( ) ; StringSelection ss = new StringSelection ( str ) ; clipboard . setContents ( ss , ss ) ; } \n', 0.4761093645389748)

('static void copyToClipboard ( String textToCopy ) { StringSelection stringSelection = new StringSelection ( textToCopy ) ; Clipboard clpbrd = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clpbrd . setContents ( stringSelection , null ) ; } \n', 0.4730787630694193)

('public void copyToClipboard ( String sText ) { Clipboard objClipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; StringSelection objStringSelection = new StringSelection ( sText ) ; objClipboard . setContents ( objStringSelection , this ) ; } \n', 0.4723259640021406)

('public static void copyToClipboard ( String string ) { StringSelection stringSelection = new StringSelection ( string ) ; Clipboard clpbrd = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clpbrd . setContents ( stringSelection , null ) ; } \n', 0.4720089838555941)

('public static void copyToClipboard ( String s ) { StringSelection stringSelection = new StringSelection ( s ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipboard . setContents ( stringSelection , null ) ; } \n', 0.4712765746497808)

('protected void copyToClipboard ( ) { if ( _clipboard != null ) { _clipboard . dispose ( ) ; } String stackTrace = stackTraceToString ( _status . getException ( ) ) ; _clipboard = new Clipboard ( _list . getDisplay ( ) ) ; _clipboard . setContents ( new Object [ ] { stackTrace } , new Transfer [ ] { TextTransfer . getInstance ( ) } ) ; } \n', 0.469547078319246)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 13 #################################
('public void Randomize ( ) { for ( Neuron neuron : neurons ) { neuron . Randomize ( ) ; } } \n', 0.3959874072886176)

('private static ArrayList < ArrayList < Integer >> transposeMatrix ( ArrayList < ArrayList < Integer >> matrix ) { int numRows = matrix . size ( ) ; int numCols = matrix . get ( 0 ) . size ( ) ; ArrayList < ArrayList < Integer >> newMat = new ArrayList < ArrayList < Integer >> ( ) ; for ( int i = 0 ; i < numCols ; i ++ ) newMat . add ( new ArrayList < Integer > ( ) ) ; for ( int i = 0 ; i < numRows ; i ++ ) { for ( int j = 0 ; j < numCols ; j ++ ) { newMat . get ( j ) . add ( matrix . get ( i ) . get ( j ) ) ; } } return newMat ; } \n', 0.3932453567335805)

('public void normalizeMatrix ( RealMatrix matrix ) { int m = matrix . getRowDimension ( ) ; int n = matrix . getColumnDimension ( ) ; for ( int i = 0 ; i < m ; i ++ ) { RealMatrix subMatrix = matrix . getSubMatrix ( i , i , 0 , n - 1 ) ; double sum = norm1 ( subMatrix ) / n ; for ( int j = 0 ; j < n ; j ++ ) { subMatrix . addToEntry ( 0 , j , - 1.0 * sum ) ; } double std = norm1 ( arrayTimes ( subMatrix , subMatrix ) ) / n ; timesEquals ( subMatrix , 1.0 / std ) ; for ( int j = 0 ; j < n ; j ++ ) { matrix . setEntry ( i , j , subMatrix . getEntry ( 0 , j ) ) ; } } } \n', 0.3910880093429273)

('public void randomizeBiases ( double lower , double upper ) { for ( Neuron neuron : neuronList ) { neuron . randomizeBias ( lower , upper ) ; } } \n', 0.3891627800683074)

('@ Override public String toMatrixMarket ( NumberFormat formatter ) { StringBuilder out = new StringBuilder ( ) ; out . append ( "%%MatrixMarket-vector-array-real-" ) ; out . append ( length ) . append ( \'|n\' ) ; for ( int i = 0 ; i < length ; i ++ ) { out . append ( formatter . format ( get ( i ) ) ) . append ( \'|n\' ) ; } return out . toString ( ) ; } \n', 0.3868258040168201)

('public static List < List < Double >> transposeMatrix ( List < List < Double >> in ) { double inCols = in . size ( ) ; double inRows = ( inCols > 0 ) ? in . get ( 0 ) . size ( ) : 0 ; List < List < Double >> out = new ArrayList < List < Double >> ( ) ; for ( int i = 0 ; i < inRows ; ++ i ) { ArrayList < Double > newCol = new ArrayList < Double > ( ) ; for ( int j = 0 ; j < inCols ; ++ j ) { newCol . add ( in . get ( j ) . get ( i ) ) ; } out . add ( newCol ) ; } return out ; } \n', 0.38441181234651195)

('public static String escVector ( double [ ] vec , String [ ] nomes ) { HTML += "<table>-" ; for ( int i = 0 ; i < vec . length ; i ++ ) { HTML += "<tr>-<td>" + nomes [ i ] + ":-" + Math . round ( vec [ i ] * 100 ) / 100.0 + "</td>-</tr>-" ; } HTML += "</table>-" ; return HTML ; } \n', 0.3828316547174765)

('public Matrix ( String in ) throws Exception { ArrayList < Double > aux = new ArrayList < Double > ( ) ; Scanner scan = new Scanner ( in ) ; while ( scan . hasNext ( ) ) { double e = scan . nextDouble ( ) ; aux . add ( e ) ; } scan . close ( ) ; Double n = Math . sqrt ( aux . size ( ) ) ; if ( n != n . intValue ( ) ) { N = 0 ; m = null ; throw new Exception ( "The-A-matrix-must-be-a-square-matrix" ) ; } else { N = n . intValue ( ) ; m = new double [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { m [ i ] [ j ] = aux . get ( i * N + j ) ; } } } aux . clear ( ) ; } \n', 0.3822577773987434)

('public DoubleVector leftMultiplyVector ( DoubleVector vector ) throws Exception { if ( m_numColumns != vector . size ( ) ) { throw new Exception ( "the-matrix-and-the-vector-are-noe-compatible" ) ; } double [ ] result = new double [ m_numRows ] ; for ( int i = 0 ; i < this . m_numRows ; i ++ ) { if ( ! m_values . containsKey ( i ) ) { result [ i ] = 0 ; } else { double sums = 0 ; LinkedHashMap < Integer , Double > currentRow = m_values . get ( i ) ; Set < Integer > keys = currentRow . keySet ( ) ; Iterator < Integer > iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { int key = iterator . next ( ) . intValue ( ) ; sums += currentRow . get ( key ) * vector . at ( key ) ; } result [ i ] = sums ; } } return new DoubleVector ( result ) ; } \n', 0.38155155725419376)

('public static String matrixToNumbers ( int [ ] [ ] matrix ) { int cols = matrix [ 0 ] . length ; int rows = matrix . length ; StringBuilder sb = new StringBuilder ( 3 * cols * rows ) ; sb . append ( "|begin{tikzpicture}-" ) ; sb . append ( "|matrix-[matrix-of-math-nodes,left-delimiter=(,right-delimiter=),-ampersand-replacement=|&]-(m)-" ) ; sb . append ( "{-" ) ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { sb . append ( matrix [ i ] [ j ] + "-|&-" ) ; } sb . append ( "||-" ) ; } sb . append ( "};-" ) ; return sb . toString ( ) ; } \n', 0.38145342683299127)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 14 #################################
('private LinkedList < String > sortStringSet ( Set < String > input ) { LinkedList < String > sortedItems = new LinkedList < String > ( ) ; for ( String e : input ) sortedItems . add ( e ) ; Collections . sort ( sortedItems ) ; return sortedItems ; } \n', 0.4610935977618856)

('public static boolean isListSort ( String sort ) { return sort . endsWith ( "*" ) ; } \n', 0.45427069074303555)

('public static void sortList ( List list ) { sortList ( list , new Comparator < ListItem > ( ) { public int compare ( ListItem listItem1 , ListItem listItem2 ) { return listItem1 . text . compareTo ( listItem2 . text ) ; } } ) ; } \n', 0.4533994217583312)

('private Boolean compareStringLists ( List < String > list1 , List < String > list2 ) { if ( list1 == null && list2 == null ) { return true ; } if ( list1 == null || list2 == null || list1 . size ( ) != list2 . size ( ) ) { return false ; } for ( String s1 : list1 ) { if ( ! list2 . contains ( s1 ) ) { return false ; } } return true ; } \n', 0.4500470316993037)

('public static String sortOrderToString ( JinxConstants . SortOrder sortOrder ) { if ( sortOrder == null ) { return null ; } return sortOrder . toString ( ) . replaceAll ( "_" , "-" ) ; } \n', 0.4480149920981601)

('public static void sortStrings ( String [ ] strings ) { sortStrings ( strings , 0 , strings . length - 1 ) ; } \n', 0.44744101926833524)

('public static ArrayList < String > SortStringList ( ArrayList < String > list ) { ArrayList < NumericString > numericStringList = new ArrayList < NumericString > ( ) ; for ( String item : list ) numericStringList . add ( new NumericString ( item ) ) ; Collections . sort ( numericStringList ) ; ArrayList < String > sortedList = new ArrayList < String > ( ) ; for ( NumericString item : numericStringList ) sortedList . add ( item . toString ( ) ) ; return sortedList ; } \n', 0.44667101017015226)

('private static String sort ( String word ) { if ( word . length ( ) == 0 ) return "" ; if ( word . length ( ) == 1 ) return word ; List < String > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { list . add ( word . substring ( i , i + 1 ) ) ; } Collections . sort ( list ) ; word = "" ; for ( String s : list ) { word += s ; } return word ; } \n', 0.4438603303117831)

('public static boolean verifyStringListSortByAlphabetically ( List < String > oriList ) { List < String > afterSorting = new ArrayList < String > ( ) ; boolean result = true ; afterSorting . addAll ( oriList ) ; Collections . sort ( afterSorting ) ; if ( ! oriList . equals ( afterSorting ) ) { result = false ; AutomationLogger . getInstance ( ) . error ( "The-string-list-does-NOT-sort-by-alphabetically-ascending!" ) ; } else { AutomationLogger . getInstance ( ) . info ( "The-string-list-sorts-by-alphabetically-ascending-correctly!" ) ; } return result ; } \n', 0.4416763500675002)

('private void sortStringList ( List < String > strings ) { Collections . sort ( strings , String . CASE_INSENSITIVE_ORDER ) ; } \n', 0.44136169867191)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 15 #################################
("public static String convertDecimalStringToHexString ( String in ) { int integer = Integer . parseInt ( in ) ; String hexString = Integer . toHexString ( integer ) ; if ( hexString . length ( ) == 1 ) { hexString = '0' + hexString ; } return hexString ; } \n", 0.4253949201254642)

('public static byte [ ] decodeHexString ( String hexStr ) throws NumberFormatException { if ( hexStr == null ) { return null ; } if ( ( hexStr . length ( ) % 2 ) != 0 ) { throw new NumberFormatException ( "Bad-hex-string.-Length-of-string-must-be-even." ) ; } byte [ ] result = new byte [ hexStr . length ( ) / 2 ] ; for ( int i = 0 ; i < hexStr . length ( ) ; i += 2 ) { String hexDigit = hexStr . substring ( i , i + 2 ) ; int byteValue = Integer . parseInt ( hexDigit , 16 ) ; result [ i / 2 ] = ( byte ) ( byteValue & 0xFF ) ; } return result ; } \n', 0.4209883653839003)

('public static String decimalToHex ( int value , int numOfDigits ) { value = value & ( powersOf16 [ numOfDigits ] - 1 ) ; String result = Integer . toHexString ( value ) ; if ( result . length ( ) < numOfDigits ) result = ZEROS . substring ( 0 , numOfDigits - result . length ( ) ) + result ; return result ; } \n', 0.42010072186987324)

('public static String longHexStringToBinary ( String hex ) { StringBuffer output = new StringBuffer ( ) ; for ( int i = 0 ; i < hex . length ( ) ; i ++ ) { String h = hex . substring ( i , i + 1 ) ; output . append ( hexToBinary ( h , 4 ) ) ; } return output . toString ( ) ; } \n', 0.41971102892724366)

('public static int getDecimalStringAsInt ( ByteBuffer buffer , int len ) { byte [ ] bytes = getBytes ( buffer , len ) ; String str = new String ( bytes , Charsets . US_ASCII ) ; return Integer . parseInt ( str . trim ( ) ) ; } \n', 0.41926742278758256)

('public static int getOctalStringAsInt ( ByteBuffer buffer , int len ) { byte [ ] bytes = getBytes ( buffer , len ) ; String str = new String ( bytes , Charsets . US_ASCII ) ; return Integer . parseInt ( str . trim ( ) , 8 ) ; } \n', 0.4138753027074946)

('protected static long decodeNtpHexString ( String s ) throws NumberFormatException { if ( s == null ) { throw new NumberFormatException ( "null" ) ; } int ind = s . indexOf ( \'.\' ) ; if ( ind == - 1 ) { if ( s . length ( ) == 0 ) return 0 ; return Long . parseLong ( s , 16 ) << 32 ; } return Long . parseLong ( s . substring ( 0 , ind ) , 16 ) << 32 | Long . parseLong ( s . substring ( ind + 1 ) , 16 ) ; } \n', 0.4112265093620936)

('protected static long decodeNtpHexString ( String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( "null" ) ; } int ind = hexString . indexOf ( \'.\' ) ; if ( ind == - 1 ) { if ( hexString . length ( ) == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } \n', 0.4112265093620936)

('protected long decodeNtpHexString ( String s ) throws NumberFormatException { if ( s == null ) { throw new NumberFormatException ( "null" ) ; } int ind = s . indexOf ( \'.\' ) ; if ( ind == - 1 ) { if ( s . length ( ) == 0 ) return 0 ; return Long . parseLong ( s , 16 ) << 32 ; } return Long . parseLong ( s . substring ( 0 , ind ) , 16 ) << 32 | Long . parseLong ( s . substring ( ind + 1 ) , 16 ) ; } \n', 0.41085437764074867)

('private byte [ ] unpackHexString ( String hexString ) { byte [ ] array = new byte [ 16 ] ; BigInteger bigInt = new BigInteger ( hexString , 16 ) ; BigInteger andValue = new BigInteger ( "ff" , 16 ) ; for ( int i = 0 , index = 15 ; i < 16 ; i ++ , index -- ) { BigInteger shift = bigInt . shiftRight ( i * 8 ) ; shift = shift . and ( andValue ) ; array [ index ] = shift . byteValue ( ) ; } return array ; } \n', 0.4096079331690788)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 16 #################################
('public static Date toDate ( String value ) throws ParseException { StringBuilder dateBuilder = new StringBuilder ( ) ; try { int length = value . length ( ) ; dateBuilder . append ( value . substring ( 2 , 6 ) ) ; dateBuilder . append ( length < 8 ? "01" : value . substring ( 6 , 8 ) ) ; dateBuilder . append ( length < 10 ? "01" : value . substring ( 8 , 10 ) ) ; dateBuilder . append ( length < 12 ? "00" : value . substring ( 10 , 12 ) ) ; dateBuilder . append ( length < 14 ? "00" : value . substring ( 12 , 14 ) ) ; dateBuilder . append ( length < 16 ? "00" : value . substring ( 14 , 16 ) ) ; dateBuilder . append ( length < 17 || value . substring ( 16 , 17 ) . equals ( "Z" ) ? "+" : value . substring ( 16 , 17 ) ) ; dateBuilder . append ( length < 19 ? "00" : value . substring ( 17 , 19 ) ) ; dateBuilder . append ( length < 22 ? "00" : value . substring ( 20 , 22 ) ) ; } catch ( Exception exception ) { throw new ParseException ( "Failed-to-normalize-the-date-string." , exception ) ; } try { return formatter . parse ( dateBuilder . toString ( ) ) ; } catch ( Exception exception ) { throw new ParseException ( "Failed-to-parse-the-date-string." , exception ) ; } } \n', 0.4265461246922431)

('private static void convertDateString ( String str ) { try { Date date = Utils . dateFromString ( str ) ; display ( "Date-to-millis:-" + date . getTime ( ) ) ; } catch ( Exception e ) { } } \n', 0.4262708033791331)

('private Date stringToDate ( String stringValue ) throws OdaException { if ( stringValue != null && stringValue . length ( ) > 0 ) { try { return new Date ( Long . parseLong ( stringValue ) ) ; } catch ( Exception ex ) { throw new OdaException ( Messages . getFormattedString ( "invalid_date_value" , new String [ ] { stringValue } ) ) ; } } this . wasNull = true ; return null ; } \n', 0.4253699400950206)

('@ SuppressWarnings ( { "CallToDateToString" , "deprecation" } ) public static String toGMTString ( long time ) { return new Date ( time ) . toGMTString ( ) ; } \n', 0.42396987403971864)

("public static void stringToDate ( String sDate , int [ ] anDate ) { if ( anDate . length != 3 ) { throw new UnsupportedOperationException ( ) ; } int nYear , nMonth , nDate ; int nA = 0 ; int nB = sDate . indexOf ( '.' , nA ) ; nDate = Integer . parseInt ( sDate . substring ( nA , nB ) ) ; nA = nB + 1 ; nB = sDate . indexOf ( '.' , nA ) ; nMonth = Integer . parseInt ( sDate . substring ( nA , nB ) ) ; nMonth -- ; nA = nB + 1 ; nYear = Integer . parseInt ( sDate . substring ( nA , sDate . length ( ) ) ) ; anDate [ 0 ] = nYear ; anDate [ 1 ] = nMonth ; anDate [ 2 ] = nDate ; } \n", 0.4239099707211208)

('public static Date convertToDate ( String dateString ) { int year = Integer . parseInt ( dateString . substring ( 0 , 4 ) ) ; int month = Integer . parseInt ( dateString . substring ( 5 , 7 ) ) ; int day = Integer . parseInt ( dateString . substring ( 8 ) ) ; return convertToDate ( year , month , day ) ; } \n', 0.4235647263410027)

('public static String transformDateToRfc1123String ( Date date ) { if ( date == null ) { return null ; } return ( ( DateFormat ) RFC1123_DATEFORMAT . clone ( ) ) . format ( date ) ; } \n', 0.42302130848317354)

('@ SuppressWarnings ( "deprecation" ) private Date toDate ( String date ) { Date result = new Date ( ) ; result . setHours ( toInt ( date . substring ( 11 , 13 ) ) ) ; result . setMinutes ( toInt ( date . substring ( 14 , 16 ) ) ) ; result . setDate ( toInt ( date . substring ( 8 , 10 ) ) ) ; result . setYear ( toInt ( date . substring ( 24 , 28 ) ) - 1900 ) ; String month = date . substring ( 4 , 7 ) ; switch ( month ) { case ( "Jan" ) : result . setMonth ( 0 ) ; break ; case ( "Feb" ) : result . setMonth ( 1 ) ; break ; case ( "Mar" ) : result . setMonth ( 2 ) ; break ; case ( "Apr" ) : result . setMonth ( 3 ) ; break ; case ( "May" ) : result . setMonth ( 4 ) ; break ; case ( "Jun" ) : result . setMonth ( 5 ) ; break ; case ( "Jul" ) : result . setMonth ( 6 ) ; break ; case ( "Aug" ) : result . setMonth ( 7 ) ; break ; case ( "Sep" ) : result . setMonth ( 8 ) ; break ; case ( "Oct" ) : result . setMonth ( 9 ) ; break ; case ( "Nov" ) : result . setMonth ( 10 ) ; break ; case ( "Dec" ) : result . setMonth ( 11 ) ; break ; default : result . setMonth ( 0 ) ; } result . setSeconds ( 0 ) ; return result ; } \n', 0.42249605285354197)

('public static Date toDateFromLongFormat ( String date ) { if ( date == null ) return null ; if ( date . trim ( ) . matches ( "|d+" ) ) return new Date ( Long . valueOf ( date ) * 1000L ) ; Date parsedDate = toDateWithFormatString ( date , FACEBOOK_LONG_DATE_FORMAT ) ; if ( parsedDate == null ) parsedDate = toDateWithFormatString ( date , FACEBOOK_LONG_DATE_FORMAT_WITHOUT_TIMEZONE ) ; return parsedDate ; } \n', 0.42242956137241017)

('public String toMealDateString ( ) { String dayS = day ; Integer dayInt = 0 ; if ( day != null ) { dayInt = new Integer ( day ) ; } if ( dayInt < 10 && ! day . substring ( 0 , 1 ) . equals ( "0" ) ) { dayS = new String ( "" + 0 + day ) ; } int monthToPrint = month + 1 ; if ( monthToPrint == 13 ) { monthToPrint = 1 ; } String monthS ; if ( monthToPrint < 10 ) { monthS = new String ( "" + 0 + monthToPrint ) ; } else { monthS = new String ( "" + monthToPrint ) ; } return new String ( "" + year + "-" + monthS + "-" + dayS ) ; } \n', 0.4221163696557476)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 17 #################################
('private void parseCommandLineArguments ( final String [ ] arguments ) { if ( arguments == null || arguments . length == 0 ) { return ; } for ( String argument : arguments ) { if ( argument . startsWith ( "-m=" ) ) { this . minimized = Boolean . parseBoolean ( argument . substring ( "-m=" . length ( ) ) ) ; } } } \n', 0.4514160906825629)

('public static Map parseCommandLineArguments ( String [ ] args ) { HashMap retMap = new HashMap ( ) ; String lastArg = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . startsWith ( "-" ) ) { arg = arg . substring ( 1 , arg . length ( ) ) ; String [ ] values = arg . split ( "=" , 2 ) ; lastArg = arg ; retMap . put ( values [ 0 ] , values . length > 1 ? values [ 1 ] : "" ) ; } else if ( lastArg != null ) { String val = ( String ) retMap . get ( lastArg ) ; if ( "" . equals ( val ) ) retMap . put ( lastArg , arg ) ; } } LOG . finest ( "cliMap-" + retMap ) ; return retMap ; } \n', 0.44842028349654184)

('private CommandLine parseArgs ( String [ ] args ) throws ParseException { final CommandLineParser parser = new DefaultParser ( ) ; final Options options = createCommandLineOptions ( ) ; return parser . parse ( options , args ) ; }\n', 0.44771770906539315)

('private static void readCommandLineArgs ( String [ ] args ) throws NumberFormatException { for ( String s : args ) { if ( s . toLowerCase ( ) . startsWith ( "traincorpus=" ) ) TRAIN_CORPUS = "./input/" + s . split ( "=" ) [ 1 ] ; if ( s . toLowerCase ( ) . startsWith ( "testcorpus=" ) ) TEST_CORPUS = "./input/" + s . split ( "=" ) [ 1 ] ; } } \n', 0.44767473373204814)

('private void parseProgramArguments ( String [ ] args ) throws IllegalArgumentException { if ( args . length == 0 ) { ws_ = true ; deploymentDescriptorLocation_ = "LAN.xml" ; } else { nbDecimals_ = new Integer ( args [ 0 ] ) . intValue ( ) ; run_ = new Integer ( args [ 1 ] ) . intValue ( ) ; int deployment = new Integer ( args [ 2 ] ) . intValue ( ) ; switch ( deployment ) { case 1 : deploymentDescriptorLocation_ = "applicationDescriptor.xml" ; break ; case 2 : deploymentDescriptorLocation_ = "LAN.xml" ; break ; case 3 : throw new IllegalArgumentException ( "P2P-is-no-longer-supported" ) ; case 4 : deploymentDescriptorLocation_ = "sophia-cluster.xml" ; break ; case 5 : deploymentDescriptorLocation_ = "custom-descriptor.xml" ; break ; default : deploymentDescriptorLocation_ = "applicationDescriptor.xml" ; } } } \n', 0.4470231063550213)

('public static String parseCommandLineInput ( String [ ] args ) throws Exception { if ( args . length == 1 ) { String pattern = "[a-zA-z]+" ; String cityName = args [ 0 ] ; if ( cityName . matches ( pattern ) ) { return cityName ; } else { throw new InvalidParameterNameException ( "Please-pass-a-valid-city-name-as-a-parameter.-Aborting." ) ; } } else { throw new TooManyParametersException ( "Input-parameters-not-correctly-specified.-Please-only-specify-one-parameter.-Aborting." ) ; } } \n', 0.4454745052886194)

('private static void parseCommandLine ( final String [ ] args ) throws IOException { if ( args . length == 0 ) { Configuration . initializeFromClasspathConfig ( ) ; } else if ( args . length == 1 ) { Configuration . initializeFromConfigFile ( new File ( args [ 0 ] ) ) ; } else { System . err . println ( "usage:-Main-[config.properties]" ) ; System . exit ( 1 ) ; } } \n', 0.44481066389821966)

('public static void parseCommandLine ( String [ ] args ) { int argPtr = 0 ; while ( argPtr < args . length ) { String key = args [ argPtr ++ ] ; if ( key . startsWith ( "#" ) ) { String [ ] pair = key . split ( "=" ) ; if ( ! ( pair [ 0 ] . equals ( "#player" ) && pair [ 1 ] . equals ( ( String ) settings . get ( "team" ) + ( String ) settings . get ( "uniform" ) ) ) ) { break ; } } if ( key . startsWith ( "-" ) ) { key = key . substring ( 1 ) ; String value ; if ( key . contains ( "=" ) ) { value = key . substring ( key . indexOf ( "=" ) + 1 ) ; key = key . substring ( 0 , key . indexOf ( "=" ) ) ; } else { value = args [ argPtr ++ ] ; } if ( value . startsWith ( """ ) || value . startsWith ( "\'" ) ) { value = value . substring ( 1 , value . length ( ) - 1 ) ; } System . out . println ( "Setting-key-" + key + "-=-" + value ) ; override . put ( key , parseValue ( value ) ) ; } } } \n', 0.4425574828339722)

('private void parseProgramArguments ( String [ ] args ) { nbDecimals = new Integer ( args [ 0 ] ) . intValue ( ) ; nbIntervals = new Integer ( args [ 1 ] ) . intValue ( ) ; deploymentDescriptorLocation_ = args [ 2 ] ; System . err . println ( "PiBBP-:-deploymentDescriptorLocation-=-" + deploymentDescriptorLocation_ ) ; System . exit ( 0 ) ; } \n', 0.44151296384385963)

('public static void parseCommandLineArguments ( String [ ] args ) { int i = 0 , j ; String arg ; char flag ; boolean verboseFlag = false ; String ioUtilityName = "" ; while ( i < args . length && args [ i ] . startsWith ( "-" ) ) { arg = args [ i ++ ] ; if ( arg . equals ( "-verbose" ) ) { System . out . println ( "Verbose-mode-is-on..." ) ; verboseFlag = true ; } else if ( arg . equalsIgnoreCase ( "-i" ) || arg . equalsIgnoreCase ( "-ioutility" ) ) { if ( i < args . length ) ioUtilityName = args [ i ++ ] ; else System . err . println ( "You-must-supply-a-name-after-using-the--ioutility-flag." ) ; if ( verboseFlag ) System . out . println ( "Loading-IUOtility:-" + ioUtilityName ) ; } } if ( i == args . length ) System . err . println ( "Usage:-java-Adventure-[-verbose]-[-ioutility-utilityName]" ) ; else System . out . println ( "Success!" ) ; loadIOUtility ( ioUtilityName , verboseFlag ) ; } \n', 0.4406950845234333)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 18 #################################
('public Collection getNameValue ( String name ) { return ( Collection ) this . nameValueMap . get ( name . toLowerCase ( ) ) ; } \n', 0.40311821328227926)

('public Collection getNameValue ( String name ) { return ( Collection ) this . m . get ( name . toLowerCase ( ) ) ; } \n', 0.4018895478990663)

('public String getValueForName ( String name , Set < String > entries ) { if ( entries != null ) { for ( String entry : entries ) { Pair < String , String > pair = parse ( entry ) ; if ( pair != null && pair . getFirst ( ) . equals ( name ) ) { return pair . getSecond ( ) ; } } } return null ; } \n', 0.38855720200653193)

('private String getUniqueOperationName ( String name ) { int i = 1 ; String candidate ; do { candidate = name + i ++ ; } while ( name2OperationsMap . get ( candidate ) != null ) ; return candidate ; } \n', 0.38818248686969414)

('public float getAnyValueByName ( String key ) throws IllegalArgumentException { if ( kontenNamen . containsKey ( key ) ) { throw new IllegalArgumentException ( "Bitte-geben-Sie-einen-gltigen-Kontennamen-an." ) ; } int secKey = kontenNummern . get ( key ) . intValue ( ) ; return getAnyValueByNumber ( secKey ) ; } \n', 0.38639993620883717)

('public String getValueName ( int value ) { if ( valueNames == null ) { return null ; } return ( String ) valueNames . get ( new Integer ( value ) ) ; } \n', 0.38575732990509537)

('private String getValueForName ( String name ) { for ( int i = 0 ; i < fEntryNamesAndValues . length ; i ++ ) { Object [ ] entry = fEntryNamesAndValues [ i ] ; if ( name . equals ( entry [ 0 ] ) ) { return ( String ) entry [ 1 ] ; } } return ( String ) fEntryNamesAndValues [ 0 ] [ 0 ] ; } \n', 0.3853108874760999)

('public static < E extends Enum < E >> E getEnumFromName ( ResultSet resultSet , int columnIndex , Class < E > enumClass ) throws SQLException { String name = resultSet . getString ( columnIndex ) ; if ( name == null ) { return null ; } try { return Enum . valueOf ( enumClass , name ) ; } catch ( IllegalArgumentException e ) { throw new IllegalStateException ( "The-name-" + name + "-is-not-a-valid-name-for-the-enum-" + enumClass , e ) ; } } \n', 0.3852608269663103)

('public PrimitiveData getPrimitiveValueNamed ( String name ) { int counter = 0 ; while ( counter < primitives . size ( ) ) { PrimitiveData x = primitives . get ( counter ) ; if ( x . getName ( ) . equals ( name ) ) { return x ; } counter = counter + 1 ; } return null ; } \n', 0.384731711546502)

('private String getValueForName ( final String name ) { for ( int i = 0 ; i < fEntryNamesAndValues . length ; i ++ ) { String [ ] entry = fEntryNamesAndValues [ i ] ; if ( name . equals ( entry [ 0 ] ) ) { return entry [ 1 ] ; } } return fEntryNamesAndValues [ 0 ] [ 0 ] ; } \n', 0.3814181570306613)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 19 #################################
('public void exportPreviewCallback ( File file ) { String filename = file . getAbsolutePath ( ) ; if ( ! filename . endsWith ( "png" ) ) filename += ".png" ; GLOBAL . pngPreviewSaveLocation = filename ; GLOBAL . exportPreviewPNG = true ; } \n', 0.4189364010371111)

('public void exportDocuments ( File exportDirectory , String databaseName , File hibernateConfig ) throws Exception { XWikiContext xcontext = createXWikiContext ( databaseName , hibernateConfig ) ; Package pack = new Package ( ) ; pack . setWithVersions ( false ) ; pack . addAllWikiDocuments ( xcontext ) ; try { pack . exportToDir ( exportDirectory , xcontext ) ; } catch ( IOException e ) { throw new PackageException ( PackageException . ERROR_PACKAGE_UNKNOWN , "Failed-to-export-documents-to-[" + exportDirectory + "]" , e ) ; } disposeXWikiContext ( xcontext ) ; } \n', 0.41762532895749477)

('public void exportDefaultLibrary ( ) throws JAXBException { JAXBContext context = JAXBContext . newInstance ( TLALibrary . class ) ; Marshaller marshaller = context . createMarshaller ( ) ; File f = new File ( DEFAULT_LIBRARY_NAME ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , Boolean . TRUE ) ; marshaller . marshal ( this , f ) ; } \n', 0.4136081645332642)

('public static String exportMoMLToTemporaryFile ( NamedObj namedObj ) throws Exception { File temporaryFile = File . createTempFile ( "ptCopernicus" , ".xml" ) ; temporaryFile . deleteOnExit ( ) ; FileWriter writer = new FileWriter ( temporaryFile ) ; String header = "<class-name="Temp"-extends="ptolemy.actor.TypedCompositeActor">-" ; writer . write ( header , 0 , header . length ( ) ) ; namedObj . exportMoML ( writer , 1 , GENERATOR_NAME ) ; String footer = "</class>-" ; writer . write ( footer , 0 , footer . length ( ) ) ; writer . close ( ) ; return StringUtilities . substitute ( temporaryFile . toString ( ) , "|" , "/" ) ; } \n', 0.41322816911467064)

('private static File exportDiscoveredSchemas ( final List < Set > schemas , final IJavaProject project ) throws IOException , InterruptedException , CoreException { File dotFile ; String dotGraph ; File outputDirectory ; String dateIdentifier ; List < String > dslFiles ; List < String > rooScripts ; dateIdentifier = new SimpleDateFormat ( "yyyy.MM.dd.HH.mm.ss" ) . format ( System . currentTimeMillis ( ) ) ; outputDirectory = new File ( project . getProject ( ) . getLocation ( ) . toOSString ( ) , "exschema_results/" + dateIdentifier ) ; outputDirectory . mkdirs ( ) ; dotGraph = Util . createDotGraph ( schemas ) ; dotFile = Util . saveDotGraph ( dotGraph , outputDirectory ) ; Util . executeDotCommand ( dotFile ) ; rooScripts = Util . createRooScripts ( schemas ) ; Util . saveFiles ( rooScripts , outputDirectory , "rooScripts" , "roo" ) ; dslFiles = Util . createDslFiles ( schemas ) ; Util . saveFiles ( dslFiles , outputDirectory , "dslFiles" , "exschema" ) ; project . getProject ( ) . refreshLocal ( IResource . DEPTH_INFINITE , null ) ; return outputDirectory ; } \n', 0.41259054159832)

("public static void exportCSV ( File csvFile , List < List < String >> csvMap ) throws IOException { if ( ! csvFile . canRead ( ) ) throw new IOException ( I18n . get ( I18n . M_FILE_PERMISSION_NO_WRITE , csvFile . getPath ( ) ) ) ; try ( FileWriter writer = new FileWriter ( csvFile ) ) { for ( List < String > list : csvMap ) { for ( String s : list ) { writer . append ( s ) ; writer . append ( fieldSeparator ) ; } writer . append ( '|n' ) ; } } } \n", 0.4120104449911369)

('public static void serializeUserDefinedErrorParsers ( ) throws CoreException { try { DocumentBuilder builder = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; Document doc = builder . newDocument ( ) ; Element elementPlugin = doc . createElement ( ELEM_PLUGIN ) ; doc . appendChild ( elementPlugin ) ; if ( fUserDefinedErrorParsers != null ) { for ( Entry < String , IErrorParserNamed > entry : fUserDefinedErrorParsers . entrySet ( ) ) { IErrorParserNamed errorParser = entry . getValue ( ) ; addErrorParserExtension ( elementPlugin , errorParser ) ; } } serializeXml ( doc , getStoreLocation ( STORAGE_ERRORPARSER_EXTENSIONS ) ) ; } catch ( Exception e ) { throw new CoreException ( new Status ( IStatus . ERROR , "Failed-serializing-to-file-" + STORAGE_ERRORPARSER_EXTENSIONS , CCorePlugin . PLUGIN_ID , e ) ) ; } } \n', 0.4102963169434748)

('public void ExportProjectDialog ( ) { TreePath n = TreeMain . getSelectionPath ( ) ; if ( n == null ) { return ; } ProjectData node = ( ProjectData ) n . getLastPathComponent ( ) ; String s = Utils . SaveDialog ( this , Settings . LastLoadingDir , node . ProjectDir , ".myp" , bundle . getString ( "frmMain.MYPFile" ) , true , bundle . getString ( "frmMain.FileExist" ) ) ; if ( ! s . isEmpty ( ) ) { this . setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; ExportProject ( node , s ) ; Settings . LastLoadingDir = Utils . GetDirFromFilename ( s ) ; this . setCursor ( Cursor . getDefaultCursor ( ) ) ; } } \n', 0.4101175280749397)

('public int exportRecipes ( Context context ) { if ( this . Recipes . isEmpty ( ) ) return - 1 ; Gson gson = new Gson ( ) ; try { String jsonRecipes = gson . toJson ( this . Recipes ) ; File file = new File ( Environment . getExternalStorageDirectory ( ) , "MyRecipes.json" ) ; FileOutputStream fout = new FileOutputStream ( file ) ; fout . write ( jsonRecipes . getBytes ( Charset . forName ( "UTF-8" ) ) ) ; fout . flush ( ) ; fout . close ( ) ; } catch ( Exception e ) { return - 1 ; } return 0 ; } \n', 0.4082214249690157)

('static private List < File > exportDiagramsDefault ( Diagram system , File suggestedFile , FileFormatOption fileFormat ) throws IOException { if ( suggestedFile . exists ( ) && suggestedFile . isDirectory ( ) ) { throw new IllegalArgumentException ( "File-is-a-directory-" + suggestedFile ) ; } OutputStream os = null ; try { if ( canFileBeWritten ( suggestedFile ) == false ) { return Collections . emptyList ( ) ; } os = new BufferedOutputStream ( new FileOutputStream ( suggestedFile ) ) ; system . exportDiagram ( os , 0 , fileFormat ) ; } finally { if ( os != null ) { os . close ( ) ; } } return Arrays . asList ( suggestedFile ) ; } \n', 0.40761623306067896)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 20 #################################
('public static void setTemporaryDirectory ( Map < Object , Object > properties , String temporaryDirectory ) { properties . put ( TEMPORARY_DIRECTORY , temporaryDirectory ) ; } \n', 0.4386388141689046)

('public static void setDestDir ( Context context , String newPath ) { context . getSharedPreferences ( DEST_DIR , Context . MODE_PRIVATE ) . edit ( ) . putString ( DEST_DIR , newPath ) . commit ( ) ; } \n', 0.4356216152418356)

('public void setWorkingDir ( File cwd ) { if ( ! cwd . isDirectory ( ) ) { throw new IllegalArgumentException ( "The-argument-is-not-a-directory:-" + cwd . getAbsolutePath ( ) ) ; } this . cwd = cwd ; } \n', 0.43457147499725945)

('public void setVideoDir ( File dir ) { getSettings ( ) . videoDir = dir . getAbsolutePath ( ) ; videoDir = null ; } \n', 0.4333214855990762)

('public void setLdifDirectory ( File ldifDirectory ) { LOG . info ( "The-LDIF-directory-file-is-{}" , ldifDirectory . getAbsolutePath ( ) ) ; this . ldifDirectory = ldifDirectory ; } \n', 0.43108968863164054)

('public void setOuputDir ( File outputDir ) { checkRunning ( ) ; Simulator . outputDir = outputDir ; if ( ! outputDir . exists ( ) || ! outputDir . isDirectory ( ) ) { outputDir . mkdirs ( ) ; } } \n', 0.430838682555329)

('public void setWorkingDir ( File workingDir ) { try { this . workingDir = workingDir . getCanonicalFile ( ) . getAbsoluteFile ( ) ; } catch ( IOException e ) { myLog . l ( Log . INFO , "SessionThread-canonical-error" ) ; } } \n', 0.4301294159858626)

('@ Required public void setLogsDir ( File dir ) { if ( ! dir . isDirectory ( ) ) { throw new IllegalArgumentException ( "No-such-directory:-" + dir ) ; } if ( ! dir . canWrite ( ) ) { throw new IllegalArgumentException ( "Directory-not-writable:-" + dir ) ; } _logsDir = dir ; } \n', 0.42824246396630616)

('public void setWorldConifgsDirectory ( File worldConfigsDir ) { if ( ! worldConfigsDir . isDirectory ( ) ) return ; this . worldConfigsDir = worldConfigsDir ; } \n', 0.42798053392020224)

('public void setWorkingDirectory ( File wd ) { workingDirectory = ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) ? null : wd ; } \n', 0.42783612258074766)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 21 #################################
('public String getReasonPhrase ( ) throws Exception { return connection . getResponseMessage ( ) ; } \n', 0.41093172039303083)

('public String getStatusCodeString ( ) { rlock ( ) ; try { return statusCode == null ? null : statusCode . getValue ( ) ; } finally { runlock ( ) ; } } \n', 0.41041829514869743)

('public static String getReasonPhrase ( Client . Response response ) { return response . getStatusCode ( ) == 500 ? response . getStatusMessage ( ) : getReasonPhrase ( response . getMethod ( ) , response . getStatusCode ( ) ) ; } \n', 0.40523850167840275)

('public String getSavedPassword ( String username ) { return identities . get ( username ) ; } \n', 0.399141812328681)

('private String getStatusUrl ( CMnDbBuildData build , int status ) { StringBuffer url = new StringBuffer ( ) ; url . append ( statusUrl + "?" ) ; url . append ( IMnBuildForm . BUILD_ID_LABEL + "=" + build . getId ( ) ) ; url . append ( "&" ) ; url . append ( CMnBuildStatusForm . STATUS_LABEL + "=" + CMnBuildStatusForm . statusKeys [ status ] ) ; return url . toString ( ) ; } \n', 0.3990394455382612)

('@ Override public String getStatusLine ( ) { MetaData m = getMetaData ( ) ; if ( m == null ) { return null ; } String responseHead = m . response . get ( "response-head" ) ; String headers [ ] = responseHead . split ( "-" ) ; return headers [ 0 ] ; } \n', 0.3967767837253506)

('public String getExplainString ( TClientRequest request ) throws ImpalaException { StringBuilder stringBuilder = new StringBuilder ( ) ; createExecRequest ( request , stringBuilder ) ; return stringBuilder . toString ( ) ; } \n', 0.3950191252005364)

('public static String getBodyForWebLogin ( List < NameValuePair > params ) throws UnsupportedEncodingException { StringBuilder result = new StringBuilder ( ) ; boolean first = true ; for ( NameValuePair pair : params ) { if ( first ) { first = false ; } else { result . append ( SFKeywords . CHAR_AMPERSAND ) ; } result . append ( pair . getName ( ) ) ; result . append ( SFKeywords . EQUALS ) ; result . append ( pair . getValue ( ) ) ; } return result . toString ( ) ; } \n', 0.39491757490405593)

('public TokenStatus getStatus ( ) { if ( logOut ) { return TokenStatus . INACTIVE ; } if ( tokenCreationTimestamp == - 1 ) { return TokenStatus . DEAD ; } else if ( ( System . currentTimeMillis ( ) - tokenCreationTimestamp ) < TOKEN_LOCAL_LIFESPAN ) { return TokenStatus . ACTIVE ; } else { return TokenStatus . INACTIVE ; } } \n', 0.3919491866408573)

('public static int getLdapStatusCode ( Exception exception ) { int ldapStatusCode = - 1 ; String message = exception . getMessage ( ) ; if ( message != null && message . startsWith ( "[LDAP:-error-code-" ) ) { int begin = "[LDAP:-error-code-" . length ( ) ; int end = begin + 2 ; try { ldapStatusCode = Integer . parseInt ( message . substring ( begin , end ) . trim ( ) ) ; } catch ( NumberFormatException nfe ) { } } return ldapStatusCode ; } \n', 0.3918852850498964)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 22 #################################
('public String paramsAsRequest ( ) { StringBuffer result = new StringBuffer ( 512 ) ; Map params = paramValues ( ) ; Iterator i = params . entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; result . append ( entry . getKey ( ) ) ; result . append ( "=" ) ; result . append ( CmsEncoder . encode ( entry . getValue ( ) . toString ( ) , getCms ( ) . getRequestContext ( ) . getEncoding ( ) ) ) ; if ( i . hasNext ( ) ) { result . append ( "&" ) ; } } return result . toString ( ) ; } \n', 0.38389750101319386)

('public static HttpResponse postJSON ( JSONObject jsonData , String apiEndpoint , Context context ) { HttpResponse result = null ; if ( ! isOnline ( context ) ) { return null ; } else { result = postJsonString ( jsonData . toString ( ) , apiEndpoint , context ) ; return result ; } } \n', 0.3768976922373781)

('private JSONObject readJSONFormRequest ( HttpServletRequest request ) { final int buf_size = 4096 ; JSONObject jsonObject = null ; BufferedReader inputStream = null ; try { inputStream = new BufferedReader ( new InputStreamReader ( request . getInputStream ( ) , Configuration . getInstance ( ) . getCharacterEncoding ( ) ) ) ; CharArrayWriter data = new CharArrayWriter ( ) ; char buf [ ] = new char [ buf_size ] ; int ret ; while ( ( ret = inputStream . read ( buf , 0 , buf_size ) ) != - 1 ) { data . write ( buf , 0 , ret ) ; } if ( data . size ( ) == 0 ) return jsonObject ; jsonObject = new JSONObject ( data . toString ( ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( "read-request-post-data-errordon\'t-support-post-encoding" , e ) ; } catch ( IOException e ) { logger . error ( "read-request-post-data-errorio-exception" , e ) ; } catch ( ParseException e ) { logger . error ( "read-request-post-data-errorparse-json-error" , e ) ; } finally { IOUtils . closeQuietly ( inputStream ) ; } logger . debug ( "Received-request-post-data:{}" , jsonObject ) ; return jsonObject ; } \n', 0.36860520585157636)

('private static void serializeRequestsAsJSON ( Serializer serializer , Collection < Request > requests , Map < String , Attachment > attachments ) throws JSONException , IOException { JSONArray batch = new JSONArray ( ) ; for ( Request request : requests ) { request . serializeToBatch ( batch , attachments ) ; } serializer . writeRequestsAsJson ( BATCH_PARAM , batch , requests ) ; } \n', 0.36758558473069697)

('public JsonObject makeJsonRequest ( URL url ) throws IOException { Request request = Request . Get ( url . toString ( ) ) ; if ( getProxy ( ) != null ) { request = request . viaProxy ( getProxy ( ) ) ; } String json = request . execute ( ) . returnContent ( ) . asString ( ) ; JsonReader reader = Json . createReader ( new StringReader ( json ) ) ; return reader . readObject ( ) ; } \n', 0.3586584145109802)

('public String readJSONMessage ( ) throws IOException { StringBuilder sb = new StringBuilder ( START_CAPACITY ) ; boolean gotOpening = false ; boolean inQuotes = false ; boolean escaping = false ; int level = 0 ; while ( true ) { int rawChar = _reader . read ( ) ; if ( rawChar < 0 ) return null ; char c = ( char ) rawChar ; if ( ! gotOpening ) { if ( Character . isWhitespace ( c ) ) { } else if ( c == \'{\' ) { appendChar ( sb , c ) ; gotOpening = true ; level ++ ; } else { throw new IOException ( "Unexpected-character-before-opening-brace,-\'{\'." ) ; } } else { appendChar ( sb , c ) ; if ( escaping ) { escaping = false ; } else { if ( c == \'|\' ) { escaping = true ; } else if ( c == \'|"\' ) { if ( inQuotes ) inQuotes = false ; else inQuotes = true ; } else if ( c == \'{\' ) { level ++ ; } else if ( c == \'}\' ) { if ( inQuotes ) continue ; level -- ; if ( level == 0 ) break ; } } } } return sb . toString ( ) ; } \n', 0.35808751271009964)

('protected static JSONObject parseJSONResponse ( HttpEntity entity ) throws IOException , JSONException { ByteArrayOutputStream jsonBuffer = new ByteArrayOutputStream ( 1024 ) ; entity . writeTo ( jsonBuffer ) ; jsonBuffer . close ( ) ; String json = jsonBuffer . toString ( "UTF-8" ) ; return new JSONObject ( json ) ; } \n', 0.3579452813864447)

('public String paramsAsRequest ( ) { StringBuffer result = new StringBuffer ( 512 ) ; Map < String , Object > params = paramValues ( ) ; Iterator < Entry < String , Object >> i = params . entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Entry < String , Object > entry = i . next ( ) ; result . append ( entry . getKey ( ) ) ; result . append ( "=" ) ; result . append ( CmsEncoder . encode ( entry . getValue ( ) . toString ( ) , getCms ( ) . getRequestContext ( ) . getEncoding ( ) ) ) ; if ( i . hasNext ( ) ) { result . append ( "&" ) ; } } return result . toString ( ) ; } \n', 0.3542909431073834)

('private static Map < String , Object > handleJsonResponse ( String responseBody , HttpUriRequest request ) throws BoxViewException { TypeToken < Map < String , Object >> typeToken = new TypeToken < Map < String , Object >> ( ) { } ; java . lang . reflect . Type mapType = typeToken . getType ( ) ; Map < String , Object > jsonDecoded = GSON . fromJson ( responseBody , mapType ) ; if ( jsonDecoded == null ) { error ( JSON_RESPONSE_ERROR , null , request , responseBody ) ; } if ( jsonDecoded . containsKey ( "type" ) && jsonDecoded . get ( "type" ) . equals ( "error" ) ) { String message = "Server-Error" ; if ( jsonDecoded . containsKey ( "message" ) ) { message = jsonDecoded . get ( "message" ) . toString ( ) ; } error ( SERVER_ERROR , message , request , responseBody ) ; } return jsonDecoded ; } \n', 0.3526206918229785)

('protected Object serializeArgumentToJson ( Object pArg ) { if ( pArg == null ) { return null ; } else if ( pArg instanceof JSONAware ) { return pArg ; } else if ( pArg . getClass ( ) . isArray ( ) ) { return serializeArray ( pArg ) ; } else if ( pArg instanceof Map ) { return serializeMap ( ( Map ) pArg ) ; } else if ( pArg instanceof Collection ) { return serializeCollection ( ( Collection ) pArg ) ; } else { return pArg instanceof Number || pArg instanceof Boolean ? pArg : pArg . toString ( ) ; } } \n', 0.3513129654911224)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 23 #################################
('public Session openSession ( ) throws IOException { return connection . openSession ( ) ; } \n', 0.3660450207859914)

('private void _closeConn ( Connection conn ) { try { if ( conn != null ) { conn . close ( ) ; } } catch ( Exception ex ) { _log . info ( "Failed-to-close-Connection:-" + ex ) ; } } \n', 0.364865280987586)

('public synchronized Session openSession ( ) throws IOException { this . checkConnection ( ) ; return new Session ( cm , getOrCreateSecureRND ( ) ) ; } \n', 0.3640356948855172)

('public void downgradeLegalDepartment ( ) { String s = "DOWNGRADELEGALDEPARTMENT-" ; connection . send ( s ) ; } \n', 0.3629453049465279)

('private void connectionFailed ( String mac ) { Message msg = mHandler . obtainMessage ( Constants . MESSAGE_CONNECTION_FAILED , - 1 , - 1 , mac ) ; mHandler . sendMessage ( msg ) ; BluetoothComms . this . start ( ) ; } \n', 0.36233199932397886)

('private void connectionFailed ( String mac ) { Log . d ( "btdebug" , "connectionFailed()-" + mac ) ; Message msg = mHandler . obtainMessage ( Constants . MESSAGE_CONNECTION_FAILED , - 1 , - 1 , mac ) ; mHandler . sendMessage ( msg ) ; start ( ) ; } \n', 0.36080524211074205)

('public synchronized void onConnection ( ) { if ( this . socketHandler != null ) { socketHandler . handle ( this ) ; } } \n', 0.35915834557992554)

('@ Override public void onConnectionInfoAvailable ( final WifiP2pInfo info ) { go_name = info . groupOwnerAddress ; if ( info . isGroupOwner && ! server ) { new Thread ( new ServerSocketHandler ( ) ) . start ( ) ; new Thread ( new ClientSocketWriter ( info . groupOwnerAddress , 8988 , this ) ) . start ( ) ; server = true ; Log . d ( TAG , "I-am-the-group-owner" ) ; } else if ( ! info . isGroupOwner && ! client ) { new Thread ( new ClientSocketWriter ( info . groupOwnerAddress , 8988 , this ) ) . start ( ) ; client = true ; Log . d ( TAG , "I-am-not-the-group-owner" ) ; } } \n', 0.35852303681475955)

('public Document persistantConnect ( String website ) { Document htmlDoc = null ; while ( true ) { try { Thread . sleep ( 2000 ) ; Connection conn = Jsoup . connect ( website ) ; htmlDoc = conn . timeout ( 10000 ) . get ( ) ; break ; } catch ( IOException | InterruptedException e ) { System . out . println ( "Tried-to-connect-boss...-but-it-timed-out-=/" ) ; } } return htmlDoc ; } \n', 0.35822384111070227)

('public void patent ( ) { String s = "PATENT-" ; connection . send ( s ) ; } \n', 0.3578429312595096)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 24 #################################
('public static void copyFileToDirIfNecessary ( File oldFile , File outputDir ) throws IOException { File target = new File ( outputDir , oldFile . getName ( ) ) ; if ( ! target . exists ( ) || target . lastModified ( ) < oldFile . lastModified ( ) ) { FileInputStream in = new FileInputStream ( oldFile ) ; FileOutputStream out = new FileOutputStream ( target ) ; copyStream ( in , out ) ; in . close ( ) ; out . close ( ) ; target . setLastModified ( oldFile . lastModified ( ) ) ; } } \n', 0.391538426091698)

("public static File copyDisk ( final File mainFile , final File toDirectory ) throws IOException { final String name = mainFile . getName ( ) ; final int idx = name . lastIndexOf ( '.' ) ; final String beginName = name . substring ( 0 , idx ) ; final String endName = name . substring ( idx ) ; final File parentDir = mainFile . getParentFile ( ) ; File [ ] files = parentDir . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { boolean ok = name . startsWith ( beginName ) && name . endsWith ( endName ) ; return ok ; } } ) ; File mainFileCopy = null ; for ( File file : files ) { File f = copyFile ( file , toDirectory ) ; if ( file . getName ( ) . equals ( mainFile . getName ( ) ) ) { mainFileCopy = f ; } } return mainFileCopy ; } \n", 0.3808199236780443)

('public static void copyDir ( final File srcDir , final File destDir , final FileFilter filter ) throws IOException { copyDir ( srcDir , destDir , filter , true ) ; } \n', 0.37918947721707774)

('public void copyFromLocalFile ( Path src , Path dst ) throws IOException { copyFromLocalFile ( false , src , dst ) ; } \n', 0.37266021544785133)

('@ Override public File copyFile ( String strSrc , String strDest ) throws IOException { Path path = new Path ( strSrc ) ; if ( ! hdfs . exists ( path ) ) throw new IOException ( "file-does-not-exist!-" + strSrc ) ; File temp = new File ( strDest ) ; hdfs . copyToLocalFile ( path , new Path ( strDest ) ) ; return temp ; } \n', 0.3724951356988123)

('public void copyFromLocalFile ( Path local , Path destination , boolean overwrite ) throws IOException { FileSystem fs = local . getFileSystem ( configuration ) ; fs . copyFromLocalFile ( false , overwrite , local , destination ) ; } \n', 0.3722887624812087)

('public void copyFromLocalFile ( Path src , Path dst ) throws IOException { fs . copyFromLocalFile ( src , dst ) ; } \n', 0.3708995283276334)

('public void copyFromLocalFile ( String [ ] [ ] data , boolean overwrite ) throws IOException { for ( int i = 0 ; i < data . length ; i ++ ) { copyFromLocalFile ( new Path ( data [ i ] [ 0 ] ) , new Path ( data [ i ] [ 1 ] ) , overwrite ) ; } } \n', 0.37053770685114484)

('public static boolean copyRecursively ( File src , File target ) { if ( src . isDirectory ( ) ) { return copyDirectoryContents ( src , target ) ; } else { try { Files . copy ( src , target ) ; return true ; } catch ( IOException e ) { return false ; } } } \n', 0.35871800516500973)

('private static void copy ( File source , File dest , Filter onlyCopy ) throws IOException { if ( ! source . exists ( ) ) { return ; } if ( source . isDirectory ( ) ) { copyDir ( source , dest , onlyCopy ) ; } else { copyFile ( source , dest , onlyCopy ) ; } } \n', 0.35239632588122816)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 25 #################################
('public FileInputStream openFileInput ( @ NonNull File file ) { try { return super . openFileInput ( file . toString ( ) ) ; } catch ( IOException ioe ) { throw new IORuntimeException ( ioe ) ; } } \n', 0.38072069565063715)

('private void openFile ( File file ) throws IOException { if ( ! file . exists ( ) || ! file . canRead ( ) ) { return ; } int BUFFER_SIZE = 4096 ; FileInputStream fis = new FileInputStream ( file ) ; InputStreamReader isr = new InputStreamReader ( fis ) ; BufferedReader br = new BufferedReader ( isr ) ; StringBuffer textBuffer = new StringBuffer ( BUFFER_SIZE ) ; char [ ] buffer = new char [ BUFFER_SIZE ] ; int charsRead ; while ( ( charsRead = br . read ( buffer , 0 , BUFFER_SIZE ) ) > 0 ) { textBuffer . append ( buffer , 0 , charsRead ) ; } fEditor . setText ( textBuffer . toString ( ) ) ; if ( br != null ) { try { br . close ( ) ; } catch ( IOException e ) { } } } \n', 0.3799453975208481)

('private synchronized void openFile ( ) { try { if ( reader != null ) { reader . close ( ) ; } InputStream is = StreamUtils . inputStream ( file ) ; reader = new BufferedReader ( new InputStreamReader ( is , encoding ) , StreamUtils . BUFFER_SIZE ) ; if ( skipHeaderLine ) { reader . readLine ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } \n', 0.37741470790897735)

('public BufferedCsvReader ( String inputFilePath , String encoding ) throws FileNotFoundException , UnsupportedEncodingException { this . inputFilePath = inputFilePath ; Reader reader = new InputStreamReader ( new FileInputStream ( inputFilePath ) , encoding ) ; bufferedReader = new BufferedReader ( reader ) ; } \n', 0.37376067937353263)

('public static BufferedReader getBufferedReader ( File f , String encoding ) throws IOException { if ( encoding == null ) { encoding = DEFAULT_ENCODING ; } return new BufferedReader ( new InputStreamReader ( getInputStream ( f ) , encoding ) ) ; } \n', 0.37264694312987334)

('public BufferedFileReader ( final File aFile , final String aEncoding ) throws FileNotFoundException , UnsupportedEncodingException { super ( new InputStreamReader ( new FileInputStream ( aFile ) , aEncoding ) ) ; } \n', 0.3720089762349229)

('public static StringBuffer openFile ( InputStream stream ) throws IOException { InputStreamReader streamReader = null ; StringBuffer fileBuffer = new StringBuffer ( ) ; BufferedReader reader = null ; try { streamReader = new InputStreamReader ( stream ) ; reader = new BufferedReader ( streamReader ) ; char [ ] buffer = new char [ 1024 ] ; int line = reader . read ( buffer ) ; while ( line > 0 ) { fileBuffer . append ( buffer , 0 , line ) ; line = reader . read ( buffer ) ; } } finally { if ( streamReader != null ) { try { streamReader . close ( ) ; } catch ( Exception e ) { } } if ( reader != null ) { try { reader . close ( ) ; } catch ( Exception e ) { } } } return fileBuffer ; } \n', 0.37086678415382784)

('@ Override public InputStream openContents ( ) { try { return new FileInputStream ( file ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( "Unable-to-open-file-\'" + file . getAbsolutePath ( ) + "\'" , e ) ; } } \n', 0.37077542613967)

('public void open ( ) throws Exception { BufferedReader reader = new BufferedReader ( new FileReader ( getFile ( ) ) ) ; char [ ] buffer = new char [ 100 ] ; StringBuffer readResult = new StringBuffer ( ) ; int amountRead ; while ( ( amountRead = reader . read ( buffer , 0 , 100 ) ) == 100 ) { readResult . append ( buffer ) ; } readResult . append ( buffer , 0 , amountRead ) ; _text = readResult . toString ( ) ; } \n', 0.36998168830854894)

('public String openFromIJJar ( String path ) { String text = null ; try { InputStream is = this . getClass ( ) . getResourceAsStream ( path ) ; if ( is == null ) return null ; InputStreamReader isr = new InputStreamReader ( is ) ; StringBuffer sb = new StringBuffer ( ) ; char [ ] b = new char [ 8192 ] ; int n ; while ( ( n = isr . read ( b ) ) > 0 ) sb . append ( b , 0 , n ) ; text = sb . toString ( ) ; } catch ( IOException e ) { } return text ; } \n', 0.3691551485450696)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 26 #################################
('private long oneHourInFuture ( ) { return System . currentTimeMillis ( ) + TimeUnit . HOURS . toMillis ( 1 ) ; } \n', 0.4046899620739698)

('public int getMinuteForCalc ( ) { return calendar . get ( Calendar . MINUTE ) ; } \n', 0.40005997128667203)

('protected Long calculateInitialDelay ( Long currentTimeInMillis , LocalTime time ) { DateTime currentTime = new DateTime ( currentTimeInMillis ) ; Long initialDelay = 0L ; int currentHour = currentTime . getHourOfDay ( ) ; DateTime initialTime = new DateTime ( currentTimeInMillis ) . withHourOfDay ( time . getHourOfDay ( ) ) . withMinuteOfHour ( time . getMinuteOfHour ( ) ) . withSecondOfMinute ( 0 ) ; if ( currentHour > time . getHourOfDay ( ) ) { initialTime = initialTime . plusDays ( 1 ) ; } initialDelay = initialTime . getMillis ( ) - currentTime . getMillis ( ) ; return initialDelay ; } \n', 0.3987797398833783)

('public String getIdleTimeInMinAndSeconds ( ) { Calendar now = Calendar . getInstance ( ) ; long timeDiff = ( now . getTimeInMillis ( ) - getLastcommand ( ) . getTime ( ) ) / 1000 ; return "(" + timeDiff / 60 + "-min,-" + timeDiff % 60 + "-sec-idle)" ; } \n', 0.39799232808689944)

('public int getIntervalMinute ( ) { return getEndMinuteUnit ( ) - getBeginMinuteUnit ( ) ; } \n', 0.3974030447518983)

('@ Override public boolean isDurationEstimated ( ) { return this . compareTo ( DAYS ) >= 0 ; } \n', 0.39657025451247224)

('public long durationInMins ( ) { return interval . toDuration ( ) . getStandardMinutes ( ) ; } \n', 0.394134286616156)

('public long getMillisPassed ( ) { return ( System . nanoTime ( ) - startTime ) / 1000000 ; } \n', 0.39289708405836854)

('@ Benchmark public void nanoSecondBenchmark_avoidingReflectionOverhead ( int numIterations ) { for ( int i = 0 ; i < numIterations ; i ++ ) { System . nanoTime ( ) ; } } \n', 0.3920278612973598)

('public Long getPredictedArrivalOrDepartureSeconds ( ) { return ( predictedArrivalOrDepartureTimeUTC . getTime ( ) - System . currentTimeMillis ( ) ) / 1000 ; } \n', 0.3900009218994165)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 27 #################################
('protected String normalize ( String s ) { if ( s == null ) { return "" ; } StringBuilder str = new StringBuilder ( ) ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char ch = s . charAt ( i ) ; switch ( ch ) { case \'<\' : { str . append ( "&lt;" ) ; break ; } case \'>\' : { str . append ( "&gt;" ) ; break ; } case \'&\' : { str . append ( "&amp;" ) ; break ; } case \'"\' : { str . append ( "&quot;" ) ; break ; } case \'|r\' : case \'|n\' : { if ( canonical ) { str . append ( "&#" ) ; str . append ( Integer . toString ( ch ) ) ; str . append ( \';\' ) ; break ; } } default : { str . append ( ch ) ; } } } return ( str . toString ( ) ) ; } \n', 0.41022971733172675)

('public static String normalizeDirname ( String dirname ) { StringBuilder result = new StringBuilder ( dirname ) ; if ( dirname . contains ( "|" ) ) { if ( ! dirname . endsWith ( "|" ) ) { result . append ( \'|\' ) ; } } else if ( dirname . contains ( "/" ) ) { if ( ! dirname . endsWith ( "/" ) ) { result . append ( \'/\' ) ; } } else if ( dirname . length ( ) > 0 ) { result . append ( \'/\' ) ; } return result . toString ( ) ; } \n', 0.40869814169949326)

('public static String normalize ( String s , boolean canonical ) { StringBuilder str = new StringBuilder ( ) ; int len = s != null ? s . length ( ) : 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = s . charAt ( i ) ; switch ( ch ) { case \'<\' : str . append ( "&lt;" ) ; break ; case \'>\' : str . append ( "&gt;" ) ; break ; case \'&\' : str . append ( "&amp;" ) ; break ; case \'"\' : str . append ( "&quot;" ) ; break ; case \'|r\' : case \'|n\' : if ( canonical ) { str . append ( "&#" ) ; str . append ( Integer . toString ( ch & 0xFF ) ) ; str . append ( \';\' ) ; break ; } default : if ( ch < 0x20 ) { str . append ( "&#" ) ; str . append ( Integer . toString ( ch & 0xFF ) ) ; str . append ( \';\' ) ; } else if ( ch > 0xff00 ) { str . append ( ( char ) ( ch & 0xFF ) ) ; } else str . append ( ch ) ; } } return str . toString ( ) ; } \n', 0.40553845285699425)

('@ SuppressWarnings ( "cast" ) public static String normalize ( String s , boolean canonical ) { if ( s == null ) { return null ; } StringBuilder str = new StringBuilder ( ) ; int len = ( s != null ) ? s . length ( ) : 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = s . charAt ( i ) ; switch ( ch ) { case \'<\' : str . append ( "&lt;" ) ; break ; case \'>\' : str . append ( "&gt;" ) ; break ; case \'&\' : str . append ( "&amp;" ) ; break ; case \'"\' : str . append ( "&quot;" ) ; break ; case \'|r\' : case \'|n\' : if ( canonical ) { str . append ( "&#" ) ; str . append ( Integer . toString ( ( int ) ( ch & 0xFF ) ) ) ; str . append ( \';\' ) ; break ; } default : if ( ch < 0x20 ) { str . append ( "&#" ) ; str . append ( Integer . toString ( ( int ) ( ch & 0xFF ) ) ) ; str . append ( \';\' ) ; } else if ( ch > 0xff00 ) { str . append ( ( char ) ( ch & 0xFF ) ) ; } else str . append ( ch ) ; } } return ( str . toString ( ) ) ; } \n', 0.40411009934093833)

("private static String normalize ( String col ) { int preSingle = - 2 ; StringBuilder sb = new StringBuilder ( ) ; for ( int j = 0 , len = col . length ( ) ; j < len ; ++ j ) { char ch = col . charAt ( j ) ; if ( ch == '|'' ) { if ( preSingle == j - 1 ) { sb . append ( ch ) ; preSingle = - 2 ; } else { preSingle = j ; } } else { sb . append ( ch ) ; } } return sb . toString ( ) ; } \n", 0.40406544432946156)

('public String normalize ( String s ) throws RemoteException , RemoteException { if ( s == null ) { return "" ; } StringBuilder str = new StringBuilder ( ) ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char ch = s . charAt ( i ) ; switch ( ch ) { case \'<\' : { str . append ( "&lt;" ) ; break ; } case \'>\' : { str . append ( "&gt;" ) ; break ; } case \'&\' : { str . append ( "&amp;" ) ; break ; } case \'"\' : { str . append ( "&quot;" ) ; break ; } case \'|r\' : case \'|n\' : { if ( canonical ) { str . append ( "&#" ) ; str . append ( Integer . toString ( ch ) ) ; str . append ( \';\' ) ; break ; } } default : { str . append ( ch ) ; } } } return ( str . toString ( ) ) ; } \n', 0.4027647337721931)

('protected String normalize ( String s ) { StringBuilder str = new StringBuilder ( ) ; int len = ( s != null ) ? s . length ( ) : 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = s . charAt ( i ) ; switch ( ch ) { case \'<\' : { str . append ( "&lt;" ) ; break ; } case \'>\' : { str . append ( "&gt;" ) ; break ; } case \'&\' : { str . append ( "&amp;" ) ; break ; } case \'"\' : { str . append ( "&quot;" ) ; break ; } case \'|r\' : case \'|n\' : { if ( canonical ) { str . append ( "&#" ) ; str . append ( Integer . toString ( ch ) ) ; str . append ( \';\' ) ; break ; } } default : { str . append ( ch ) ; } } } return ( str . toString ( ) ) ; } \n', 0.4027647337721931)

('public static String swap ( String str , int i , int j ) { char [ ] chars = str . toCharArray ( ) ; swap ( chars , i , j ) ; return String . copyValueOf ( chars ) ; } \n', 0.402297144255907)

("private static Pair < String , String > normalize ( String s1 , String s2 ) { final int minLen = Math . min ( s1 . length ( ) , s2 . length ( ) ) ; final StringBuilder sb1 = new StringBuilder ( s1 ) ; final StringBuilder sb2 = new StringBuilder ( s2 ) ; for ( int i = 0 ; i < minLen ; i ++ ) { final char ch1 = s1 . charAt ( i ) ; final char ch2 = sb2 . charAt ( i ) ; if ( ch1 == ch2 && ch1 == '-' ) { sb1 . setCharAt ( i , '_' ) ; sb2 . setCharAt ( i , '_' ) ; } else if ( ch1 == '-' && ch2 != '_' ) { sb1 . setCharAt ( i , '_' ) ; } else if ( ch2 == '-' && ch1 != '_' ) { sb2 . setCharAt ( i , '_' ) ; } } s1 = sb1 . toString ( ) ; s2 = sb2 . toString ( ) ; return Pair . create ( s1 , s2 ) ; } \n", 0.3989036661460945)

('public static String normalize ( String s ) { StringBuffer str = new StringBuffer ( ) ; int len = ( s != null ) ? s . length ( ) : 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = s . charAt ( i ) ; switch ( ch ) { case \'<\' : { str . append ( "&lt;" ) ; break ; } case \'>\' : { str . append ( "&gt;" ) ; break ; } case \'&\' : { str . append ( "&amp;" ) ; break ; } case \'"\' : { str . append ( "&quot;" ) ; break ; } case \'|r\' : case \'|n\' : { str . append ( "&#" ) ; str . append ( Integer . toString ( ch ) ) ; str . append ( \';\' ) ; break ; } default : { str . append ( ch ) ; } } } return str . toString ( ) ; } \n', 0.3982562523191436)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 28 #################################
('public static String extractHtml ( String content , String startpoint , String endpoint ) { Pattern startPattern = Pattern . compile ( startpoint , Pattern . CASE_INSENSITIVE ) ; Pattern endPattern = Pattern . compile ( endpoint , Pattern . CASE_INSENSITIVE ) ; Matcher startMatcher = startPattern . matcher ( content ) ; Matcher endMatcher = endPattern . matcher ( content ) ; int start = 0 ; int end = content . length ( ) ; if ( startMatcher . find ( ) ) { start = startMatcher . end ( ) ; } if ( endMatcher . find ( start ) ) { end = endMatcher . start ( ) ; } return content . substring ( start , end ) ; } \n', 0.4225099506087976)

('public static String extractContentStrippingMarkup ( String htmlText , String startMark , String endMark ) { String content = "" ; int startMarkIndex = htmlText . indexOf ( startMark ) ; int endMarkIndex = htmlText . indexOf ( endMark ) ; if ( startMarkIndex != - 1 && endMarkIndex != - 1 ) { startMarkIndex += startMark . length ( ) ; content = htmlText . substring ( startMarkIndex , endMarkIndex ) ; Source src = new Source ( content ) ; content = src . getTextExtractor ( ) . toString ( ) ; } return content ; } \n', 0.4201197423600136)

('public String extractContent ( String xmlString ) { String regex = "(?<=|w|>).*(?=|<|/|w+)" ; Pattern re = Pattern . compile ( regex , Pattern . MULTILINE | Pattern . COMMENTS ) ; Matcher reMatcher = re . matcher ( xmlString ) ; while ( reMatcher . find ( ) ) { return reMatcher . group ( ) . trim ( ) ; } return "" ; } \n', 0.4194600492195314)

('private String extractContent ( String content , String regex ) { if ( StringUtils . isBlank ( regex ) ) { return null ; } Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( content ) ; if ( matcher . find ( ) ) { if ( matcher . groupCount ( ) > 0 ) { if ( matcher . groupCount ( ) > 1 ) { LOGGER . warn ( "Ignoring-{}-extra-regex-extract{}-for-regex-{}" , matcher . groupCount ( ) - 1 , matcher . groupCount ( ) > 2 ? "s" : "" , regex ) ; } return matcher . group ( 1 ) ; } } return null ; } \n', 0.4160184901089181)

("public boolean extractJSONfromHTML ( ) { JSONValue jsonValue ; String tagId = url . substring ( url . lastIndexOf ( '/' ) + 1 ) ; Element dataTag = Document . get ( ) . getElementById ( tagId ) ; if ( dataTag != null ) { jsonValue = JSONParser . parseStrict ( dataTag . getInnerHTML ( ) ) ; task . process ( jsonValue ) ; return true ; } else { String location = Window . Location . getHref ( ) ; return false ; } } \n", 0.41435941131403653)

('private String extractData ( String regexp , String htmlItem , int group ) { Pattern pattern = Pattern . compile ( regexp ) ; Matcher matcher = pattern . matcher ( htmlItem ) ; if ( matcher == null || ! matcher . find ( ) ) { throw new IllegalStateException ( "Impossible-to-parse-results.-Probably-Scambio-Etico-refactored-its-html-and-this-application-must-be-updated." ) ; } return matcher . group ( group ) ; } \n', 0.4127194650203217)

('private String extractFromHtml ( String content ) throws Exception { Parser myParser ; Node [ ] nodes = null ; myParser = Parser . createParser ( content , null ) ; NodeFilter filter = new NodeClassFilter ( TextNode . class ) ; nodes = myParser . extractAllNodesThatMatch ( filter ) . toNodeArray ( ) ; StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) { TextNode textnode = ( TextNode ) nodes [ i ] ; String line = textnode . toPlainTextString ( ) . trim ( ) ; result . append ( line ) ; } return result . toString ( ) ; } \n', 0.41264880182455893)

('public static LinkedList extractFootnotesFromContent ( String content ) { LinkedList < String > footnotes = new LinkedList < > ( ) ; int pos = 0 ; while ( pos != - 1 ) { pos = content . indexOf ( Constants . footnoteHtmlTag , pos ) ; if ( pos != - 1 ) { int end = content . indexOf ( """ , pos + Constants . footnoteHtmlTag . length ( ) ) ; if ( end != - 1 ) { String fn = content . substring ( pos + Constants . footnoteHtmlTag . length ( ) , end ) ; if ( - 1 == footnotes . indexOf ( fn ) ) { footnotes . add ( fn ) ; } pos = end ; } else { pos = pos + Constants . footnoteHtmlTag . length ( ) ; } } } return footnotes ; } \n', 0.4123791874405629)

('@ SuppressWarnings ( "unchecked" ) public static Map < String , String > extractMetaData ( Template template ) { Enumeration children = template . getRootTreeNode ( ) . children ( ) ; for ( TemplateElement child : new EnumerationIterator < TemplateElement > ( children ) ) { if ( child instanceof Comment ) { Comment c = ( Comment ) child ; return extractTags ( c . getText ( ) ) ; } } return null ; } \n', 0.4085096488943682)

('private HashMap < String , String > extractContentFromLPISTable ( final String input ) { HashMap < String , String > output = new HashMap < String , String > ( ) ; String [ ] rows = extractDataBetweenStartAndEndString ( input , "<tr" , "</tr>" ) ; Pattern startGoals = Pattern . compile ( ".*<b>Lernergebnisse.*</b>.*" ) ; Pattern startContent = Pattern . compile ( ".*<b>Inhalte-der-LV:</b>.*" ) ; for ( int i = 0 ; i < rows . length ; i ++ ) { Log . v ( TAG , "Row:-" + rows [ i ] ) ; if ( startGoals . matcher ( rows [ i ] ) . matches ( ) ) { output . put ( "goals" , extractDataBetweenStartAndEndString ( rows [ ++ i ] , "<td" , "</td>" ) [ 0 ] ) ; } else if ( startContent . matcher ( rows [ i ] ) . matches ( ) ) { output . put ( "content" , extractDataBetweenStartAndEndString ( rows [ ++ i ] , "<td" , "</td>" ) [ 0 ] ) ; } } return output ; } \n', 0.40641326792359056)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 29 #################################
('private String getHtmlUrlForCategories ( Node blogNode ) throws RepositoryException { String url = blogNode . getProperty ( BLOG_URL_PROPERTY ) . getString ( ) ; url += "/mode/categorieshtml" ; return url ; } \n', 0.40129276508980605)

('public static String getHtmlForAboutDialog ( Map < String , Object > contextParams ) { Template template = velocityEngine . getTemplate ( "res/templates/AboutTemplate.vm" ) ; VelocityContext context = new VelocityContext ( contextParams ) ; StringWriter writer = new StringWriter ( ) ; template . merge ( context , writer ) ; return writer . toString ( ) ; } \n', 0.397612521035409)

('private String getHtml ( String url ) throws IOException { URL u = new URL ( url ) ; System . out . println ( "connecting-to-[" + url + "]" ) ; URLConnection conn = u . openConnection ( ) ; conn . connect ( ) ; System . out . println ( "connected" ) ; int fileSize = conn . getContentLength ( ) ; System . out . println ( "file-size:" + fileSize ) ; System . out . println ( "downloading-html..." ) ; InputStream inStream = conn . getInputStream ( ) ; if ( - 1 == fileSize ) { return readWithoutLength ( inStream ) ; } else { return readWithLength ( inStream , fileSize ) ; } } \n', 0.3938582971763465)

('private String getLoggedOutPage ( final String redirectUrl ) { if ( redirectUrl == null ) { return getFileContent ( LOGOUT_FILENAME ) ; } else { final String pageContent = getFileContent ( LOGOUT_REDIRECT_FILENAME ) ; return PATTERN_REDIRECT_URL . matcher ( pageContent ) . replaceAll ( redirectUrl ) ; } } \n', 0.39227139510261627)

('private static String getWebLinkHtml ( ) { String content = null ; URLConnection connection = null ; try { connection = new URL ( SECI_LINKS_URL ) . openConnection ( ) ; Scanner scanner = new Scanner ( connection . getInputStream ( ) ) ; scanner . useDelimiter ( "|Z" ) ; content = scanner . next ( ) ; scanner . close ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return content ; } \n', 0.38798269203140223)

('private static Set < URL > getPageDefHtmlUrls ( final URL url , final String content , final Set < URL > history ) throws IOException { assert url != null ; assert content != null ; assert history != null ; final Set < URL > ret = new HashSet < > ( ) ; final Matcher mat = URL_PATTERN . matcher ( content ) ; while ( mat . find ( ) ) { final String furl = mat . group ( 1 ) ; if ( furl . endsWith ( ".def" ) || furl . endsWith ( ".html" ) || furl . endsWith ( ".htm" ) ) { final URL domainUrl = withDomain ( url , furl ) ; if ( ! history . contains ( domainUrl ) ) { ret . add ( domainUrl ) ; } } } history . add ( url ) ; return ret ; } \n', 0.3878968796672154)

('public static String getDirectiveHelp ( final String aDirective ) { StringBuilder help = new StringBuilder ( ) ; help . append ( Messages . getString ( "directive." + aDirective + ".help" ) ) ; if ( Messages . containsKey ( "directive." + aDirective + ".sample" ) ) { help . append ( "<p><a-href="" ) ; help . append ( BasicInternalLinkHandler . makeLink ( IAssistanceConstants . SAMPLE_LINK_PREFIX , aDirective ) ) ; help . append ( "">" ) ; help . append ( Messages . getString ( IAssistanceConstants . INSERT_SAMPLE_MESSAGE ) ) ; help . append ( "</a></p>" ) ; } return help . toString ( ) ; } \n', 0.3840761761052031)

('public static String getWebPage ( URL url ) { StringBuffer page = new StringBuffer ( ) ; try { URLConnection connection = url . openConnection ( ) ; String line ; BufferedReader in ; if ( connection . getContentEncoding ( ) == null ) in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; else in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) , connection . getContentEncoding ( ) ) ) ; while ( ( line = in . readLine ( ) ) != null ) page . append ( line ) . append ( \'|n\' ) ; in . close ( ) ; } catch ( UnsupportedEncodingException e ) { System . err . println ( "WebPage.getWebPage():-" + e ) ; } catch ( IOException e ) { System . err . println ( "WebPage.getWebPage():-" + e ) ; } return page . toString ( ) ; } \n', 0.384032890342042)

('private void retrieveHTML ( String URL ) throws IOException { Connection connection = Jsoup . connect ( URL ) ; Document htmlDocument = connection . get ( ) ; Elements linksOnPage = htmlDocument . select ( "a[href]" ) ; Element ele = null ; int size = linksOnPage . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { ele = linksOnPage . get ( i ) ; if ( ! uniqueURLS . contains ( ele . absUrl ( "href" ) ) ) { uniqueURLS . add ( ele . absUrl ( "href" ) ) ; } } } \n', 0.3839511835372207)

('public static URL getHTMLPageURL ( FileObject htmlFile , String activePlatform ) { assert htmlFile != null : "htmlFile-cannot-be-null" ; JavaPlatform platform = VisageProjectUtil . getActivePlatform ( activePlatform ) ; boolean workAround6193279 = platform != null && platform . getSpecification ( ) . getVersion ( ) . compareTo ( JDK_15 ) >= 0 ; URL url = null ; if ( workAround6193279 ) { File f = FileUtil . toFile ( htmlFile ) ; try { String path = f . getAbsolutePath ( ) ; if ( File . separatorChar != \'/\' ) { path = path . replace ( File . separatorChar , \'/\' ) ; } path = path . replaceAll ( "-" , "%20" ) ; url = new URL ( "file" , null , path ) ; } catch ( MalformedURLException e ) { ErrorManager . getDefault ( ) . notify ( e ) ; } } else { try { url = htmlFile . getURL ( ) ; } catch ( FileStateInvalidException f ) { ErrorManager . getDefault ( ) . notify ( f ) ; } } return url ; } \n', 0.38098236982895395)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 30 #################################
('protected void writeVendorFileFooter ( BufferedWriter writer ) throws IOException { writer . write ( "</p>-" ) ; writer . write ( "<p>-" ) ; writer . write ( "<a-href="index.html">Back</a>" ) ; writer . write ( "</p>-" ) ; writer . write ( "</body>-" ) ; writer . write ( "</html>-" ) ; } \n', 0.41571304270402265)

('public static void writeOnHtmlReport ( String text ) { try { BufferedWriter writer = new BufferedWriter ( new FileWriter ( batchReportFile , true ) ) ; writer . newLine ( ) ; writer . write ( text ) ; writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.4050490001334113)

('private void outputFileFooter ( ) { moFileStream . println ( "---|-End-of-log-|------------------------------------------------------" ) ; } \n', 0.40396287130630876)

('private void outputFileFooter ( ) { moFileStream . println ( "-</log-entries>" ) ; moFileStream . println ( "</log>" ) ; } \n', 0.40396287130630876)

('private void outputFileFooter ( ) { moFileStream . println ( "|par-|par-----------------------------------------------------------------------------|par" ) ; moFileStream . println ( "}" ) ; } \n', 0.40396287130630876)

("protected void writeFileFooter ( PrintWriter pw ) throws IOException { super . writeFileFooter ( pw ) ; pw . println ( '}' ) ; } \n", 0.40383814689356634)

('protected void writeFileFooter ( PrintWriter pw ) throws IOException { pw . println ( ) ; pw . println ( "-/**" ) ; pw . println ( "-*-Writes-the-exception-data-to-the-faultDetails" ) ; pw . println ( "-*/" ) ; pw . println ( "-public-void-writeDetails(javax.xml.namespace.QName-qname,-org.apache.axis.encoding.SerializationContext-context)-throws-java.io.IOException-{" ) ; pw . println ( "-context.serialize(qname,-null,-this);" ) ; pw . println ( "-}" ) ; super . writeFileFooter ( pw ) ; } \n', 0.40383814689356634)

('public static void writeHTML ( ArrayList < String > linesToWrite , String savePath ) throws IOException { Path savePath2 = Paths . get ( savePath ) ; Files . write ( savePath2 , linesToWrite , Charset . defaultCharset ( ) ) ; } \n', 0.4032058805251844)

('public void logHTMLContext ( String path ) { String source = getHtmlSource ( ) ; BufferedWriter writer = null ; try { writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( path ) ) ) ; writer . write ( source ) ; writer . flush ( ) ; } catch ( Exception e ) { throw new RuntimeException ( "Unable-to-save-HTML-body" , e ) ; } finally { try { writer . close ( ) ; } catch ( Exception e ) { } } } \n', 0.39967193479731933)

('public HtmlReporter ( Main client , File output ) throws IOException { super ( client , output ) ; mWriter = new BufferedWriter ( new FileWriter ( output ) ) ; } \n', 0.3995449554227901)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 31 #################################
('public String getLocalIP ( ) { String ip = socket . getLocalAddress ( ) . getHostAddress ( ) ; if ( ip . equals ( "0.0.0.0" ) ) ip = "127.0.0.1" ; return ip ; } \n', 0.40504970391393147)

('public static String getClientIpAddress ( ) { return ( String ) clientIpAddress . get ( ) ; } \n', 0.4023261090756701)

('private String [ ] getOctetsFromIP ( ) { return ip . getHostAddress ( ) . split ( "|." ) ; } \n', 0.40198109169338725)

('public static String getMacAddress ( final NetworkInterface ni ) throws SocketException { if ( log . isDebugEnabled ( ) ) log . debug ( HelperLog . methodStart ( ni ) ) ; if ( null == ni ) { throw new RuntimeExceptionIsNull ( "ni" ) ; } final StringBuilder sb = new StringBuilder ( ) ; final byte [ ] hardwareAddress = ni . getHardwareAddress ( ) ; if ( null != hardwareAddress ) { for ( int ii = 0 ; ii < hardwareAddress . length ; ii ++ ) { sb . append ( String . format ( ( 0 == ii ? HelperString . EMPTY_STRING : \'-\' ) + "%02X" , hardwareAddress [ ii ] ) ) ; } } final String result = sb . toString ( ) ; if ( log . isDebugEnabled ( ) ) log . debug ( HelperLog . methodExit ( result ) ) ; return result ; } \n', 0.40163696129836296)

('public InetAddress getRemoteIPAddress ( ) { if ( _remoteIPAddress == null ) { try { _remoteIPAddress = InetAddress . getByAddress ( _remoteIP ) ; } catch ( UnknownHostException uhe ) { if ( _log . shouldLog ( Log . ERROR ) ) _log . error ( "Invalid-IP?-" , uhe ) ; } } return _remoteIPAddress ; } \n', 0.39980779783403586)

('public Router getRouterFromIP ( String address ) { return IPToRouter . get ( address ) ; } \n', 0.3995269848402556)

('public static Integer getPort ( String addressWithHostAndPort ) { if ( addressWithHostAndPort == null ) return null ; try { return Integer . valueOf ( addressWithHostAndPort . split ( ":" , 2 ) [ 1 ] ) ; } catch ( Throwable t ) { logWarn ( logger , "fail-to-get-port-from-" , addressWithHostAndPort , t ) ; return null ; } } \n', 0.3981272995846992)

('private static String getPortFromLocalAddress ( final InetSocketAddress local ) { switch ( local . getPort ( ) ) { case 80 : return "" ; case 443 : return "" ; default : return ":" + local . getPort ( ) ; } } \n', 0.39809842883400803)

('public static String getLocalIpAddress ( ) { if ( localIpAddress . length ( ) == 0 ) { localIpAddress = "0.0.0.0" ; } return localIpAddress ; } \n', 0.39764766508978444)

('public static String getIpAddress ( ) { return ipAddress . get ( ) ; } \n', 0.39738922948139765)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 32 #################################
("private double findExclamationMarksWeight ( String sentence ) { int numExclamations = 0 ; for ( int i = 0 ; i < sentence . length ( ) ; ) { if ( sentence . charAt ( i ) == '!' ) { int temp = 1 ; while ( ++ i < sentence . length ( ) ) { if ( sentence . charAt ( i ) == '!' ) { temp += 1 ; } else { i ++ ; break ; } } if ( numExclamations < temp ) numExclamations = temp ; } else i ++ ; } return numExclamations * WEIGHT_PER_EXCLAMATION_MARK ; } \n", 0.41252158912792936)

('private double computeStringSimilarity ( String s1 , String s2 ) { ArrayList < String > pairs1 = letterPairs ( s1 ) ; ArrayList < String > pairs2 = letterPairs ( s2 ) ; int intersection = 0 ; int union = pairs1 . size ( ) + pairs2 . size ( ) ; for ( int i = 0 ; i < pairs1 . size ( ) ; i ++ ) { Object pair1 = pairs1 . get ( i ) ; for ( int j = 0 ; j < pairs2 . size ( ) ; j ++ ) { Object pair2 = pairs2 . get ( j ) ; if ( pair1 . equals ( pair2 ) ) { intersection ++ ; pairs2 . remove ( j ) ; break ; } } } return ( 2.0 * intersection ) / union ; } \n', 0.4106422050322428)

('public static int levenshteinSimilarity ( String compareString1 , String compareString2 , int minPercent ) { int dlw = getLevenshteinDistance ( compareString1 , compareString2 , minPercent ) ; if ( ( minPercent > - 1 ) && ( dlw == - 1 ) ) return 0 ; int maxlwlm = Math . max ( compareString1 . length ( ) , compareString2 . length ( ) ) ; int percent = 100 ; if ( maxlwlm > 0 ) { percent = 100 - ( dlw * 100 ) / maxlwlm ; if ( percent >= 100 ) { percent = 100 ; if ( ! compareString1 . equals ( compareString2 ) ) percent = percent - 1 ; } else if ( percent < 0 ) { percent = 0 ; } } return percent ; } \n', 0.4052618261405815)

('public double binaryProbability ( String rule ) { String [ ] ruleComponents = rule . split ( "-" ) ; if ( ! nonTerminalCounts . containsKey ( ruleComponents [ 0 ] ) ) { return 0 ; } double binaryCount = binaryCounts . get ( rule ) ; double nonTerminalCount = nonTerminalCounts . get ( ruleComponents [ 0 ] ) ; return binaryCount / nonTerminalCount ; } \n', 0.4020272926081856)

('void doNClusters ( StringTokenizer tokens ) throws SyntaxError { if ( ! tokens . hasMoreTokens ( ) ) { throw new SyntaxError ( "Numero-de-clusters-no-especificado" ) ; } String tmp = tokens . nextToken ( ) ; parNClusters = Integer . parseInt ( tmp ) ; } \n', 0.40134647668465273)

('private static double similarity ( String a , String b ) { a = a . toLowerCase ( ) ; b = b . toLowerCase ( ) ; int [ ] costs = new int [ b . length ( ) + 1 ] ; for ( int j = 0 ; j < costs . length ; j ++ ) costs [ j ] = j ; for ( int i = 1 ; i <= a . length ( ) ; i ++ ) { costs [ 0 ] = i ; int nw = i - 1 ; for ( int j = 1 ; j <= b . length ( ) ; j ++ ) { int cj = Math . min ( 1 + Math . min ( costs [ j ] , costs [ j - 1 ] ) , a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ? nw : nw + 1 ) ; nw = costs [ j ] ; costs [ j ] = cj ; } } return costs [ b . length ( ) ] ; } \n', 0.40086626619146265)

('public Double scoreString ( String prefix ) { Letter thisLetter = root ; while ( prefix . length ( ) > 0 ) { Character thisChar = prefix . charAt ( 0 ) ; prefix = prefix . substring ( 1 ) ; if ( ! thisLetter . hasChild ( thisChar ) ) { return new Double ( 0 ) ; } else { thisLetter = thisLetter . getChild ( thisChar ) ; } } return thisLetter . score ( ) . doubleValue ( ) ; } \n', 0.4002494879815813)

('public String hamming ( String userInput , String Xbrltext ) { float similarity = 0.0f ; float count = 0.0f ; String simi ; char [ ] user = userInput . toCharArray ( ) ; char [ ] xbrl = Xbrltext . toCharArray ( ) ; int shortest = Math . min ( user . length , xbrl . length ) ; int longest = Math . max ( user . length , xbrl . length ) ; for ( int i = 0 ; i < shortest ; i ++ ) { if ( user [ i ] != xbrl [ i ] ) count += 1 ; } count += longest - shortest ; if ( count == 0.0f ) { return "100%" ; } similarity = ( Xbrltext . length ( ) - count ) / Xbrltext . length ( ) ; NumberFormat format = NumberFormat . getInstance ( ) ; format . setMaximumIntegerDigits ( 2 ) ; format . setMaximumFractionDigits ( 2 ) ; simi = format . format ( similarity * 100 ) + "%" ; return simi ; } \n', 0.39970988521950584)

('private double similarityScore ( String a , String b ) { double result ; if ( a . equals ( b ) ) { result = 1. ; } else { result = - mu ; } return result ; } \n', 0.3994069081636745)

('long computeAverage ( List < String > lines ) { if ( lines == null ) { throw new IllegalArgumentException ( "lines-must-not-be-null" ) ; } String text = joinLines ( lines , "-" ) ; String [ ] sentences = text . split ( "[" + sentenceDelimiters + "]" ) ; long totalWords = 0 ; for ( String sentence : sentences ) { String [ ] words = sentence . trim ( ) . split ( "|s+" ) ; for ( String word : words ) { if ( word . length ( ) >= minWordLength ) { totalWords ++ ; } } } long sentenceCount = sentences . length ; return totalWords / sentenceCount ; } \n', 0.3992946202501967)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 33 #################################
('private static int sampleFromDistribution ( double [ ] distribution , Random rng ) { double d = rng . nextDouble ( ) ; double sum = 0.0 ; for ( int i = 0 ; i < distribution . length ; i ++ ) { sum += distribution [ i ] ; if ( d <= sum ) return i ; } throw new IllegalArgumentException ( "Distribution-is-invalid?-d=" + d + ",-sum=" + sum ) ; } \n', 0.41048257155667944)

('public static int sampleFromDistribution ( double [ ] distribution , Random rng ) { double d = rng . nextDouble ( ) ; double sum = 0.0 ; for ( int i = 0 ; i < distribution . length ; i ++ ) { sum += distribution [ i ] ; if ( d <= sum ) return i ; } throw new IllegalArgumentException ( "Distribution-is-invalid?-d=" + d + ",-sum=" + sum ) ; } \n', 0.41048257155667944)

('public static DoubleArray rand ( int size , RealDistribution distribution ) { DoubleArray array = doubleArray ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { array . set ( i , distribution . sample ( ) ) ; } return array ; } \n', 0.41034901251569345)

('public void priorSample ( ) { Random r = new Random ( ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) { if ( r . nextDouble ( ) < nodes [ i ] . conditionalProbability ( ) ) { nodes [ i ] . value = true ; } else nodes [ i ] . value = false ; } } \n', 0.40674557104303116)

('public static double Accuracy ( double accuracy , double dodge ) { int outcome = 0 ; Random generator = new Random ( ) ; double probability = generator . nextDouble ( ) ; if ( probability * 100 <= ( accuracy - dodge ) ) { outcome = 1 ; System . out . println ( "Hit!" ) ; } else { System . out . println ( "Swing-and-a-miss!" ) ; } return outcome ; } \n', 0.40352055342091026)

('public static final double randPmOne ( ) { return ( Math . random ( ) < 0.5 ) ? - 1.0 : 1.0 ; } \n', 0.4034611091952551)

("public void randBoard ( int x , int y , int pr ) { board = new char [ x ] [ y ] ; for ( int i = 0 ; i < x ; i ++ ) { for ( int j = 0 ; j < y ; j ++ ) { double r = Math . round ( Math . random ( ) * 100 ) ; if ( r <= pr ) { board [ i ] [ j ] = 'B' ; } else board [ i ] [ j ] = 'U' ; } } fillWithNums ( ) ; } \n", 0.4029758398013852)

('public static void calcNewBuyProbability ( ) { currBuyProbability = currBuyProbability + ( new UniformRealDistribution ( JinSup . randGen , Parameters . lowerUniformBound , Parameters . upperUniformBound ) ) . sample ( ) ; if ( currBuyProbability < Parameters . minBuyProbability ) { currBuyProbability = Parameters . minBuyProbability ; } if ( currBuyProbability > Parameters . maxBuyProbability ) { currBuyProbability = Parameters . maxBuyProbability ; } } \n', 0.40047321339072234)

('private int weightedDistribution ( int [ ] weights ) { int sum = 0 ; for ( int i = 0 ; i < weights . length ; i ++ ) sum += weights [ i ] ; int val = ( int ) Math . floor ( r . nextDouble ( ) * sum ) ; for ( int i = 0 ; i < weights . length ; i ++ ) { val -= weights [ i ] ; if ( val < 0 ) return i ; } return - 1 ; } \n', 0.40044697102216875)

('private int weightedRank ( int rank ) { return g_random . nextInt ( 0x100 ) ; } \n', 0.3997937728526177)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 34 #################################
('public static StringBuffer writeCSV ( String [ ] fields ) { StringBuffer sb = null ; for ( String field : fields ) { sb = append ( sb , field ) ; } if ( sb == null ) { sb = new StringBuffer ( ) ; } sb . append ( CRLF ) ; return sb ; } \n', 0.3996006651987638)

('private void writeCSV ( String value , OutputStreamWriter w ) throws IOException { w . append ( value + ";" ) ; } \n', 0.39220637127913405)

('private void writeCSV ( String div ) { dataCSV csv ; int nivel = 0 ; csv = ( dataCSV ) csvData . elementAt ( 0 ) ; nivel = csv . data . size ( ) ; for ( int i = 1 ; i < csvData . size ( ) ; i ++ ) { csv = ( dataCSV ) csvData . elementAt ( i ) ; if ( csv . data . size ( ) > nivel ) { nivel = csv . data . size ( ) ; } } for ( int i = 0 ; i < csvData . size ( ) ; i ++ ) { csv = ( dataCSV ) csvData . elementAt ( i ) ; for ( int j = csv . data . size ( ) ; j < nivel ; j ++ ) { if ( csv . parent ) csv . data . addElement ( csv . data . elementAt ( 0 ) ) ; else csv . data . addElement ( "" ) ; } } String data ; int i ; if ( nivel > 1 ) i = 1 ; else i = 0 ; for ( ; i < nivel ; i ++ ) { for ( int j = 0 ; j < csvData . size ( ) ; j ++ ) { csv = ( dataCSV ) csvData . elementAt ( j ) ; data = ( String ) csv . data . elementAt ( i ) ; sb . append ( """ ) . append ( data ) . append ( """ ) . append ( div ) ; } sb . append ( "-" ) ; } } \n', 0.39163111143393403)

('private final static void writeCSV ( final PrintWriter pw , final String ... values ) { assert values . length == 3 ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) pw . print ( ",-" ) ; String v = values [ i ] ; if ( v != null && ( v . contains ( "," ) || v . contains ( """ ) || v . contains ( "#" ) || containsWhitespace . matcher ( v ) . find ( ) ) ) v = \'"\' + v . replace ( """ , """" ) + \'"\' ; pw . print ( v ) ; } pw . println ( ) ; } \n', 0.3889135473442916)

('public void writeCsv ( ConsoleTable table , PrintWriter writer ) { OutputStream os = new WriterOutputStream ( writer ) ; PrintStream ps = new PrintStream ( os ) ; try { writeCsv ( table , ps ) ; } finally { ps . close ( ) ; } } \n', 0.38846976505952546)

('public void saveCSVConfig ( final OutputStream out ) throws IOException { final OutputStreamWriter writer = new OutputStreamWriter ( out ) ; final CsvWriter csv = new CsvWriter ( ) ; try { final Enumeration keys = params . keys ( ) ; final Enumeration values = params . elements ( ) ; while ( keys . hasMoreElements ( ) ) { final String key = ( String ) keys . nextElement ( ) ; final String value = ( String ) values . nextElement ( ) ; csv . append ( key ) ; csv . append ( value ) ; csv . nl ( ) ; writer . write ( csv . toString ( ) ) ; csv . reset ( ) ; } } finally { writer . close ( ) ; out . close ( ) ; } } \n', 0.3874548523264726)

('private static void writeCSV ( String table , HashMap < String , ArrayList < String >> data , String output ) throws Exception { int max = 0 ; for ( String key : data . keySet ( ) ) { int size = data . get ( key ) . size ( ) ; if ( size > max ) max = size ; } StringBuilder s = new StringBuilder ( ) ; for ( String key : data . keySet ( ) ) { s . append ( key ) ; s . append ( ";" ) ; } s . append ( "-" ) ; for ( int i = 0 ; i < max ; i ++ ) { for ( String key : data . keySet ( ) ) { if ( data . get ( key ) . size ( ) > i ) { s . append ( data . get ( key ) . get ( i ) ) ; } else { s . append ( "%empty%" ) ; } s . append ( ";" ) ; } s . append ( "-" ) ; } FileWriter fw = new FileWriter ( output + table + ".csv" ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( s . toString ( ) ) ; bw . close ( ) ; } \n', 0.38683860103531653)

('public void writeCSV ( Writer writer , String columnDelimiter , String rowDelimiter ) throws IOException { for ( K k : getItems ( ) ) { writer . write ( k . toString ( ) ) ; writer . write ( columnDelimiter ) ; writer . write ( acc . get ( k ) . toString ( ) ) ; writer . write ( rowDelimiter ) ; } } \n', 0.3868236753386918)

('public StringBuilder writeCsv ( LinkedHashMap < String , List < String >> csvMap ) { StringBuilder sb = new StringBuilder ( ) ; int nrOfRows = 0 ; for ( String header : csvMap . keySet ( ) ) { nrOfRows = csvMap . get ( header ) . size ( ) ; sb . append ( header ) ; sb . append ( "," ) ; } sb . setLength ( sb . length ( ) - 1 ) ; sb . append ( "-" ) ; for ( int row = 0 ; row < nrOfRows ; row ++ ) { for ( String header : csvMap . keySet ( ) ) { sb . append ( csvMap . get ( header ) . get ( row ) ) ; sb . append ( "," ) ; } sb . setLength ( sb . length ( ) - 1 ) ; sb . append ( "-" ) ; } return sb ; } \n', 0.3837516138978032)

('public void writeConflictingDocuments ( Writer out ) throws IOException { BufferedWriter bw = ( ( out instanceof BufferedWriter ) ? ( ( BufferedWriter ) out ) : new BufferedWriter ( out ) ) ; for ( int f = 0 ; f < this . listFieldNames . length ; f ++ ) { if ( f != 0 ) bw . write ( "," ) ; bw . write ( \'"\' + this . listFieldNames [ f ] + \'"\' ) ; } bw . newLine ( ) ; for ( int c = 0 ; c < this . conflictingDocuments . length ; c ++ ) { bw . write ( this . conflictingDocuments [ c ] . toCsvString ( \'"\' , this . listFieldNames ) ) ; bw . newLine ( ) ; } if ( bw != out ) bw . flush ( ) ; } \n', 0.38001549634846155)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 35 #################################
('void checkMutableComboBoxModel ( ) { if ( ! ( m_model instanceof MutableComboBoxModel ) ) throw new RuntimeException ( "Cannot-use-this-method-with-a-non-Mutable-data-model." ) ; } \n', 0.4100719190504546)

('public static boolean isMailingListEditor ( User user ) throws PortalException , SystemException { List < Role > roles ; try { roles = com . dotmarketing . business . APILocator . getRoleAPI ( ) . loadRolesForUser ( user . getUserId ( ) ) ; } catch ( DotDataException e ) { Logger . error ( MailingListFactory . class , e . getMessage ( ) , e ) ; throw new SystemException ( e ) ; } Iterator < Role > rolesIt = roles . iterator ( ) ; boolean isMailingListEditor = false ; while ( rolesIt . hasNext ( ) ) { Role role = ( Role ) rolesIt . next ( ) ; if ( role . getName ( ) . equals ( Config . getStringProperty ( "MAILINGLISTS_EDITOR_ROLE" ) ) ) { isMailingListEditor = true ; break ; } } return isMailingListEditor ; } \n', 0.408467451036566)

('void checkMutableComboBoxModel ( ) { if ( ! ( dataModel instanceof MutableComboBoxModel ) ) throw new RuntimeException ( "Cannot-use-this-method-with-a-non-Mutable-data-model." ) ; } \n', 0.40172553628163654)

('private void checkBoxPropStaticActionPerformed ( java . awt . event . ActionEvent evt ) { config . writeStaticProps = checkBoxPropStatic . isSelected ( ) ; } \n', 0.40156350237396055)

('public boolean isCheckBoxChecked ( int index ) { return checker . isButtonChecked ( CheckBox . class , index ) ; } \n', 0.40116223313751387)

('private void checkValid ( ) { btnOk . setEnabled ( true ) ; } \n', 0.39613515812512906)

('private static boolean isEditorExist ( Class type ) { for ( int i = 0 ; i < 10 ; i ++ ) { System . gc ( ) ; if ( null == PropertyEditorManager . findEditor ( type ) ) { return false ; } } return true ; } \n', 0.39396564469305656)

('public boolean isCheckBoxChecked ( String text ) { return checker . isButtonChecked ( CheckBox . class , text ) ; } \n', 0.38915318195231596)

('private boolean isClickValid ( float x , float y ) { if ( ! isActive ( ) && ! this . isVisible ) return false ; float currentAngle = MixUtils . getAngle ( cMarker . x , cMarker . y , signMarker . x , signMarker . y ) ; pPt . x = x - signMarker . x ; pPt . y = y - signMarker . y ; pPt . rotate ( ( float ) Math . toRadians ( - ( currentAngle + 90 ) ) ) ; pPt . x += txtLab . getX ( ) ; pPt . y += txtLab . getY ( ) ; float objX = txtLab . getX ( ) - txtLab . getWidth ( ) / 2 ; float objY = txtLab . getY ( ) - txtLab . getHeight ( ) / 2 ; float objW = txtLab . getWidth ( ) ; float objH = txtLab . getHeight ( ) ; if ( pPt . x > objX && pPt . x < objX + objW && pPt . y > objY && pPt . y < objY + objH ) { return true ; } else { return false ; } } \n', 0.37693747464086935)

('private void jCheckBox2ActionPerformed ( java . awt . event . ActionEvent evt ) { replay . setInfiniteReplay ( jCheckBox2 . isSelected ( ) ) ; } \n', 0.374889345561968)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 36 #################################
('public void enableLabels ( boolean enabled ) { if ( enabled != labelsEnabled_ ) { if ( enabled ) { labelContainer_ . add ( labelPanel_ ) ; } else { labelContainer_ . remove ( labelPanel_ ) ; } labelsEnabled_ = enabled ; labelContainer_ . revalidate ( ) ; } } \n', 0.42460438142405904)

('protected void setLabelToolTipText ( String text ) { toolTipText = text ; if ( label != null && ! label . isDisposed ( ) ) { label . setToolTipText ( text ) ; } } \n', 0.42341937477339353)

('public void setToolTipText ( String toolTipText ) { label . setToolTipText ( toolTipText ) ; } \n', 0.4193378266101994)

('public void setToolTipText ( String text ) { super . setToolTipText ( text ) ; label . setToolTipText ( text ) ; } \n', 0.4193378266101994)

('public void setToolTipText ( String text ) { super . setToolTipText ( text ) ; Iterator < RowPane > i = rows . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( RowPane ) i . next ( ) ) . setToolTipText ( text ) ; } } \n', 0.41792700874953337)

('public void setCaptionText ( String text ) { m_label . setCaption ( text ) ; } \n', 0.4163045938561156)

('private Label boldedLabel ( String text ) { Label label = new Label ( text ) ; label . getElement ( ) . getStyle ( ) . setProperty ( "fontWeight" , "bold" ) ; return label ; } \n', 0.4160570118654233)

('protected void replaceUIText ( Composite parent , String search , String replace ) { if ( parent == null ) { return ; } if ( parent . getChildren ( ) == null || parent . getChildren ( ) . length == 0 ) { return ; } for ( Control child : parent . getChildren ( ) ) { if ( child instanceof Label ) { Label label = ( Label ) child ; if ( label . getText ( ) != null ) { label . setText ( label . getText ( ) . replaceAll ( search , replace ) ) ; } } else if ( child instanceof Text ) { Text text = ( Text ) child ; if ( text . getText ( ) != null ) { text . setText ( text . getText ( ) . replaceAll ( search , replace ) ) ; } } else if ( child instanceof Composite ) { replaceUIText ( ( Composite ) child , search , replace ) ; } } } \n', 0.4160387814742611)

('public void setToolTipText ( String string ) { hintLabel . setToolTipText ( string ) ; } \n', 0.4128530471424494)

('public void setToolTipText ( String string ) { checkWidget ( ) ; toolTipText = string ; int hwndHeaderToolTip = parent . headerToolTipHandle ; if ( hwndHeaderToolTip == 0 ) { parent . createHeaderToolTips ( ) ; parent . updateHeaderToolTips ( ) ; } } \n', 0.41204957838590056)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 37 #################################
('public static int convertToNumber ( String str , int fallback ) { try { if ( StringUtils . isEmpty ( str ) ) { return fallback ; } return Integer . valueOf ( str . trim ( ) ) ; } catch ( NumberFormatException ex ) { LOGGER . error ( "Could-not-parse-string-{}-as-number" , str , ex ) ; return fallback ; } } \n', 0.4172186775606706)

('public static Integer stringToInteger ( final String str ) { if ( ( str != null ) && ( str . length ( ) > 0 ) ) { return Integer . valueOf ( str ) ; } else { return null ; } } \n', 0.41653208882595993)

('public static Integer stringToInteger ( String s ) { if ( s == null || s . length ( ) == 0 ) { return null ; } return Integer . parseInt ( s ) ; } \n', 0.41387013054202626)

('public static Integer toInteger ( String string ) { if ( ( string == null ) || ( string . length ( ) == 0 ) ) { return null ; } return Integer . parseInt ( string ) ; } \n', 0.41311028088998364)

("public static String toRealNumberString ( String a ) { char [ ] aarray = a . toCharArray ( ) ; while ( aarray [ 0 ] == '0' && aarray . length > 1 ) { if ( aarray [ 1 ] == '.' ) { break ; } aarray = Arrays . copyOfRange ( aarray , 1 , aarray . length ) ; toRealNumberString ( String . valueOf ( aarray ) ) ; } return String . valueOf ( aarray ) ; } \n", 0.4128151261471623)

('static public Integer StringToInteger ( String ss , Integer value ) { Integer returnValue ; returnValue = value ; ss = ss . trim ( ) ; if ( 0 != ss . length ( ) ) { returnValue = Integer . valueOf ( ss ) ; } return returnValue ; } \n', 0.41204027079121286)

('public static Integer string2Integer ( String str ) { if ( str == null || str . length ( ) == 0 ) { return null ; } try { return Integer . parseInt ( str ) ; } catch ( Exception e ) { return null ; } } \n', 0.4107135919344508)

("private Number convertStringToNumber ( String strValue ) { Number value = null ; try { if ( StringUtils . hasText ( strValue ) ) { if ( strValue . indexOf ( '.' ) > 0 ) { value = Double . valueOf ( strValue ) ; } else { value = Long . valueOf ( strValue ) ; } } } catch ( NumberFormatException ne ) { value = null ; } return value ; } \n", 0.41008809922380574)

('public static Integer stringToInteger ( String in ) { if ( in == null ) { return null ; } in = in . trim ( ) ; if ( in . length ( ) == 0 ) { return null ; } try { return Integer . parseInt ( in ) ; } catch ( NumberFormatException e ) { LOG . warn ( "stringToInteger-fail,string=" + in , e ) ; return null ; } } \n', 0.4100869201188477)

('public static Integer safeStringToInteger ( String inString ) { Integer wkIntVal = Integer . valueOf ( 0 ) ; if ( null == inString ) return wkIntVal ; inString = inString . trim ( ) ; if ( 0 == inString . length ( ) ) return wkIntVal ; try { wkIntVal = Integer . valueOf ( inString ) ; } catch ( NumberFormatException nfe ) { } return wkIntVal ; } \n', 0.4088155151100916)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 38 #################################
('public static void saveLongList ( String file , Collection < Long > c ) throws FileNotFoundException , IOException { saveLongList ( file , c , false ) ; } \n', 0.45281271243278)

('public static void saveList ( File file , Collection < String > set ) { BufferedWriter writer = null ; try { writer = new BufferedWriter ( new FileWriter ( file ) ) ; for ( String l : set ) { writer . write ( l ) ; if ( ! l . endsWith ( "-" ) ) writer . write ( "-" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } } } } \n', 0.450382957631143)

('public MemberManager saveList ( String filePath ) { try { File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } BufferedWriter bw = new BufferedWriter ( new FileWriter ( file . getAbsoluteFile ( ) ) ) ; bw . write ( memberList . toString ( ) ) ; bw . close ( ) ; } catch ( IOException e ) { System . err . println ( e . getMessage ( ) ) ; } return this ; } \n', 0.4481751392995783)

('protected void saveLists ( ) { File saveFile = MainScreen . filepath ; try { FileWriter fos = new FileWriter ( saveFile ) ; System . out . println ( this . toJson ( ) ) ; fos . write ( this . toJson ( ) ) ; fos . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.44541805498885123)

('public void saveList ( SubscriptionRecordList list , String file ) { LOG . info ( "Saving-" + list . size ( ) + "-items(s)" ) ; LOG . info ( "Filename=" + file ) ; FileOutputStream fos ; try { fos = new FileOutputStream ( file ) ; try { XMLEncoder xenc = new XMLEncoder ( fos ) ; try { xenc . writeObject ( list ) ; xenc . flush ( ) ; } finally { xenc . close ( ) ; } } finally { try { fos . close ( ) ; } catch ( IOException ex ) { LOG . info ( "Could-not-close-" + file + ":-" + ex . getMessage ( ) ) ; } } } catch ( FileNotFoundException ex ) { LOG . error ( "Error-accessing-storage-" + file + ":-" + ex . getMessage ( ) ) ; } LOG . info ( "Save-complete" ) ; } \n', 0.4441615534669504)

('public static void saveAutorunList ( String pathoffiletosave , String texttosave ) { try { File ff = new File ( pathoffiletosave ) ; ff . createNewFile ( ) ; FileWriter ffw = new FileWriter ( ff ) ; ffw . write ( texttosave ) ; ffw . close ( ) ; } catch ( Exception e ) { System . out . println ( "Unable-to-save-file" ) ; } } \n', 0.4415565169590996)

('public void saveMsgList ( String filename ) { try { BufferedWriter bw = new BufferedWriter ( new FileWriter ( filename ) ) ; bw . write ( this . toString ( ) ) ; bw . write ( "-" ) ; bw . close ( ) ; } catch ( FileNotFoundException e ) { System . out . println ( "MsgList--->-saveMsgList--->-File:-" + filename + "-not-found!" ) ; } catch ( IOException e ) { System . out . println ( "MsgList--->-saveMsgList-" + e ) ; } } \n', 0.4408056742015176)

('@ Deprecated public static void saveSessionListToFile ( Context context , String fileName , List < Session > sessionList ) { if ( sessionList . size ( ) >= 1 ) { Writer writer = null ; try { OutputStream out = context . openFileOutput ( fileName , Context . MODE_PRIVATE ) ; writer = new OutputStreamWriter ( out ) ; gson . toJson ( sessionList , SESSION_LIST_TYPE , writer ) ; } catch ( FileNotFoundException e ) { } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } } \n', 0.4395836103234189)

('void saveListToFile ( JList list , File file ) { try { if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } final BufferedWriter bw = new BufferedWriter ( new FileWriter ( file ) ) ; final ListModel model = list . getModel ( ) ; final int size = model . getSize ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final String s = model . getElementAt ( i ) + "-" ; bw . write ( s , 0 , s . length ( ) ) ; } bw . close ( ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; } } \n', 0.4380274028738482)

('public static < E > boolean saveList ( ArrayList < E > list , File file ) { try { BufferedWriter bw = new BufferedWriter ( new FileWriter ( file ) ) ; for ( E item : list ) { bw . write ( item . toString ( ) ) ; bw . newLine ( ) ; } bw . flush ( ) ; bw . close ( ) ; return true ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return false ; } \n', 0.43789871834155125)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 39 #################################
('private void dumpAndDeleteCapturedFile ( File source , String sectionHeader ) { byte buffer [ ] = new byte [ 2048 ] ; int status = - 1 ; boolean error = false ; try { FileInputStream sourceStream = new FileInputStream ( source ) ; System . err . println ( sectionHeader ) ; System . err . println ( "<<<<<<<<<<<<<<<<<<<" ) ; do { try { status = sourceStream . read ( buffer ) ; } catch ( IOException ex ) { error = true ; System . err . print ( "Error-reading-file:-" + ex . getMessage ( ) ) ; } if ( status > 0 ) System . err . write ( buffer , 0 , status ) ; } while ( status > 0 ) ; System . err . println ( ">>>>>>>>>>>>>>>>>>>" ) ; System . err . println ( ) ; try { sourceStream . close ( ) ; } catch ( IOException ex ) { error = true ; System . err . print ( "Couldn\'t-close-file:-" + ex . getMessage ( ) ) ; } } catch ( FileNotFoundException ex ) { error = true ; System . err . print ( "Error-opening-file:-" + ex . getMessage ( ) ) ; } if ( ! error && ! keepTestOutput ) { source . delete ( ) ; } } \n', 0.39972520265502876)

('public boolean excludeFileFromCompression ( String path ) { boolean exclude = false ; for ( Pattern p : this . compressionExclusionPatterns ) { Matcher m = p . matcher ( path ) ; if ( m . matches ( ) ) { exclude = true ; break ; } } return exclude ; } \n', 0.3834791815514496)

('private static void generateHeaderFile ( String headerFile , HashMap < String , String > map , PrintWriter os ) throws IOException { String symbolName = "_" + headerFile . toUpperCase ( ) . replace ( \'.\' , \'_\' ) + "_" ; os . println ( "#ifndef-" + symbolName ) ; os . println ( "#define-" + symbolName ) ; for ( final String arrayName : map . keySet ( ) ) { String inputFileName = map . get ( arrayName ) ; File inputFile = new File ( inputFileName ) ; long length = inputFile . length ( ) ; os . printf ( "extern-const-signed-char-%s[%d];-" , arrayName , length ) ; } os . println ( "#endif-/*-" + symbolName + "-*/" ) ; } \n', 0.3741603447743363)

('private static Data cloneDataWithCleanedLabelForConversion ( Data originalData ) { Data clonedData = new BasicData ( originalData . getData ( ) , originalData . getFormat ( ) ) ; Dictionary < String , Object > originalMetadata = originalData . getMetadata ( ) ; Dictionary < String , Object > clonedMetadata = clonedData . getMetadata ( ) ; for ( Enumeration < String > keys = originalMetadata . keys ( ) ; keys . hasMoreElements ( ) ; ) { String key = keys . nextElement ( ) ; if ( DataProperty . LABEL . equals ( key ) ) { clonedMetadata . put ( key , FileUtilities . replaceInvalidFilenameCharacters ( ( String ) originalMetadata . get ( key ) ) ) ; } else { clonedMetadata . put ( key , originalMetadata . get ( key ) ) ; } } return clonedData ; } \n', 0.36156541121838615)

('private byte [ ] generateARCFileMetaData ( String date ) throws IOException { String metadataHeaderLinesTwoAndThree = getMetadataHeaderLinesTwoAndThree ( "1-" + "0" ) ; int recordLength = metadataHeaderLinesTwoAndThree . getBytes ( DEFAULT_ENCODING ) . length ; String metadataHeaderStr = ARC_MAGIC_NUMBER + getARCFilename ( ) + "-0.0.0.0-" + date + "-text/plain-" + recordLength + metadataHeaderLinesTwoAndThree ; ByteArrayOutputStream metabaos = new ByteArrayOutputStream ( recordLength ) ; metabaos . write ( metadataHeaderStr . getBytes ( DEFAULT_ENCODING ) ) ; metabaos . write ( LINE_SEPARATOR ) ; byte [ ] bytes = metabaos . toByteArray ( ) ; byte [ ] gzippedMetaData = gzip ( bytes ) ; if ( gzippedMetaData [ 3 ] != 0 ) { throw new IOException ( "The-GZIP-FLG-header-is-unexpectedly-" + "-non-zero.-Need-to-add-smarter-code-that-can-deal-" + "-when-already-extant-extra-GZIP-header-fields." ) ; } gzippedMetaData [ 3 ] = 4 ; gzippedMetaData [ 9 ] = 3 ; byte [ ] assemblyBuffer = new byte [ gzippedMetaData . length + ARC_GZIP_EXTRA_FIELD . length ] ; System . arraycopy ( gzippedMetaData , 0 , assemblyBuffer , 0 , 10 ) ; System . arraycopy ( ARC_GZIP_EXTRA_FIELD , 0 , assemblyBuffer , 10 , ARC_GZIP_EXTRA_FIELD . length ) ; System . arraycopy ( gzippedMetaData , 10 , assemblyBuffer , 10 + ARC_GZIP_EXTRA_FIELD . length , gzippedMetaData . length - 10 ) ; bytes = assemblyBuffer ; return bytes ; } \n', 0.3586965646409478)

('public void writeContactsFileHeaderLine ( File newContactsFile ) throws IOException { BufferedWriter newContactsBW = null ; try { newContactsBW = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( newContactsFile , true ) , "UTF8" ) ) ; List < String > contactColumnNames = new LinkedList < String > ( ) ; contactColumnNames . add ( "role" ) ; contactColumnNames . add ( "name" ) ; contactColumnNames . add ( "telephone" ) ; contactColumnNames . add ( "address" ) ; contactColumnNames . add ( "email" ) ; fileUtils . writeValuesToFile ( newContactsBW , contactColumnNames ) ; newContactsBW . close ( ) ; } catch ( Exception e ) { log . error ( "An-error-occurred-writing-contact-file:-" + e . getMessage ( ) , e ) ; } finally { if ( newContactsBW != null ) { try { newContactsBW . close ( ) ; } catch ( Exception e ) { log . error ( "An-error-occurred-closing-output-stream-on-contact-file:-" + e . getMessage ( ) , e ) ; } } } } \n', 0.3581788275637395)

('public static void outputCSVLine ( final Writer writer , final String [ ] values ) throws IOException { for ( int i = 0 ; i < values . length ; ) { final String value = values [ i ] ; if ( value != null ) { if ( value == Config . ColumnValueTrue || value == Config . ColumnValueFalse ) { writer . write ( value ) ; } else { writer . write ( \'"\' ) ; outputValueEscapeQuotes ( writer , value ) ; writer . write ( \'"\' ) ; } } if ( ++ i != values . length ) writer . write ( \',\' ) ; } writer . write ( CSVNewLine ) ; } \n', 0.35682311905907577)

('public String [ ] fromCSVLine ( String source , int size ) { ArrayList < String > tmpArray = fromCSVLinetoArray ( source ) ; if ( size < tmpArray . size ( ) ) { size = tmpArray . size ( ) ; } String [ ] rtnArray = new String [ size ] ; tmpArray . toArray ( rtnArray ) ; return rtnArray ; } \n', 0.3557190862313748)

('public static String buildCsvLine ( String ... values ) { StringBuilder line = new StringBuilder ( values . length * 10 ) ; for ( String value : values ) { line . append ( "," ) . append ( """ ) . append ( value . replaceAll ( """ , """" ) ) . append ( """ ) ; } return line . substring ( 1 ) . toString ( ) ; } \n', 0.35435259466709346)

('public static String generateHeaderLine ( String fieldSeparator , Locale locale ) { final List < String > headers = new LinkedList < String > ( ) ; final Messages i18nMessages = new Messages ( locale ) ; headers . add ( i18nMessages . getMessage ( "log.header.date" ) ) ; headers . add ( i18nMessages . getMessage ( "log.header.h1.meanRespTime" ) ) ; headers . add ( i18nMessages . getMessage ( "log.header.inspire.meanRespTime" ) ) ; headers . add ( i18nMessages . getMessage ( "log.header.h1.availability" ) ) ; headers . add ( i18nMessages . getMessage ( "log.header.inspire.availability" ) ) ; headers . add ( i18nMessages . getMessage ( "log.header.h1.nbBizErrors" ) ) ; headers . add ( i18nMessages . getMessage ( "log.header.inspire.nbBizErrors" ) ) ; headers . add ( i18nMessages . getMessage ( "log.header.h1.nbConnErrors" ) ) ; headers . add ( i18nMessages . getMessage ( "log.header.inspire.nbConnErrors" ) ) ; return StringUtils . join ( headers . iterator ( ) , fieldSeparator ) ; } \n', 0.3524037013117239)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 40 #################################
('private String replaceIllegalFileNameCharacters ( final String pFilename , final char [ ] pIllegalChars , final char pReplacementChar ) { String returnString = pFilename ; for ( char c : pIllegalChars ) { returnString = returnString . replace ( c , pReplacementChar ) ; } return returnString ; } \n', 0.43883244836736746)

('public static boolean replaceInFile ( File file , String oldS , String newS , String encoding ) { try { String s = FileUtils . readFileToString ( file ) ; if ( s . indexOf ( oldS ) != - 1 ) { s = s . replaceAll ( oldS , newS ) ; Writer bw = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( file ) , encoding ) ) ; try { bw . write ( s ) ; bw . flush ( ) ; } finally { bw . close ( ) ; } return true ; } } catch ( IOException e ) { Log . error ( e ) ; } return false ; } \n', 0.4338837138461149)

('public static String replaceIllegalFilenameCharactersOld ( String filename , char replacementCharacter ) { Matcher matcher = ILLEGAL_FILENAME_CHARS_PATTERN_OLD . matcher ( filename ) ; String result = matcher . replaceAll ( replacementCharacter + "" ) ; return result ; } \n', 0.4325608670913391)

('public static String replaceIllegalFilenameCharacters ( String filename ) { Matcher matcher = ILLEGAL_FILENAME_CHARS_PATTERN . matcher ( filename ) ; String result = matcher . replaceAll ( DEFAULT_REPLACEMENT_CHAR ) ; return result ; } \n', 0.4302317818620611)

('public static String replaceLastExtension ( String filename , String newExt ) { if ( ( filename == null ) || ( newExt == null ) ) { return null ; } if ( filename . isEmpty ( ) ) { return null ; } String [ ] parts = filename . split ( "|." ) ; String newFilename = parts [ 0 ] ; for ( int i = 1 ; i < parts . length - 1 ; i ++ ) { newFilename = newFilename + "." + parts [ i ] ; } return newFilename + "." + newExt ; } \n', 0.4227676880701275)

('public static String sanitizeForFileName ( final String toSanitize ) { return ILLEGAL_FILE_NAME_CHARS . matcher ( toSanitize ) . replaceAll ( "_" ) ; } \n', 0.42210692723986526)

('public static Map . Entry < Integer , String > replaceAllWeirdCharsFromFile ( String f ) throws IOException { Charset charset = Charset . forName ( "UTF-8" ) ; int weirdCharsCount = 0 ; Set < String > weirdCharsList = new HashSet < > ( ) ; String text = new String ( Files . readAllBytes ( Paths . get ( f ) ) , charset ) ; char [ ] textArray = text . toCharArray ( ) ; for ( int i = 0 ; i < textArray . length ; i ++ ) { if ( text . codePointAt ( i ) > 500 && i != 0 ) { textArray [ i ] = \'-\' ; weirdCharsList . add ( String . valueOf ( text . charAt ( i ) ) ) ; System . out . println ( i + "-" + text . charAt ( i ) + "-" + text . codePointAt ( i ) ) ; weirdCharsCount ++ ; } } text = String . valueOf ( textArray ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( Paths . get ( f . substring ( 0 , f . length ( ) - 4 ) + "_clean.srt" ) , charset ) ) { writer . write ( text ) ; writer . flush ( ) ; } catch ( EOFException e ) { Log . appendToInfoArea ( e . toString ( ) ) ; e . printStackTrace ( ) ; } return new AbstractMap . SimpleEntry < > ( weirdCharsCount , String . join ( ",-" , weirdCharsList ) ) ; } \n', 0.41923295526177545)

('public static String replaceNonFileNameChars ( final String value , final String replaceBy ) { return PATTERN_NON_FILE_NAME . matcher ( value ) . replaceAll ( replaceBy ) ; } \n', 0.41892895350755216)

('public static File replaceExtension ( File file , String extension ) { String fileName = file . getPath ( ) ; int pos = fileName . lastIndexOf ( \'.\' ) ; if ( pos != - 1 ) { if ( Validator . isNotNull ( extension ) && ! extension . startsWith ( "." ) ) { extension = "." + extension ; } fileName = fileName . substring ( 0 , pos ) + extension ; } return new File ( fileName ) ; } \n', 0.4187003463882669)

('private static String replaceIllegalCharactersInFileName ( String fileName ) { return fileName . replaceAll ( "[^a-zA-Z0-9.-]" , "_" ) ; } \n', 0.41783774425731385)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 41 #################################
('private void plotText ( String t , int l , int x , int y ) { if ( t != null && l < 20 ) { img . setColor ( Color . lightGray ) ; img . setFont ( fontBig ) ; img . drawString ( t , x , y ) ; } } \n', 0.298223236274226)

('private void plotCounters ( String p , String n ) { img . setColor ( Color . lightGray ) ; img . setFont ( fontSmall ) ; img . drawString ( p , width - 55 , 13 ) ; img . drawString ( n , width - 55 , height - 3 ) ; } \n', 0.2946938257749778)

('@ Override public void updateDrawState ( TextPaint ds ) { int [ ] states = ds . drawableState ; if ( states != null ) { int count = states . length ; for ( int i = 0 ; i < count ; i ++ ) { switch ( states [ i ] ) { case R . attr . state_pressed : case R . attr . state_selected : case R . attr . state_focused : return ; } } } int color = ds . getColor ( ) ; color = Color . argb ( mAlpha , Color . red ( color ) , Color . green ( color ) , Color . blue ( color ) ) ; ds . setColor ( color ) ; } \n', 0.2934248291350664)

('protected void save ( Graphics g ) { savedColor = g . getColor ( ) ; } \n', 0.2931284965197855)

('public void plot ( double x , double y , double alpha ) { Color col = g . getColor ( ) ; g . setColor ( new Color ( col . getRed ( ) , col . getGreen ( ) , col . getBlue ( ) , ( ( int ) ( ( alpha % 1 ) * 255 ) ) ) ) ; g . drawLine ( ( int ) x , ( int ) y , ( int ) x , ( int ) y ) ; } \n', 0.29197504456403756)

('public void write ( StringBuilder sb ) { sb . append ( "-getComponentColor(c,-"" ) . append ( propertyName ) . append ( "",-" ) . append ( defaultColorVariableName ) . append ( ",-" ) . append ( saturationOffset ) . append ( "f,-" ) . append ( brightnessOffset ) . append ( "f,-" ) . append ( alphaOffset ) ; } \n', 0.2911330483568594)

('public void drawBitmap ( int [ ] colors , int offset , int stride , float x , float y , int width , int height , boolean hasAlpha , Paint paint ) { if ( width < 0 ) { throw new IllegalArgumentException ( "width-must-be->=-0" ) ; } if ( height < 0 ) { throw new IllegalArgumentException ( "height-must-be->=-0" ) ; } if ( Math . abs ( stride ) < width ) { throw new IllegalArgumentException ( "abs(stride)-must-be->=-width" ) ; } int lastScanline = offset + ( height - 1 ) * stride ; int length = colors . length ; if ( offset < 0 || ( offset + width > length ) || lastScanline < 0 || ( lastScanline + width > length ) ) { throw new ArrayIndexOutOfBoundsException ( ) ; } if ( width == 0 || height == 0 ) { return ; } native_drawBitmap ( mNativeCanvas , colors , offset , stride , x , y , width , height , hasAlpha , paint != null ? paint . mNativePaint : 0 ) ; } \n', 0.29004385986759074)

('@ Deprecated public void drawBitmap ( @ NonNull int [ ] colors , int offset , int stride , float x , float y , int width , int height , boolean hasAlpha , @ Nullable Paint paint ) { if ( width < 0 ) { throw new IllegalArgumentException ( "width-must-be->=-0" ) ; } if ( height < 0 ) { throw new IllegalArgumentException ( "height-must-be->=-0" ) ; } if ( Math . abs ( stride ) < width ) { throw new IllegalArgumentException ( "abs(stride)-must-be->=-width" ) ; } int lastScanline = offset + ( height - 1 ) * stride ; int length = colors . length ; if ( offset < 0 || ( offset + width > length ) || lastScanline < 0 || ( lastScanline + width > length ) ) { throw new ArrayIndexOutOfBoundsException ( ) ; } if ( width == 0 || height == 0 ) { return ; } native_drawBitmap ( mNativeCanvasWrapper , colors , offset , stride , x , y , width , height , hasAlpha , paint != null ? paint . mNativePaint : 0 ) ; } \n', 0.2896095657888698)

('void save ( File file ) throws IOException { HieroSettings settings = new HieroSettings ( ) ; settings . setFontSize ( ( ( Integer ) fontSizeSpinner . getValue ( ) ) . intValue ( ) ) ; settings . setBold ( boldCheckBox . isSelected ( ) ) ; settings . setItalic ( italicCheckBox . isSelected ( ) ) ; settings . setPaddingTop ( ( ( Integer ) padTopSpinner . getValue ( ) ) . intValue ( ) ) ; settings . setPaddingRight ( ( ( Integer ) padRightSpinner . getValue ( ) ) . intValue ( ) ) ; settings . setPaddingBottom ( ( ( Integer ) padBottomSpinner . getValue ( ) ) . intValue ( ) ) ; settings . setPaddingLeft ( ( ( Integer ) padLeftSpinner . getValue ( ) ) . intValue ( ) ) ; settings . setPaddingAdvanceX ( ( ( Integer ) padAdvanceXSpinner . getValue ( ) ) . intValue ( ) ) ; settings . setPaddingAdvanceY ( ( ( Integer ) padAdvanceYSpinner . getValue ( ) ) . intValue ( ) ) ; settings . setGlyphPageWidth ( ( ( Integer ) glyphPageWidthCombo . getSelectedItem ( ) ) . intValue ( ) ) ; settings . setGlyphPageHeight ( ( ( Integer ) glyphPageHeightCombo . getSelectedItem ( ) ) . intValue ( ) ) ; for ( Iterator iter = effectPanels . iterator ( ) ; iter . hasNext ( ) ; ) { EffectPanel panel = ( EffectPanel ) iter . next ( ) ; settings . getEffects ( ) . add ( panel . getEffect ( ) ) ; } settings . save ( file ) ; } \n', 0.2818172146709622)

('public int saveLayerAlpha ( float left , float top , float right , float bottom , int alpha , @ Saveflags int saveFlags ) { alpha = Math . min ( 255 , Math . max ( 0 , alpha ) ) ; return native_saveLayerAlpha ( mNativeCanvasWrapper , left , top , right , bottom , alpha , saveFlags ) ; } \n', 0.2809368417413722)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 42 #################################
('private static List extractZipEntries ( final ZipFile zipFile ) { final List entryList = new ArrayList ( 100 ) ; final Enumeration enumeration = zipFile . entries ( ) ; while ( enumeration . hasMoreElements ( ) ) { entryList . add ( enumeration . nextElement ( ) ) ; } return entryList ; } \n', 0.42679334068071345)

('protected void extractPluginFiles ( ) throws Exception { if ( isExtractNeeded ( ) ) { if ( extractionDirectory . exists ( ) ) { FileUtils . deleteDirectory ( extractionDirectory ) ; } if ( ! extractionDirectory . mkdir ( ) ) { throw new WorkflowRuntimeException ( "Could-not-create-the-extraction-directory-for-the-plugin:-" + extractionDirectory . getAbsolutePath ( ) ) ; } ZipFile zipFile = new ZipFile ( pluginZipFile , ZipFile . OPEN_READ ) ; for ( Enumeration entries = zipFile . entries ( ) ; entries . hasMoreElements ( ) ; ) { ZipEntry entry = ( ZipEntry ) entries . nextElement ( ) ; File entryFile = new File ( extractionDirectory + java . io . File . separator + entry . getName ( ) ) ; if ( entry . isDirectory ( ) ) { if ( ! entryFile . mkdir ( ) ) { throw new WorkflowRuntimeException ( "Failed-to-create-directory:-" + entryFile . getAbsolutePath ( ) ) ; } continue ; } InputStream is = null ; OutputStream os = null ; try { is = new BufferedInputStream ( zipFile . getInputStream ( entry ) ) ; os = new BufferedOutputStream ( new FileOutputStream ( entryFile ) ) ; while ( is . available ( ) > 0 ) { os . write ( is . read ( ) ) ; } } finally { if ( os != null ) { os . close ( ) ; } if ( is != null ) { is . close ( ) ; } } } } } \n', 0.4262977380096596)

('public static final void extractJAR ( File zFile , String extractDir ) throws IOException { File extractFile = new File ( extractDir ) ; if ( ! extractFile . exists ( ) ) { extractFile . mkdirs ( ) ; } if ( ! zFile . exists ( ) ) { throw new IOException ( zFile + "-does-not-exist." ) ; } ZipFile zipFile = new ZipFile ( zFile ) ; try { Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; byte [ ] buf = new byte [ BUFFER_LENGTH ] ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; String entryName = entry . getName ( ) ; if ( entryName . startsWith ( "META-INF" ) ) { continue ; } File entryFile = new File ( extractDir , entryName ) ; if ( entry . isDirectory ( ) ) { entryFile . mkdirs ( ) ; continue ; } entryFile . getParentFile ( ) . mkdirs ( ) ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( entryFile ) ; int len ; InputStream is = zipFile . getInputStream ( entry ) ; while ( ( len = is . read ( buf , 0 , BUFFER_LENGTH ) ) > - 1 ) { fos . write ( buf , 0 , len ) ; } } finally { fos . close ( ) ; } } } finally { zipFile . close ( ) ; } } \n', 0.41844248262249006)

('static public void extractJarFile ( File in , File out ) throws IOException { if ( ! in . isFile ( ) ) { throw new IllegalArgumentException ( "The-file-"" + in + ""-is-a-directory-or-does-not-exit!" ) ; } if ( ! out . isDirectory ( ) ) { throw new IllegalArgumentException ( "The-file-"" + in + ""-is-no-directory-or-does-not-exit!" ) ; } java . util . jar . JarFile jar = new java . util . jar . JarFile ( in ) ; java . util . Enumeration entries = jar . entries ( ) ; while ( entries . hasMoreElements ( ) ) { java . util . jar . JarEntry file = ( java . util . jar . JarEntry ) entries . nextElement ( ) ; java . io . File f = new java . io . File ( out + java . io . File . separator + file . getName ( ) ) ; if ( file . isDirectory ( ) ) { f . mkdir ( ) ; continue ; } BufferedInputStream is = new BufferedInputStream ( jar . getInputStream ( file ) ) ; java . io . FileOutputStream fos = new java . io . FileOutputStream ( f ) ; byte [ ] buffer = new byte [ 1024 ] ; while ( true ) { int count = is . read ( buffer ) ; if ( count == - 1 ) { break ; } fos . write ( buffer , 0 , count ) ; } fos . close ( ) ; is . close ( ) ; } } \n', 0.41824193703347173)

('public final void extractFolder ( final String zipFile ) throws ZipException , IOException { int BUFFER = 2048 ; File file = new File ( zipFile ) ; ZipFile zip = new ZipFile ( file ) ; String newPath = zipFile . substring ( 0 , zipFile . length ( ) - 4 ) ; new File ( newPath ) . mkdir ( ) ; Enumeration zipFileEntries = zip . entries ( ) ; while ( zipFileEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipFileEntries . nextElement ( ) ; String currentEntry = entry . getName ( ) ; File destFile = new File ( newPath , currentEntry ) ; File destinationParent = destFile . getParentFile ( ) ; destinationParent . mkdirs ( ) ; if ( ! entry . isDirectory ( ) ) { BufferedInputStream is = new BufferedInputStream ( zip . getInputStream ( entry ) ) ; int currentByte ; byte data [ ] = new byte [ BUFFER ] ; FileOutputStream fos = new FileOutputStream ( destFile ) ; BufferedOutputStream dest = new BufferedOutputStream ( fos , BUFFER ) ; while ( ( currentByte = is . read ( data , 0 , BUFFER ) ) != - 1 ) { dest . write ( data , 0 , currentByte ) ; } dest . flush ( ) ; dest . close ( ) ; is . close ( ) ; } if ( currentEntry . endsWith ( ".zip" ) ) { extractFolder ( destFile . getAbsolutePath ( ) ) ; } } } \n', 0.4166917805259942)

('public static String extractZip ( File zipArchive , String outputDir ) { try { String rootDirectoryPath = null ; ZipFile zipFile = new ZipFile ( zipArchive ) ; Enumeration < ? > enu = zipFile . entries ( ) ; while ( enu . hasMoreElements ( ) ) { ZipEntry zipEntry = ( ZipEntry ) enu . nextElement ( ) ; String name = zipEntry . getName ( ) ; long size = zipEntry . getSize ( ) ; long compressedSize = zipEntry . getCompressedSize ( ) ; System . out . printf ( "name:-%-20s-|-size:-%6d-|-compressed-size:-%6d-" , name . substring ( 0 , name . indexOf ( \'/\' ) ) , size , compressedSize ) ; if ( rootDirectoryPath == null ) { rootDirectoryPath = name . substring ( 0 , name . indexOf ( \'/\' ) ) ; } File file = new File ( outputDir , name ) ; if ( name . endsWith ( "/" ) ) { file . mkdirs ( ) ; continue ; } File parent = file . getParentFile ( ) ; if ( parent != null ) { parent . mkdirs ( ) ; } InputStream is = zipFile . getInputStream ( zipEntry ) ; FileOutputStream fos = new FileOutputStream ( file ) ; byte [ ] bytes = new byte [ 1024 ] ; int length ; while ( ( length = is . read ( bytes ) ) >= 0 ) { fos . write ( bytes , 0 , length ) ; } is . close ( ) ; fos . close ( ) ; } zipFile . close ( ) ; return rootDirectoryPath ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } } \n', 0.4103092891729835)

('public static void extractFilesFromJar ( File archive , String suffix , File destDir ) throws MojoExecutionException { destDir . mkdirs ( ) ; if ( destDir . isDirectory ( ) ) { try { JarFile jarFile = new JarFile ( archive ) ; Enumeration < JarEntry > entries = jarFile . entries ( ) ; List < JarEntry > toBeExtracted = new ArrayList < JarEntry > ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry current = entries . nextElement ( ) ; if ( current . getName ( ) . endsWith ( suffix ) ) { toBeExtracted . add ( current ) ; } } for ( JarEntry entry : toBeExtracted ) { File dest = new File ( destDir , new File ( entry . getName ( ) ) . getName ( ) ) ; OutputStream outputStream = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; InputStream inputStream = new BufferedInputStream ( jarFile . getInputStream ( entry ) ) ; byte [ ] buffer = new byte [ 4096 ] ; while ( true ) { int nBytes = inputStream . read ( buffer ) ; if ( nBytes <= 0 ) { break ; } outputStream . write ( buffer , 0 , nBytes ) ; } outputStream . flush ( ) ; outputStream . close ( ) ; inputStream . close ( ) ; } } catch ( IOException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } } else { throw new MojoExecutionException ( "directory-" + destDir + "-cannot-be-created" ) ; } } \n', 0.40928119990740347)

('public static void extractAll ( ZipFile zip , File dest , boolean overwrite ) throws IOException { if ( dest . isFile ( ) ) { if ( overwrite ) { if ( ! dest . delete ( ) ) { throw new IOException ( "Failed-to-delete-existing-file-at-" + dest . getPath ( ) ) ; } } else { throw new IOException ( "Failed-to-extract-to-" + dest . getPath ( ) + "---already-exists-as-regular-file" ) ; } } Enumeration < ? extends ZipEntry > entries = zip . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; try { extract ( zip , entry , new File ( dest , entry . getName ( ) ) , overwrite ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; System . err . println ( "Failed-to-extract-" + entry . getName ( ) ) ; } } } \n', 0.4079068162259879)

('private static File extractZipFile ( File sourceFile ) throws IOException { File tempDir = File . createTempFile ( "owlapi-project" , "" ) ; tempDir . mkdir ( ) ; ZipFile zipFile = new ZipFile ( sourceFile ) ; Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry zipEntry = entries . nextElement ( ) ; if ( zipEntry . isDirectory ( ) ) { File dir = new File ( tempDir , zipEntry . getName ( ) ) ; dir . mkdirs ( ) ; } else { InputStream is = zipFile . getInputStream ( zipEntry ) ; int bufferSize = 10 * 1024 * 1024 ; BufferedInputStream bis = new BufferedInputStream ( is , bufferSize ) ; File entryFile = new File ( tempDir , zipEntry . getName ( ) ) ; entryFile . getParentFile ( ) . mkdirs ( ) ; FileOutputStream fos = new FileOutputStream ( entryFile ) ; BufferedOutputStream bos = new BufferedOutputStream ( fos ) ; byte [ ] buffer = new byte [ bufferSize ] ; while ( true ) { int read = bis . read ( buffer ) ; if ( read == - 1 ) { break ; } bos . write ( buffer , 0 , read ) ; if ( read < buffer . length ) { break ; } } bis . close ( ) ; bos . close ( ) ; } } return tempDir ; } \n', 0.4071921254880825)

('public static List < File > extractFilesFromZIP ( File zipFilename , File outputDir , boolean filesWithAbsolutePath ) throws IOException { ZipInputStream zipInputStream = new ZipInputStream ( new FileInputStream ( zipFilename ) ) ; ZipEntry zipEntry = zipInputStream . getNextEntry ( ) ; if ( zipEntry == null ) { zipInputStream . close ( ) ; throw new IOException ( "No-files-inside-ZIP" ) ; } else { List < File > extractedFiles = new ArrayList < File > ( ) ; while ( zipEntry != null ) { String entryName = zipEntry . getName ( ) ; logger . debug ( "Extracting-" + entryName ) ; File newFile = new File ( outputDir , entryName ) ; if ( filesWithAbsolutePath ) { extractedFiles . add ( newFile ) ; } else { extractedFiles . add ( new File ( entryName ) ) ; } if ( zipEntry . isDirectory ( ) ) { newFile . mkdirs ( ) ; } else { if ( newFile . getParentFile ( ) != null && ( ! newFile . getParentFile ( ) . exists ( ) ) ) { newFile . getParentFile ( ) . mkdirs ( ) ; } FileOutputStream newFileOutputStream = new FileOutputStream ( newFile ) ; IOUtils . copyLarge ( zipInputStream , newFileOutputStream ) ; newFileOutputStream . close ( ) ; zipInputStream . closeEntry ( ) ; } zipEntry = zipInputStream . getNextEntry ( ) ; } zipInputStream . close ( ) ; return extractedFiles ; } } \n', 0.4071647156098561)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 43 #################################
('public static XmlRpcStruct parseFile ( BufferedReader input ) throws IOException , InvalidPostFormatException { XmlRpcStruct p = new XmlRpcStruct ( ) ; String line ; String prevKey = null ; String prevValue = null ; Pattern keyPattern ; keyPattern = Pattern . compile ( "^[|d|w_]+:" , Pattern . CASE_INSENSITIVE | Pattern . UNICODE_CASE ) ; while ( ( line = input . readLine ( ) ) != null ) { if ( ( ! "" . equals ( line ) ) && ( ! line . startsWith ( "#" ) ) ) { Matcher m = keyPattern . matcher ( line ) ; if ( m . find ( ) ) { if ( prevKey != null ) { FileParser . putVal ( p , prevKey , prevValue ) ; } String [ ] vals = line . split ( ":" , 2 ) ; prevKey = vals [ 0 ] ; prevValue = vals [ 1 ] ; } else { if ( prevValue != null ) { prevValue += line ; } else { throw new InvalidPostFormatException ( ) ; } } } } if ( prevKey != null ) FileParser . putVal ( p , prevKey , prevValue ) ; return p ; } \n', 0.4420437922399142)

('@ SuppressWarnings ( "nls" ) public static XmlRpcStruct parseFile ( BufferedReader input ) throws IOException , InvalidPostFormatException { XmlRpcStruct p = new XmlRpcStruct ( ) ; String line ; String prevKey = null ; String prevValue = null ; Pattern keyPattern ; keyPattern = Pattern . compile ( "^[|d|w_]+:" , Pattern . CASE_INSENSITIVE | Pattern . UNICODE_CASE ) ; while ( ( line = input . readLine ( ) ) != null ) { if ( ( ! "" . equals ( line ) ) && ( ! line . startsWith ( "#" ) ) ) { Matcher m = keyPattern . matcher ( line ) ; if ( m . find ( ) ) { if ( prevKey != null ) { FileParser . putVal ( p , prevKey , prevValue ) ; } String [ ] vals = line . split ( ":" , 2 ) ; prevKey = vals [ 0 ] ; prevValue = vals [ 1 ] ; } else { if ( prevValue != null ) { prevValue += line ; } else { throw new InvalidPostFormatException ( ) ; } } } } if ( prevKey != null ) FileParser . putVal ( p , prevKey , prevValue ) ; return p ; } \n', 0.4420437922399142)

('@ SuppressWarnings ( "nls" ) public static XmlRpcStruct parseFile ( final BufferedReader input ) throws IOException , InvalidPostFormatException { final XmlRpcStruct p = new XmlRpcStruct ( ) ; String line ; String prevKey = null ; String prevValue = null ; Pattern keyPattern ; keyPattern = Pattern . compile ( "^[|d|w_]+:" , Pattern . CASE_INSENSITIVE | Pattern . UNICODE_CASE ) ; while ( ( line = input . readLine ( ) ) != null ) { if ( ! "" . equals ( line ) && ! line . startsWith ( "#" ) ) { final Matcher m = keyPattern . matcher ( line ) ; if ( m . find ( ) ) { if ( prevKey != null ) { FileParser . putVal ( p , prevKey , prevValue ) ; } final String [ ] vals = line . split ( ":" , 2 ) ; prevKey = vals [ 0 ] ; prevValue = vals [ 1 ] ; } else { if ( prevValue != null ) { prevValue += line ; } else { throw new InvalidPostFormatException ( ) ; } } } } if ( prevKey != null ) { FileParser . putVal ( p , prevKey , prevValue ) ; } return p ; } \n', 0.4420437922399142)

('public static NSObject parse ( File f ) throws Exception { FileInputStream fis = new FileInputStream ( f ) ; byte [ ] magic = new byte [ 8 ] ; fis . read ( magic ) ; String magic_string = new String ( magic ) ; fis . close ( ) ; if ( magic_string . startsWith ( "bplist00" ) ) { return BinaryPropertyListParser . parse ( f ) ; } else if ( magic_string . startsWith ( "<?xml" ) ) { return XMLPropertyListParser . parse ( f ) ; } else { throw new UnsupportedOperationException ( "The-given-file-is-neither-a-binary-nor-a-XML-property-list.-ASCII-property-lists-are-not-supported." ) ; } } \n', 0.43261477619618893)

('public static Map < String , String > parsePropertyFile ( File propFile , ISdkLog log ) { FileInputStream fis = null ; BufferedReader reader = null ; try { fis = new FileInputStream ( propFile ) ; reader = new BufferedReader ( new InputStreamReader ( fis , SdkConstants . INI_CHARSET ) ) ; String line = null ; Map < String , String > map = new HashMap < String , String > ( ) ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) > 0 && line . charAt ( 0 ) != \'#\' ) { Matcher m = PATTERN_PROP . matcher ( line ) ; if ( m . matches ( ) ) { map . put ( m . group ( 1 ) , m . group ( 2 ) ) ; } else { log . warning ( "Error-parsing-\'%1$s\':-"%2$s"-is-not-a-valid-syntax" , propFile . getAbsolutePath ( ) , line ) ; return null ; } } } return map ; } catch ( FileNotFoundException e ) { } catch ( IOException e ) { log . warning ( "Error-parsing-\'%1$s\':-%2$s." , propFile . getAbsolutePath ( ) , e . getMessage ( ) ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { } } } return null ; } \n', 0.4273346356845629)

('protected Map < String , Object > parseFile ( File file ) throws IOException { if ( file == null ) { return Collections . emptyMap ( ) ; } else if ( ! file . isFile ( ) || ! file . canRead ( ) ) { throw new IOException ( String . format ( "%s-is-not-a-readable-file" , file . getAbsolutePath ( ) ) ) ; } else { try { return new Gson ( ) . fromJson ( new FileReader ( file ) , new TypeToken < Map < String , Object >> ( ) { } . getType ( ) ) ; } catch ( JsonSyntaxException e ) { throw new AmbariException ( String . format ( "Failed-to-parse-JSON-formatted-file:-%s" , file . getAbsolutePath ( ) ) , e ) ; } } } \n', 0.4270172731475944)

('public static < T > T parseJson ( File jsonFile , Class < T > klass ) { try { FileReader reader = new FileReader ( jsonFile ) ; BufferedReader buf = new BufferedReader ( reader ) ; StringBuilder json = new StringBuilder ( ) ; String line ; while ( ( line = buf . readLine ( ) ) != null ) { json . append ( line ) ; } return new Gson ( ) . fromJson ( json . toString ( ) , klass ) ; } catch ( IOException ex ) { throw new JsonException ( ex ) ; } } \n', 0.42508075389284616)

('public static FileConfiguration parseFromFile ( final File file ) { FileConfiguration configuration = new FileConfiguration ( file ) ; if ( file == null || ! file . exists ( ) ) { return configuration ; } try { BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { String key , value ; int i = line . indexOf ( "=" ) ; if ( i > 0 ) { key = line . substring ( 0 , i ) ; value = line . substring ( i + 1 ) ; configuration . set ( key , value ) ; } line = reader . readLine ( ) ; } reader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return configuration ; } \n', 0.42431469466740857)

('public final void parseSignaturesString ( String signatures ) throws IOException , ParseException { parseSignaturesFile ( new StringReader ( signatures ) , false ) ; } \n', 0.4242943417237494)

('public void parseSignaturesString ( String signatures ) throws IOException , ParseException { logger . info ( "Reading-inline-API-signatures..." ) ; parseSignaturesFile ( new StringReader ( signatures ) , false ) ; } \n', 0.4227131697511879)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 44 #################################
('private static String readTextFromAddresseElement ( Node addresseeElement ) { StringBuilder text = new StringBuilder ( ) ; NodeList nodes = addresseeElement . getChildNodes ( ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; ++ i ) { Node node = nodes . item ( i ) ; switch ( node . getNodeType ( ) ) { case Node . TEXT_NODE : String unescapedText = StringEscapeUtils . unescapeHtml4 ( node . getNodeValue ( ) ) ; text . append ( StringUtils . cleanFormatting ( unescapedText ) ) ; break ; case Node . ELEMENT_NODE : if ( node . getNodeName ( ) . equalsIgnoreCase ( HTML_TAG_BR ) ) { text . append ( System . getProperty ( "line.separator" ) ) ; } else if ( node . getNodeName ( ) . equalsIgnoreCase ( HTML_TAG_TAB ) ) { text . append ( \'|t\' ) ; } break ; default : { logger . info ( "The-node-type-is-" + node . getNodeType ( ) ) ; } } } return text . toString ( ) . trim ( ) ; } \n', 0.40740678731509816)

('private static ASTHref readHref ( Node node , String href ) { LocationData locationData = ( LocationData ) ( ( Element ) node ) . getData ( ) ; HrefResult result = readHrefWorker ( locationData , href ) ; if ( ! END . matcher ( result . rest ) . find ( ) ) throw new ValidationException ( "Can\'t-parse-"" + result . rest + ""-in-href" , locationData ) ; return result . astHref ; } \n', 0.40576031645813404)

('public void readSchema ( Reader reader , IProgressMonitor monitor ) throws IOException { try { monitor . beginTask ( "Getting-the-list-of-assignments-available-for-download..." , 1 ) ; DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setIgnoringComments ( true ) ; factory . setCoalescing ( false ) ; factory . setNamespaceAware ( true ) ; factory . setValidating ( false ) ; SubmissionParserErrorHandler errorHandler = new SubmissionParserErrorHandler ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; builder . setErrorHandler ( errorHandler ) ; Document document = builder . parse ( new InputSource ( reader ) ) ; TargetParseError [ ] errors = errorHandler . getErrors ( ) ; if ( errors != null ) { throw new TargetParseException ( errors ) ; } else { root = new RootImportNode ( ) ; root . parse ( document . getDocumentElement ( ) ) ; } } catch ( ParserConfigurationException e ) { throw new ProjectLinkException ( e ) ; } catch ( SAXException e ) { throw new ProjectLinkException ( e ) ; } finally { monitor . done ( ) ; } } \n', 0.40149149364546965)

('private Set < String > readNamespacesFromFile ( ) { Set < String > namespaceUris = new HashSet < String > ( ) ; if ( domDocument != null ) { Element rootElement = domDocument . getDocumentElement ( ) ; if ( rootElement != null ) { NamedNodeMap beanAttributes = rootElement . getAttributes ( ) ; for ( int i = 0 ; i < beanAttributes . getLength ( ) ; i ++ ) { Node currAttr = beanAttributes . item ( i ) ; String currAttrName = currAttr . getNodeName ( ) . trim ( ) ; String currAttrValue = currAttr . getNodeValue ( ) . trim ( ) ; if ( currAttrName . startsWith ( ConfigCoreUtils . ATTR_DEFAULT_NAMESPACE ) ) { namespaceUris . add ( currAttrValue ) ; } } } List < String > schemaInfo = ConfigCoreUtils . parseSchemaLocationAttr ( domDocument ) ; if ( schemaInfo != null ) { Iterator < String > iterator = schemaInfo . iterator ( ) ; while ( iterator . hasNext ( ) ) { String currSchema = iterator . next ( ) ; if ( ! namespaceUris . contains ( currSchema ) ) { namespaceUris . add ( currSchema ) ; } if ( iterator . hasNext ( ) ) { iterator . next ( ) ; } } } } return namespaceUris ; } \n', 0.3978831239859921)

('public IGrepLink readLink ( InputSource source ) throws XmlHandlerException { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; try { DocumentBuilder builder = factory . newDocumentBuilder ( ) ; builder . setErrorHandler ( SILENT_ERROR_HANDLER ) ; Document doc = builder . parse ( source ) ; doc . getDocumentElement ( ) . normalize ( ) ; return readLink ( doc ) ; } catch ( ParserConfigurationException ex ) { throw new XmlHandlerException ( ex ) ; } catch ( SAXException ex ) { throw new XmlHandlerException ( ex ) ; } catch ( IOException ex ) { throw new XmlHandlerException ( ex ) ; } finally { } } \n', 0.395106335561814)

('protected List < String > readFromUrl ( ) throws Exception { final DocumentBuilder documentBuilder = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; final Document document = documentBuilder . parse ( _url ) ; final Element documentElement = document . getDocumentElement ( ) ; final String codebase = documentElement . getAttribute ( "codebase" ) ; final NodeList jarElements = document . getElementsByTagName ( "jar" ) ; final int length = jarElements . getLength ( ) ; assert length > 0 ; final List < String > result = new ArrayList < String > ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { final Element jarElement = ( Element ) jarElements . item ( i ) ; final String href = jarElement . getAttribute ( "href" ) ; if ( codebase == null ) { result . add ( href ) ; } else if ( codebase . endsWith ( "/" ) ) { result . add ( codebase + href ) ; } else { result . add ( codebase + \'/\' + href ) ; } } return result ; } \n', 0.3939087656954905)

('private XmlTree readXmlTree ( InputSource input ) throws IllegalArgumentException , IOException { XMLReader xr ; xmlReadTreeRoot = null ; xmlReadStack = new Stack < XmlTree > ( ) ; try { xr = XMLReaderFactory . createXMLReader ( ) ; XmlSAXHandler handler = new XmlSAXHandler ( ) ; xr . setFeature ( "http://xml.org/sax/features/namespaces" , false ) ; xr . setFeature ( "http://xml.org/sax/features/validation" , false ) ; xr . setFeature ( "http://apache.org/xml/features/nonvalidating/load-dtd-grammar" , false ) ; xr . setFeature ( "http://apache.org/xml/features/nonvalidating/load-external-dtd" , false ) ; xr . setContentHandler ( handler ) ; xr . setErrorHandler ( handler ) ; xr . parse ( input ) ; } catch ( SAXException e ) { throw new IOException ( ) ; } return xmlReadTreeRoot ; } \n', 0.39305468165446333)

('protected Version readVersionElement ( Element element ) throws PackageException { Version v = new Version ( readNameAttr ( element ) ) ; v . setPath ( readPathAttr ( element ) ) ; Node node = element . getFirstChild ( ) ; while ( node != null ) { if ( node . getNodeType ( ) == Node . ELEMENT_NODE && "package" . equals ( node . getNodeName ( ) ) ) { UpdateOptions opt = new UpdateOptions ( ) ; opt . pkgId = ( ( Element ) node ) . getTextContent ( ) . trim ( ) ; opt . upgradeOnly = Boolean . parseBoolean ( ( ( Element ) node ) . getAttribute ( "upgradeOnly" ) ) ; v . addPackage ( opt ) ; } node = node . getNextSibling ( ) ; } return v ; } \n', 0.39043569775761694)

('public HTMLElement parseHTML ( InputStreamReader isr ) { return ( HTMLElement ) super . parse ( isr ) ; } \n', 0.3885460624120572)

('public Element readHtml ( String html ) { try { html = html . replaceAll ( "&nbsp;" , "&#160;" ) ; return documentBuilder . parse ( new ByteArrayInputStream ( html . getBytes ( "UTF-8" ) ) ) . getDocumentElement ( ) ; } catch ( SAXException | IOException e ) { e . printStackTrace ( ) ; return null ; } } \n', 0.38844712466770637)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 45 #################################
('public static double log10Integrate ( double lowBound , double upBound ) { double lastArea = 0 ; double slice = 2 ; double area = ( upBound - lowBound ) * ( Math . log10 ( ( upBound + lowBound ) / 2 ) ) ; while ( Math . abs ( lastArea - area ) > .01 ) { double sliceWidth = Math . abs ( ( upBound - lowBound ) / slice ) ; double newLowBound = lowBound ; double newUpBound = lowBound + sliceWidth ; lastArea = area ; area = 0 ; for ( int i = ( int ) slice ; i > 0 ; i -- ) { area = area + ( ( newUpBound - newLowBound ) * ( Math . log10 ( ( newUpBound + newLowBound ) / 2 ) ) ) ; newLowBound = newLowBound + sliceWidth ; newUpBound = newUpBound + sliceWidth ; } slice = Math . pow ( slice , 2.0 ) ; } return area ; } \n', 0.3918330895667358)

('public static double coefficient ( double [ ] x , double [ ] y ) { final int xdim = x . length ; final int ydim = y . length ; if ( xdim != ydim ) { throw new IllegalArgumentException ( "Invalid-arguments:-arrays-differ-in-length." ) ; } double sumXX = 0. , sumYY = 0. , sumXY = 0. ; double meanX = x [ 0 ] , meanY = y [ 0 ] ; int i = 1 ; while ( i < xdim ) { final double xv = x [ i ] , yv = y [ i ] ; final double deltaX = xv - meanX ; final double deltaY = yv - meanY ; ++ i ; meanX += deltaX / i ; meanY += deltaY / i ; final double neltaX = xv - meanX ; final double neltaY = yv - meanY ; sumXX += deltaX * neltaX ; sumYY += deltaY * neltaY ; sumXY += deltaX * neltaY ; } if ( ! ( sumXX > 0. && sumYY > 0. ) ) { return ( sumXX == sumYY ) ? 1. : 0. ; } return sumXY / Math . sqrt ( sumXX * sumYY ) ; } \n', 0.38671173967034045)

('public double expDistribution ( double lambda , double x ) { ExponentialDistribution exp = new ExponentialDistribution ( lambda ) ; return exp . density ( x ) ; } \n', 0.384601776040728)

('protected double [ ] distributionForInstanceMajorityVoting ( Instance instance ) throws Exception { double [ ] probs = new double [ instance . classAttribute ( ) . numValues ( ) ] ; double [ ] votes = new double [ probs . length ] ; for ( int i = 0 ; i < m_Classifiers . length ; i ++ ) { probs = getClassifier ( i ) . distributionForInstance ( instance ) ; int maxIndex = 0 ; for ( int j = 0 ; j < probs . length ; j ++ ) { if ( probs [ j ] > probs [ maxIndex ] ) maxIndex = j ; } for ( int j = 0 ; j < probs . length ; j ++ ) { if ( probs [ j ] == probs [ maxIndex ] ) votes [ j ] ++ ; } } int tmpMajorityIndex = 0 ; for ( int k = 1 ; k < votes . length ; k ++ ) { if ( votes [ k ] > votes [ tmpMajorityIndex ] ) tmpMajorityIndex = k ; } Vector < Integer > majorityIndexes = new Vector < Integer > ( ) ; for ( int k = 0 ; k < votes . length ; k ++ ) { if ( votes [ k ] == votes [ tmpMajorityIndex ] ) majorityIndexes . add ( k ) ; } int majorityIndex = majorityIndexes . get ( m_Random . nextInt ( majorityIndexes . size ( ) ) ) ; for ( int k = 0 ; k < probs . length ; k ++ ) probs [ k ] = 0 ; probs [ majorityIndex ] = 1 ; return probs ; } \n', 0.3841079439722399)

('@ Override public double [ ] distributionForInstance ( Instance instance ) throws Exception { ArrayList < Double > prototiposCercanos = new ArrayList < Double > ( prototipos . size ( ) ) ; double [ ] probabilidades = new double [ prototipos . size ( ) ] ; double sumaProbabilidades = 0 ; double totalDistancias = 0 ; for ( int i = 0 ; i < prototipos . size ( ) ; ++ i ) { prototiposCercanos . add ( distancia ( instance , prototipoMasCercano ( instance , i ) ) ) ; } for ( int i = 0 ; i < prototiposCercanos . size ( ) ; i ++ ) totalDistancias += prototiposCercanos . get ( i ) ; for ( int i = 0 ; i < probabilidades . length ; i ++ ) { probabilidades [ i ] = 1 - ( prototiposCercanos . get ( i ) / totalDistancias ) ; sumaProbabilidades += probabilidades [ i ] ; } for ( int i = 0 ; i < probabilidades . length ; i ++ ) probabilidades [ i ] = probabilidades [ i ] / sumaProbabilidades ; return probabilidades ; } \n', 0.38301300502343466)

('public Builder exponentialBuckets ( double start , double factor , int count ) { buckets = new double [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { buckets [ i ] = start * Math . pow ( factor , i ) ; } return this ; } \n', 0.3827093569719565)

('public double density ( double x ) { if ( x < min || x > max ) { return 0d ; } final int binIndex = findBin ( x ) ; final RealDistribution kernel = getKernel ( binStats . get ( binIndex ) ) ; return kernel . density ( x ) * pB ( binIndex ) / kB ( binIndex ) ; } \n', 0.38220283225033796)

('@ Override public double density ( double x ) { if ( x < min || x > max ) { return 0d ; } final int binIndex = findBin ( x ) ; final RealDistribution kernel = getKernel ( binStats . get ( binIndex ) ) ; return kernel . density ( x ) * pB ( binIndex ) / kB ( binIndex ) ; } \n', 0.38220283225033796)

('public double [ ] distributionForInstance ( Instance instance ) throws Exception { double [ ] probOfClassGivenDoc = new double [ m_numClasses ] ; double [ ] logDocGivenClass = new double [ m_numClasses ] ; for ( int h = 0 ; h < m_numClasses ; h ++ ) logDocGivenClass [ h ] = probOfDocGivenClass ( instance , h ) ; double max = logDocGivenClass [ Utils . maxIndex ( logDocGivenClass ) ] ; double probOfDoc = 0.0 ; for ( int i = 0 ; i < m_numClasses ; i ++ ) { probOfClassGivenDoc [ i ] = Math . exp ( logDocGivenClass [ i ] - max ) * m_probOfClass [ i ] ; probOfDoc += probOfClassGivenDoc [ i ] ; } Utils . normalize ( probOfClassGivenDoc , probOfDoc ) ; return probOfClassGivenDoc ; } \n', 0.38181223751422)

('public double density ( final double [ ] vals ) throws DimensionMismatchException { final int dim = getDimension ( ) ; if ( vals . length != dim ) { throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0.5 ) * getExponentTerm ( vals ) ; } \n', 0.37939494971649135)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 46 #################################
('protected String valueToCSV ( List < String > values , String valueSeparator ) { if ( values == null ) { return "" ; } String s ; if ( values . size ( ) == 1 ) { s = values . get ( 0 ) ; } else { StringBuilder str = new StringBuilder ( ) ; for ( String value : values ) { if ( str . length ( ) > 0 ) { str . append ( valueSeparator ) ; } str . append ( value ) ; } s = str . toString ( ) ; } return """ + s . replaceAll ( """ , """" ) + """ ; } \n', 0.42215469412100703)

('protected String valueToCSV ( List < String > values ) { if ( values == null ) { return "" ; } String s ; if ( values . size ( ) == 1 ) { s = values . get ( 0 ) ; } else { StringBuilder str = new StringBuilder ( ) ; for ( String value : values ) { if ( str . length ( ) > 0 ) { str . append ( DSpaceCSV . valueSeparator ) ; } str . append ( value ) ; } s = str . toString ( ) ; } return """ + s . replaceAll ( """ , """" ) + """ ; } \n', 0.42133907245931446)

('protected String convertToValidCSV ( Object value ) throws IOException { if ( value == null ) return "" ; StringBuilder r = new StringBuilder ( value . toString ( ) ) ; boolean containsDoubleQuote = r . indexOf ( DOUBLEQUOTE ) >= 0 , containsDelimiter = r . indexOf ( DELIMITER ) >= 0 , containsNewline = r . indexOf ( NEWLINE ) >= 0 ; if ( containsDoubleQuote ) { int k = 0 ; while ( ( k = r . indexOf ( DOUBLEQUOTE , k ) ) >= 0 ) { r . insert ( k , DOUBLEQUOTE ) ; k += 2 ; } } if ( containsDoubleQuote || containsDelimiter || containsNewline ) { r . insert ( 0 , DOUBLEQUOTE ) ; r . append ( DOUBLEQUOTE ) ; } return r . toString ( ) ; } \n', 0.419594767180675)

('private String valueToCSV ( ArrayList < String > values ) { String s = "" ; if ( values == null ) { return s ; } if ( values . size ( ) == 1 ) { s = values . get ( 0 ) ; } else { Iterator i = values . iterator ( ) ; while ( i . hasNext ( ) ) { s = s + i . next ( ) ; if ( i . hasNext ( ) ) { s = s + DSpaceCSV . valueSeparator ; } } } s = s . replaceAll ( """ , """" ) ; s = """ + s + """ ; return s ; } \n', 0.4100924813565987)

('protected String valueToCSV ( List < String > values ) { if ( values == null ) { return "" ; } String s ; if ( values . size ( ) == 1 ) { s = values . get ( 0 ) ; } else { StringBuilder str = new StringBuilder ( ) ; for ( String value : values ) { if ( str . length ( ) > 0 ) { str . append ( DSpaceCSV . valueSeparator ) ; } str . append ( value ) ; } s = str . toString ( ) ; } return """ + s . replaceAll ( """ , """" ) + """ ; } \n', 0.40841408743552626)

('public String toCSV ( List < Map > list , String ... tokens ) { String output = "" ; for ( String token : tokens ) { output += token + "," ; } output = output . substring ( 0 , output . length ( ) - 1 ) + "-" ; for ( Map m : list ) { String line = "" ; for ( String arg : tokens ) { Object o = m . get ( arg ) ; if ( o instanceof String ) line += """ + m . get ( arg ) + ""," ; else if ( o instanceof Double ) line += m . get ( arg ) + "," ; else { String conv = gson . toJson ( o ) ; conv = conv . replaceAll ( "-" , "-" ) ; line += """ + conv + ""," ; } } line = line . substring ( 0 , line . length ( ) - 1 ) + "-" ; output += line ; } return output ; } \n', 0.40160961189122346)

('public static String stringToCsv ( String [ ] [ ] anArray ) { String csv = "" ; for ( int i = 0 ; i < anArray . length ; i ++ ) { for ( int j = 0 ; j < anArray [ i ] . length ; j ++ ) { csv += anArray [ i ] [ j ] + "," ; } csv = csv . substring ( 0 , csv . length ( ) - 2 ) ; csv += "-" ; } return csv ; } \n', 0.3984653394042661)

('@ Deprecated public static String mapToStringExt ( Map < String , Integer > mp ) { String res = "" ; Iterator < Map . Entry < String , Integer >> it = mp . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry < String , Integer > pairs = ( Map . Entry < String , Integer > ) it . next ( ) ; if ( res . length ( ) > 0 ) { res = res + "," ; } res = res + pairs . getKey ( ) + SEPARATOR_SEMICOLON + pairs . getValue ( ) ; it . remove ( ) ; } if ( res . length ( ) > 0 ) { res = SEPARATOR_OPEN_BRACKET + res + SEPARATOR_CLOSE_BRACKET ; } return res ; } \n', 0.39097484041307407)

('public static String convertTopViolationsToCsv ( Map < String , Integer > violationsPerFile ) { StringBuffer buffer = new StringBuffer ( ) ; List < CheckStyleViolationInformation > violations = new ArrayList < CheckStyleViolationInformation > ( ) ; Iterator < String > keys = violationsPerFile . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { String key = keys . next ( ) ; int value = violationsPerFile . get ( key ) . intValue ( ) ; violations . add ( new CheckStyleViolationInformation ( key , value ) ) ; } Collections . sort ( violations ) ; for ( int i = 0 ; ( i < ( ( violations . size ( ) > 10 ) ? 10 : violations . size ( ) ) ) ; i ++ ) { CheckStyleViolationInformation info = violations . get ( i ) ; buffer . append ( info . getFileName ( ) ) . append ( "," ) ; buffer . append ( info . getNumberOfViolations ( ) ) . append ( LINE_SEPARATOR ) ; } return buffer . toString ( ) ; } \n', 0.3908840756975284)

("private static String toCSVString ( String key , double value ) { return key + CSV_DELIMITER + String . valueOf ( value ) . replace ( '.' , ',' ) + LINEBREAK ; } \n", 0.386069230356756)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 47 #################################
('private void checkZeroTimeout ( ) throws IOException { int available = inner . available ( ) ; if ( available != 0 ) { return ; } if ( timeout == 0 ) { return ; } if ( timeout < 5 ) { throw new SocketTimeoutException ( ) ; } else { throw new UnsupportedOperationException ( ) ; } } \n', 0.39122411526846745)

('public void forceInstantSend ( DatagramPacket packet ) { if ( m_socket . isConnected ( ) == true && ! interrupted ( ) ) { try { m_socket . send ( packet ) ; m_packetsSent ++ ; } catch ( Exception e ) { m_socket . disconnect ( ) ; } } } \n', 0.38745817601551913)

('protected Socket acceptSocket ( int timeout ) { try { Socket s = null ; if ( _listen != null ) { if ( _soTimeOut != timeout ) { _soTimeOut = timeout ; _listen . setSoTimeout ( _soTimeOut ) ; } s = _listen . accept ( ) ; try { if ( getMaxIdleTimeMs ( ) >= 0 ) s . setSoTimeout ( getMaxIdleTimeMs ( ) ) ; if ( _lingerTimeSecs >= 0 ) s . setSoLinger ( true , _lingerTimeSecs ) ; else s . setSoLinger ( false , 0 ) ; } catch ( Exception e ) { LogSupport . ignore ( log , e ) ; } } return s ; } catch ( java . net . SocketException e ) { LogSupport . ignore ( log , e ) ; } catch ( InterruptedIOException e ) { LogSupport . ignore ( log , e ) ; } catch ( IOException e ) { log . warn ( LogSupport . EXCEPTION , e ) ; } return null ; } \n', 0.3859319924161048)

('protected Socket acceptSocket ( ServerSocket serverSocket , int timeout ) { try { Socket s = null ; if ( _soTimeOut != timeout ) { _soTimeOut = timeout ; _listen . setSoTimeout ( _soTimeOut ) ; } if ( _listen != null ) { s = _listen . accept ( ) ; try { if ( getMaxIdleTimeMs ( ) >= 0 ) s . setSoTimeout ( getMaxIdleTimeMs ( ) ) ; if ( _lingerTimeSecs >= 0 ) s . setSoLinger ( true , _lingerTimeSecs ) ; else s . setSoLinger ( false , 0 ) ; } catch ( Exception e ) { Code . ignore ( e ) ; } } return s ; } catch ( java . net . SocketException e ) { Code . ignore ( e ) ; } catch ( InterruptedIOException e ) { if ( Code . verbose ( 99 ) ) Code . ignore ( e ) ; } catch ( IOException e ) { Code . warning ( e ) ; } return null ; } \n', 0.38543298247442254)

('static void connectWithTimeout ( Socket socket ) throws IOException { socket . connect ( new InetSocketAddress ( InetAddress . getLocalHost ( ) , 1234 ) , 500 ) ; } \n', 0.3816492525634533)

('public void waitForConnectionTimeout ( long timeout ) throws InterruptedException , ConnectionTimeoutException { waitForConnection ( timeout ) ; if ( ! anyReadyConnection ( ) ) throw new ConnectionTimeoutException ( "No-connection-was-established-within-timeout-(" + timeout + "-milliseconds)" ) ; } \n', 0.37937709088644755)

('void socketListen ( int count ) throws IOException { impl . socketListen ( count ) ; } \n', 0.3772961306730833)

('public boolean isSocketClosed ( ) { return socket . isClosed ( ) ; } \n', 0.3770615136248755)

('public int getSoTimeout ( int timeout ) throws SocketException { return proxy . proxySocket . getSoTimeout ( ) ; } \n', 0.37663021645516775)

('public int getSoTimeout ( ) throws IOException { if ( socket != null ) { return socket . getSoTimeout ( ) ; } else { throw new IOException ( "Connection-not-openned" ) ; } } \n', 0.3751185010772058)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 48 #################################
('public static String readFileIntoString ( File file ) throws IOException { if ( file . exists ( ) && file . canRead ( ) ) { ByteArrayOutputStream tmp = new ByteArrayOutputStream ( ( int ) file . length ( ) ) ; byte [ ] buffer = new byte [ 4096 ] ; int len = 0 ; BufferedInputStream inStream = new BufferedInputStream ( new FileInputStream ( file ) ) ; while ( ( len = inStream . read ( buffer ) ) != - 1 ) { tmp . write ( buffer , 0 , len ) ; } inStream . close ( ) ; tmp . flush ( ) ; tmp . close ( ) ; return new String ( tmp . toByteArray ( ) ) ; } else { throw new IOException ( "Cannot-read-file" ) ; } } \n', 0.4302262815754605)

('public static byte [ ] readBinaryFile ( File file ) throws IOException { FileInputStream fis = new FileInputStream ( file ) ; try { ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 1024 ] ; int len ; while ( ( len = fis . read ( buffer ) ) > 0 ) { stream . write ( buffer , 0 , len ) ; } byte [ ] output = stream . toByteArray ( ) ; stream . close ( ) ; return output ; } finally { fis . close ( ) ; } } \n', 0.4288755862272254)

('public static byte [ ] readFile ( File filePath ) { FileInputStream ins = null ; ByteArrayOutputStream baos = null ; if ( filePath . exists ( ) ) { try { ins = new FileInputStream ( filePath ) ; byte [ ] buffer = new byte [ 4096 ] ; int len = 0 ; baos = new ByteArrayOutputStream ( ) ; while ( ( len = ins . read ( buffer ) ) != - 1 ) { baos . write ( buffer , 0 , len ) ; baos . flush ( ) ; } return baos . toByteArray ( ) ; } catch ( Exception e ) { Flog . e ( e , "exception" ) ; return null ; } finally { if ( ins != null ) { try { ins . close ( ) ; } catch ( IOException e ) { Flog . e ( e , "exception" ) ; } } if ( baos != null ) { try { baos . close ( ) ; } catch ( IOException e ) { Flog . e ( e , "exception" ) ; } } } } return null ; } \n', 0.4270559562081578)

('public static String readFileToString ( File file ) throws IOException { String result ; FileInputStream fin = null ; try { fin = new FileInputStream ( file ) ; int length = fin . available ( ) ; byte [ ] buffer = new byte [ length ] ; fin . read ( buffer ) ; result = EncodingUtils . getString ( buffer , "UTF-8" ) ; fin . close ( ) ; } catch ( IOException e ) { throw e ; } finally { if ( fin != null ) fin . close ( ) ; } return result ; } \n', 0.4249905189670418)

('public static byte [ ] readBinaryFile ( File file ) throws Exception { FileInputStream stream = new FileInputStream ( file ) ; try { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 1024 ] ; int readBytes = 0 ; while ( ( readBytes = stream . read ( buffer ) ) != - 1 ) { output . write ( buffer , 0 , readBytes ) ; } return output . toByteArray ( ) ; } finally { stream . close ( ) ; } } \n', 0.4225022772168719)

('public static byte [ ] readFile ( File file ) throws IOException { FileInputStream fis = new FileInputStream ( file ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte [ ] buf = new byte [ 1024 ] ; for ( int readNum ; ( readNum = fis . read ( buf ) ) != - 1 ; ) { bos . write ( buf , 0 , readNum ) ; } bos . flush ( ) ; byte [ ] temp = bos . toByteArray ( ) ; bos . close ( ) ; return temp ; } \n', 0.4215488407607076)

('public static byte [ ] readFile ( String file ) { try { FileInputStream in = new FileInputStream ( new File ( file ) ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 1024 ] ; int len ; while ( ( len = in . read ( buffer , 0 , 1024 ) ) > - 1 ) { out . write ( buffer , 0 , len ) ; } in . close ( ) ; out . close ( ) ; return out . toByteArray ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } \n', 0.4201265286167327)

('public static byte [ ] readBinFile ( File file ) { FileInputStream fis = null ; try { byte [ ] buffer = new byte [ ( int ) file . length ( ) ] ; fis = new FileInputStream ( file ) ; long actual = fis . read ( buffer ) ; if ( actual != buffer . length ) { throw new RuntimeException ( "Error-reading-file-" + file . getAbsolutePath ( ) + "-.-Expected-" + buffer . length + "-bytes-but-got-" + actual ) ; } return buffer ; } catch ( Exception e ) { throw new RuntimeException ( "Error-reading-file-" + file . getAbsolutePath ( ) + "-:-" + e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( Exception e ) { ; } } } } \n', 0.4185092382355208)

('public static EBinary readFile ( File file ) throws IOException { int length = ( int ) file . length ( ) ; byte [ ] data = new byte [ length ] ; FileInputStream fi = new FileInputStream ( file ) ; try { ByteArrayOutputStream bo = new ByteArrayOutputStream ( ) ; int read = 0 ; while ( read < length ) { read += fi . read ( data , read , length - read ) ; } } finally { fi . close ( ) ; } EBinary bin = new EBinary ( data ) ; return bin ; } \n', 0.4179231203464997)

('public void readFromFile ( String file ) { FileInputStream fis = null ; ByteArrayOutputStream bos = null ; try { fis = new FileInputStream ( file ) ; bos = new ByteArrayOutputStream ( ) ; while ( fis . available ( ) != 0 ) { bos . write ( fis . read ( ) ) ; } byte [ ] bytes = bos . toByteArray ( ) ; appendInternal ( bytes ) ; } catch ( FileNotFoundException e ) { return ; } catch ( IOException e ) { return ; } finally { try { if ( bos != null ) bos . close ( ) ; } catch ( IOException e ) { } try { if ( fis != null ) fis . close ( ) ; } catch ( IOException e ) { } } } \n', 0.4177003312868472)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 49 #################################
('public static < T > Queue < T > priorityQueue ( ) { return new PriorityQueue < T > ( ) ; } \n', 0.47266666477079416)

('protected PriorityQueue ( boolean isMinQueue ) { this . isMinQueue = isMinQueue ; this . backer = new java . util . PriorityQueue < > ( ) ; } \n', 0.4685781063521681)

('public static < E > PriorityQueue < E > priorityQueue ( SortedSet < E > elements ) { return new PriorityQueue < E > ( elements ) ; } \n', 0.46639028129097665)

('private PriorityQueue < Double > priorityQueue ( int size ) { final PriorityQueue < Double > result = new PriorityQueue < > ( size < 1 ? 1 : size ) ; for ( int i = size ; i >= 0 ; i -- ) { result . add ( rng . nextDouble ( ) ) ; } return result ; } \n', 0.46051470365928926)

('private PriorityQueue < Elem > priorityQueueKeyed ( int size ) { final PriorityQueue < Elem > result = new PriorityQueue < > ( size < 1 ? 1 : size ) ; for ( int i = size ; i >= 0 ; i -- ) { result . add ( new Elem ( rng . nextDouble ( ) , value ) ) ; } return result ; } \n', 0.45976126251242044)

('public QueueItem checkOutWithHighestPriority ( ) throws InterruptedException { synchronized ( super . getLock ( ) ) { while ( ! hasQueuedItems ( ) ) { super . getLock ( ) . wait ( ) ; } return super . checkOut ( ( ( PriorityTuple ) queuedItemPriorityList . get ( queuedItemPriorityList . size ( ) - 1 ) ) . getKey ( ) ) ; } } \n', 0.45080347803810633)

('public QueueItem checkOutWithLowestPriority ( ) throws InterruptedException { synchronized ( super . getLock ( ) ) { while ( ! hasQueuedItems ( ) ) { super . getLock ( ) . wait ( ) ; } return super . checkOut ( ( ( PriorityTuple ) queuedItemPriorityList . get ( 0 ) ) . getKey ( ) ) ; } } \n', 0.4488267903294021)

('PriorityQueueSet ( int initialCapacity , Comparator < ? super E > comparator ) { this . queue = new PriorityQueue < E > ( initialCapacity , comparator ) ; } \n', 0.44859728996860515)

('public PriorityQueue < T > toPriorityQueue ( ) { PriorityQueue < T > priority = new PriorityQueue < T > ( ) ; Iterator < T > i = this . iterator ( ) ; while ( i . hasNext ( ) ) { priority . add ( i . next ( ) ) ; } return priority ; } \n', 0.4485091470949431)

('public PriorityQueue < T > toPriorityQueue ( ) { PriorityQueue < T > queue = new PriorityQueue < T > ( ) ; Iterator < T > i = this . iterator ( ) ; while ( i . hasNext ( ) ) { queue . add ( i . next ( ) ) ; } return queue ; } \n', 0.4485091470949431)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 50 #################################
('public void rebuildLOMRelationFromXMLLOMFor ( LOM aLom ) { if ( aLom == null ) { System . out . println ( "try-to-rebuild-relations-of-a-null-LOM" ) ; return ; } LinkedHashSet < LOMRelation > theLinkedHashSet = new LinkedHashSet < LOMRelation > ( ) ; ITSLOMRelationForLOMBuffer . put ( aLom , theLinkedHashSet ) ; List theRelationElements = aLom . getNodes ( LOM . ITSNameSpacePrefix + ":lom/" + LOM . ITSNameSpacePrefix + ":relation" ) ; for ( int i = 0 ; i < theRelationElements . size ( ) ; i ++ ) { Element theElement = ( Element ) theRelationElements . get ( i ) ; String theID = theElement . getChildTextTrim ( "ID" , theElement . getNamespace ( ) ) ; LOMRelation theRelation ; String theValue = theElement . getChild ( "kind" , theElement . getNamespace ( ) ) . getChild ( "value" , theElement . getNamespace ( ) ) . getChildTextTrim ( "langstring" , theElement . getNamespace ( ) ) ; if ( theValue == null || theValue . equals ( "" ) ) { System . out . println ( "found-but-not-removed-a-relation-without-value" ) ; } else { if ( theID == null ) theRelation = new LOMRelation ( aLom , theElement ) ; else { theRelation = getLOMRelation ( theID ) ; if ( theRelation == null ) theRelation = new LOMRelation ( aLom , theElement ) ; } theLinkedHashSet . add ( theRelation ) ; } } } \n', 0.3826487196021563)

('public void updateClusterVersionEntityRelation ( ClusterVersionEntity entity ) { clusterVersionEntities . add ( entity ) ; } \n', 0.38206986236164403)

('public void addClusterVersionEntity ( ClusterVersionEntity clusterVersionEntity ) { if ( clusterVersionEntities == null ) { clusterVersionEntities = new ArrayList < ClusterVersionEntity > ( ) ; } clusterVersionEntities . add ( clusterVersionEntity ) ; } \n', 0.3742520639894281)

('public TestScore [ ] bestSplitTests ( AttributeSet candidateAttributes , SymbolicAttribute goalAttribute ) { if ( candidateAttributes == null || goalAttribute == null || candidateAttributes . size ( ) == 0 ) throw new IllegalArgumentException ( "Invalid-attributes" ) ; TestScore [ ] bestTestScores = new TestScore [ candidateAttributes . size ( ) ] ; Vector attributes = candidateAttributes . attributes ( ) ; for ( int i = 0 ; i < attributes . size ( ) ; i ++ ) bestTestScores [ i ] = bestSplitTest ( ( Attribute ) attributes . elementAt ( i ) , goalAttribute ) ; return bestTestScores ; } \n', 0.3711936316379768)

('public Collection < TurnCostTableEntry > analyzeTurnRelation ( FlagEncoder encoder , OSMTurnRelation turnRelation ) { if ( ! encoder . supports ( TurnWeighting . class ) ) return Collections . emptyList ( ) ; EdgeExplorer edgeOutExplorer = outExplorerMap . get ( encoder ) ; EdgeExplorer edgeInExplorer = inExplorerMap . get ( encoder ) ; if ( edgeOutExplorer == null || edgeInExplorer == null ) { edgeOutExplorer = graph . createEdgeExplorer ( new DefaultEdgeFilter ( encoder , false , true ) ) ; outExplorerMap . put ( encoder , edgeOutExplorer ) ; edgeInExplorer = graph . createEdgeExplorer ( new DefaultEdgeFilter ( encoder , true , false ) ) ; inExplorerMap . put ( encoder , edgeInExplorer ) ; } return turnRelation . getRestrictionAsEntries ( encoder , edgeOutExplorer , edgeInExplorer , this ) ; } \n', 0.3698063764649513)

('protected float [ ] solveAfterRandomSampling ( Set < PairInt > points , SecureRandom sr ) { int n = ( points . size ( ) > 2500 ) ? 2500 : points . size ( ) ; List < PairInt > tmp = new ArrayList < PairInt > ( points ) ; int [ ] indexes = new int [ n ] ; if ( n != points . size ( ) ) { MiscMath . chooseRandomly ( sr , indexes , points . size ( ) ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { indexes [ i ] = i ; } } float [ ] xP = new float [ n ] ; float [ ] yP = new float [ xP . length ] ; int i = 0 ; for ( int idx : indexes ) { PairInt p = tmp . get ( idx ) ; xP [ i ] = p . getX ( ) ; yP [ i ] = p . getY ( ) ; i ++ ; } tmp = null ; float [ ] coeff = solve ( xP , yP ) ; return coeff ; } \n', 0.3695629620726739)

('private void formSimilarEntityPairsAcrossTriples ( List < String > listSubjsObjs , String subject , String object ) { if ( ! listSubjsObjs . contains ( subject ) ) { listSubjsObjs . add ( subject ) ; } if ( ! listSubjsObjs . contains ( object ) ) { listSubjsObjs . add ( object ) ; } } \n', 0.3693501247773129)

('private char getRelationFromSenseGlossMatchers ( List < ISense > sourceSenses , List < ISense > targetSenses ) throws MatcherLibraryException { char relation = IMappingElement . IDK ; if ( 0 < senseGlossMatchers . size ( ) ) { for ( ISense sourceSense : sourceSenses ) { for ( ISense targetSense : targetSenses ) { int k = 0 ; while ( ( relation == IMappingElement . IDK ) && ( k < senseGlossMatchers . size ( ) ) ) { relation = senseGlossMatchers . get ( k ) . match ( sourceSense , targetSense ) ; k ++ ; } return relation ; } } } return relation ; } \n', 0.36873560907499514)

('public Hashtable < String , Complex > calBoundaryBusEquivCurInj ( ) { Hashtable < String , Complex > equivCurInj = new Hashtable < > ( ) ; for ( String busId : boundaryBusIdAry ) { AclfBus bus = net . getBus ( busId ) ; Complex busVolt = bus . getVoltage ( ) ; Complex equivPowerInjComplex = new Complex ( 0 , 0 ) ; Complex equivCurComplex = new Complex ( 0 , 0 ) ; if ( bus . isActive ( ) ) { for ( Branch bra : bus . getBranchList ( ) ) { if ( bra instanceof AclfBranch ) { AclfBranch branch = ( AclfBranch ) bra ; if ( ! bra . isGroundBranch ( ) && bra . isActive ( ) ) { if ( bra . getFromBus ( ) . getId ( ) . endsWith ( busId ) && ! internalNetworkBusList . contains ( bra . getToBus ( ) . getId ( ) ) && ! boundaryBusIdList . contains ( bra . getToBus ( ) . getId ( ) ) ) { equivPowerInjComplex = equivPowerInjComplex . add ( branch . powerFrom2To ( ) ) ; } else if ( bra . getToBus ( ) . getId ( ) . endsWith ( busId ) && ! internalNetworkBusList . contains ( bra . getFromBus ( ) . getId ( ) ) && ! boundaryBusIdList . contains ( bra . getFromBus ( ) . getId ( ) ) ) { equivPowerInjComplex = equivPowerInjComplex . add ( branch . powerTo2From ( ) ) ; } } } } } equivCurComplex = equivPowerInjComplex . divide ( busVolt ) . conjugate ( ) ; equivCurInj . put ( busId , equivCurComplex ) ; } return equivCurInj ; } \n', 0.36842843835144157)

('public Sequence < Pair < T , T >> consecutivePairs ( final boolean includeLast ) { final Iterator < T > iterator = Sequence . this . iterator ( ) ; if ( ! iterator . hasNext ( ) ) { return emptySequence ( ) ; } return new NullTerminatedSequence < Pair < T , T >> ( ) { private T last = iterator . next ( ) ; private boolean finished = false ; @ Override protected Pair < T , T > getNext ( ) { if ( iterator . hasNext ( ) ) { T next = iterator . next ( ) ; Pair < T , T > result = Pair . create ( last , next ) ; last = next ; return result ; } if ( includeLast && ! finished ) { finished = true ; return Pair . create ( last , null ) ; } return null ; } } ; } \n', 0.3682054581664833)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 51 #################################
('public Process getProcessFromId ( int id ) { for ( Process process : this . processes ) { if ( process . getId ( ) == id ) { return process ; } } return null ; } \n', 0.40742493745892844)

('public ToolhostProcess getProcess ( int id ) { return processes . get ( id ) ; } \n', 0.40592168367505754)

('private Process getProcessById ( String id ) { for ( Iterator < Process > it = processes . iterator ( ) ; it . hasNext ( ) ; ) { Process p = it . next ( ) ; if ( p . getId ( ) . equals ( id ) ) return p ; } return null ; } \n', 0.4051697039287081)

('public static long getProcessId ( ) { RuntimeMXBean bean = ManagementFactory . getRuntimeMXBean ( ) ; String jvmName = bean . getName ( ) ; long processId = Long . valueOf ( jvmName . split ( "@" ) [ 0 ] ) ; return processId ; } \n', 0.3997955653596935)

('public static int getCurrentProcessId ( ) { final Integer processId = s_currentProcess_ID . get ( ) ; if ( processId == null ) { return 0 ; } return processId ; } \n', 0.3997167528215526)

('public int getProcessId ( ) throws NativeException { return process . getProcessId ( ) ; } \n', 0.396811459898392)

('@ Override public Process getProcess ( String processId ) { return processes . get ( processId ) ; } \n', 0.3950648886032732)

('protected Integer getTransactionId ( String url ) { Integer transactId = - 1 ; if ( url != null && url . contains ( transactionUrl ) ) { String [ ] tab = url . split ( "/" ) ; String last = tab [ tab . length - 1 ] ; try { transactId = Integer . valueOf ( last ) ; } catch ( NumberFormatException e ) { transactId = - 1 ; } } return transactId ; } \n', 0.3949111891449729)

('public static long getProcessId ( ) { return Context . getCurrentContext ( ) . getProcessId ( ) ; } \n', 0.39412113969445123)

('private String getProcessId ( String externalId ) throws WorkflowException { StringTokenizer st = new StringTokenizer ( externalId , "__" ) ; if ( st . countTokens ( ) != 4 ) throw new WorkflowException ( "TaskManagerImpl.getProcessId" , "workflowEngine.EX_ERR_ILLEGAL_EXTERNALID" , "external-Id-:-" + externalId ) ; return st . nextToken ( ) ; } \n', 0.39317056920909255)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 52 #################################
('void writeBytesToConnection ( HttpURLConnection connection , byte [ ] bytes ) throws IOException { OutputStream out = new BufferedOutputStream ( connection . getOutputStream ( ) , BUFFER_CAPACITY ) ; InputStream inputStream = new ByteArrayInputStream ( bytes ) ; byte [ ] data = new byte [ CHUNK_SIZE ] ; int length ; while ( ( length = inputStream . read ( data ) ) != - 1 ) { out . write ( data , 0 , length ) ; } out . flush ( ) ; } \n', 0.409266346274198)

('private void writeResponseFromCache ( String filePath , OutputStream outputStream , String hostName ) { DataOutputStream out = new DataOutputStream ( outputStream ) ; logger . info ( "" + hostName + "::" + filePath + "-served-from-cache" ) ; try { BufferedInputStream reader = new BufferedInputStream ( new FileInputStream ( filePath ) ) ; byte [ ] buffer = new byte [ BUF_SIZE ] ; int count ; while ( ( count = reader . read ( buffer , 0 , BUF_SIZE ) ) > - 1 ) { out . write ( buffer , 0 , count ) ; } out . flush ( ) ; reader . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.39910251908777405)

('public void transferTxtToServer ( String fileName , Socket sock ) { try { FileInputStream fileInputStream = new FileInputStream ( new File ( fileName ) ) ; BufferedOutputStream bufferedOutputStream = new BufferedOutputStream ( sock . getOutputStream ( ) ) ; byte [ ] buf = new byte [ 1024 ] ; int len = 0 ; while ( ( len = fileInputStream . read ( buf , 0 , 1024 ) ) != - 1 ) { bufferedOutputStream . write ( buf , 0 , len ) ; bufferedOutputStream . flush ( ) ; } fileInputStream . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.3938118751593691)

('@ Override public HttpURLConnection writeDataToConnection ( HttpURLConnection conn , String ... input ) throws IOException { OutputStream os = conn . getOutputStream ( ) ; for ( String s : input ) os . write ( s . getBytes ( ) ) ; os . flush ( ) ; return conn ; } \n', 0.3922444567921051)

('private void sendToStream ( ByteArrayOutputStream data ) throws IOException { outStream . write ( HEADER ) ; outStream . writeInt ( data . size ( ) ) ; data . writeTo ( outStream ) ; } \n', 0.38226742324252405)

('public void saveBytesFromServer ( byte [ ] array ) throws IOException { FileOutputStream fileName = new FileOutputStream ( mInputFileName ) ; BufferedOutputStream stream = new BufferedOutputStream ( fileName ) ; stream . write ( array , 0 , array . length ) ; stream . flush ( ) ; stream . close ( ) ; } \n', 0.3802344997760161)

('public void writeToTCP ( byte [ ] audioBytes ) { try { dos . writeInt ( audioBytes . length ) ; if ( audioBytes . length > 0 ) { dos . write ( audioBytes ) ; } } catch ( IOException e ) { System . err . println ( "There-was-an-error-writing-to-the-socket:-" + e ) ; System . err . println ( "Is-the-other-client-still-listening?" ) ; this . initTCP ( ) ; } } \n', 0.3780624887660612)

('@ Override public void closeWriterOnServer ( String sessID , int transferID ) throws IOException { InboundStreamInfo info = inboundMap . get ( sessID + transferID ) ; info . stream . close ( ) ; info . stream = null ; LOG . info ( "Closed-transfer-with-ID-" + transferID ) ; } \n', 0.3755779525743763)

('void writePayloadToConnection ( Payload payload , Object lengthDesc , HttpURLConnection connection ) throws IOException { connection . setDoOutput ( true ) ; CountingOutputStream out = new CountingOutputStream ( connection . getOutputStream ( ) ) ; try { payload . writeTo ( out ) ; } catch ( IOException e ) { logger . error ( e , "error-after-writing-%d/%s-bytes-to-%s" , out . getCount ( ) , lengthDesc , connection . getURL ( ) ) ; throw e ; } } \n', 0.3736092923596414)

('public void closeDataCollectorDataStream ( UUID id ) throws IOException { DataOutputStream stream = dataCollectorIdxStreamMap . get ( id ) ; stream . close ( ) ; this . dataCollectorDataStreamMap . remove ( id ) ; } \n', 0.37306803620406825)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 53 #################################
('private void grantConnect ( Connection con , String databaseName , String username ) throws SQLException , RSSManagerException { RSSManagerUtil . checkIfParameterSecured ( databaseName ) ; RSSManagerUtil . checkIfParameterSecured ( username ) ; PreparedStatement st = con . prepareStatement ( "-GRANT-CONNECT-ON-DATABASE-"" + databaseName + ""-TO-"" + username + """ ) ; st . executeUpdate ( ) ; st . close ( ) ; } \n', 0.38968050479724714)

('public void registerWorkerDataBaseFail ( String username , Exception e ) { workerStats . workerDatabaseFails . put ( username , e . getMessage ( ) ) ; } \n', 0.36545416047442636)

('public static void connect ( ) throws SMException { try { connection = DriverManager . getConnection ( "jdbc:mysql://" + MYSQL_URL + ":" + MYSQL_PORT + "/" + MYSQL_DATABASE , MYSQL_USERNAME , MYSQL_PASSWORD ) ; statement = connection . createStatement ( ) ; resultSet = statement . executeQuery ( "SELECT-VERSION()" ) ; if ( resultSet . next ( ) ) SMLog . write ( "MySQL-version-:-" + resultSet . getString ( 1 ) ) ; } catch ( SQLException ex ) { throw new SMRuntimeException ( ex . getMessage ( ) ) ; } } \n', 0.36422865537295096)

('public boolean connect ( ) throws SQLException { serverConnection = DriverManager . getConnection ( String . format ( "jdbc:mysql://%s:%d/%s" , dbServer , dbPort , dbDatabase ) , dbUsername , dbPassword ) ; serverStatement = serverConnection . createStatement ( ) ; return true ; } \n', 0.3632188559705796)

('private void connect ( char [ ] passwd , Properties props , boolean autoCommit ) throws SQLException { if ( connection != null ) { throw new SQLException ( "Connection-to-database-\'" + databaseURL + "\'-already-exists!" ) ; } LogService . getRoot ( ) . log ( Level . CONFIG , "com.rapidminer.tools.jdbc.DatabaseHandler.connecting_to_database" , new Object [ ] { databaseURL , this . user } ) ; DriverManager . setLoginTimeout ( 30 ) ; props . put ( "SetBigStringTryClob" , "true" ) ; if ( this . user != null && ! user . isEmpty ( ) ) { props . put ( "user" , user ) ; props . put ( "password" , new String ( passwd ) ) ; } connection = DriverManager . getConnection ( databaseURL , props ) ; connection . setAutoCommit ( autoCommit ) ; statementCreator = new StatementCreator ( connection ) ; } \n', 0.36236707244706484)

('public void connect ( String username , String passwd , boolean autoCommit ) throws SQLException { if ( connection != null ) { throw new SQLException ( "connect:-Connection-to-database-\'" + databaseURL + "\'-already-exists!" ) ; } if ( username == null ) { connection = DriverManager . getConnection ( databaseURL ) ; } else { connection = DriverManager . getConnection ( databaseURL , username , passwd ) ; } connection . setAutoCommit ( autoCommit ) ; } \n', 0.36095931133290204)

('private synchronized boolean connectToLocDBServerAsRoot ( ) { try { if ( stmt != null ) { stmt . close ( ) ; } if ( con != null ) { con . close ( ) ; } con = DriverManager . getConnection ( url , rootUser , rootPasswd ) ; stmt = con . createStatement ( ) ; LogEngine . log ( this , "DB-ServerVerbindung-als-" + rootUser + "-hergestellt" , LogEngine . INFO ) ; dbStatus = 1 ; return true ; } catch ( SQLException e ) { try { Thread . sleep ( warteZeitInSec * 1000 ) ; } catch ( InterruptedException e1 ) { LogEngine . log ( this , "Fehler-beim-Warten:-" + e1 . getMessage ( ) , LogEngine . ERROR ) ; } dbStatus = 0 ; return false ; } } \n', 0.3602122858332616)

('public final boolean connect ( ) throws Exception { if ( DBconnection == null ) { if ( ! checkDependency ( ) ) { return false ; } Class . forName ( "com.mysql.jdbc.Driver" ) . newInstance ( ) ; DBconnection = DriverManager . getConnection ( String . format ( "jdbc:mysql://%s:%s/%s?create=true,autoReconnect=true" , sql_hostName , sql_portNum , sql_database ) , sql_username , sql_password ) ; } else { if ( DBconnection . isClosed ( ) ) { DBconnection = DriverManager . getConnection ( String . format ( "jdbc:mysql://%s:%s/%s?create=true,autoReconnect=true" , sql_hostName , sql_portNum , sql_database ) , sql_username , sql_password ) ; } } return DBconnection != null && DBconnection . getCatalog ( ) != null ; } \n', 0.35873365640810106)

('public static void connectToSQLSerrver ( ) { try { Class . forName ( SQLSERVER_JDBC_DRIVER ) . newInstance ( ) ; conn = DriverManager . getConnection ( SQLSERVER_DB_URL ) ; if ( msgON ) { Utils . alertBox ( "layoutLeft" , "Base-dados-aberta" ) ; } } catch ( SQLException ex ) { Utils . alertBox ( "layoutLeft" , "Erro-na-ligao" ) ; } catch ( ClassNotFoundException ex ) { Utils . alertBox ( "layoutLeft" , "Erro-no-Driver" ) ; } catch ( Exception ex ) { Utils . alertBox ( "layoutLeft" , "Erro-genrico-na-ligao" ) ; ex . printStackTrace ( ) ; } finally { try { if ( conn != null ) { conn . close ( ) ; if ( msgON ) { Utils . alertBox ( "SQLSERVER" , "Base-dados-fechada" ) ; } } } catch ( SQLException ex ) { Utils . alertBox ( "layoutLeft" , "Erro-na-ligao" ) ; } } } \n', 0.35830659413601207)

('public static void connect ( ) throws SQLException { if ( context == null || context . isClosed ( ) ) { context = DriverManager . getConnection ( dsn , username , password ) ; } if ( context == null || context . isClosed ( ) ) { throw new SQLException ( "Lost-context-to-MYSQL-server!" ) ; } } \n', 0.3578220110599555)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 54 #################################
('@ Deprecated public static void addCacheFile ( URI uri , Configuration conf ) { String files = conf . get ( MRJobConfig . CACHE_FILES ) ; conf . set ( MRJobConfig . CACHE_FILES , files == null ? uri . toString ( ) : files + "," + uri . toString ( ) ) ; } \n', 0.35137311845569796)

('public static void setDefaultGuidEntryToPreferences ( String gnsName , String username ) { String aliasKey = gnsName + "@default-guid" ; File gnsFolder = new File ( GNS_KEY_DIR ) ; gnsFolder . mkdirs ( ) ; String extStorageDirectory = gnsFolder . toString ( ) ; try { File file = new File ( extStorageDirectory , DEFAULT_GUIDS_FILENAME ) ; file . createNewFile ( ) ; FileOutputStream fOut = new FileOutputStream ( file ) ; OutputStreamWriter myOutWriter = new OutputStreamWriter ( fOut ) ; myOutWriter . write ( aliasKey + "-" ) ; myOutWriter . write ( username + "-" ) ; myOutWriter . close ( ) ; fOut . close ( ) ; } catch ( Exception e ) { Log . e ( KeyPairUtilsAndroid . class . getName ( ) , "Could-not-create-file" , e ) ; e . printStackTrace ( ) ; } } \n', 0.34262530205189057)

('@ Deprecated public static void addCacheArchive ( URI uri , Configuration conf ) { String archives = conf . get ( MRJobConfig . CACHE_ARCHIVES ) ; conf . set ( MRJobConfig . CACHE_ARCHIVES , archives == null ? uri . toString ( ) : archives + "," + uri . toString ( ) ) ; } \n', 0.34114525373688587)

('public final Bitmap getCachedArtwork ( final Context context , final String data , final long id ) { if ( context == null || data == null ) { return null ; } Bitmap cachedImage = getCachedBitmap ( data ) ; if ( cachedImage == null && id >= 0 ) { cachedImage = getArtworkFromFile ( context , id ) ; } if ( cachedImage != null ) { addBitmapToMemCache ( data , cachedImage ) ; return cachedImage ; } return null ; } \n', 0.34080516980694364)

('public void storeExportForced ( ) { configuration . setExportForced ( exportForced ) ; } \n', 0.3407283055155884)

('@ Override public boolean cachedResultsAvailable ( FileSystem fileSystem , Configuration conf , QueryRequest < InlinksByDomainQueryInfo , FlexBuffer , URLFPV2 > theClientRequest ) throws IOException { FileSystem localFileSystem = FileSystem . getLocal ( conf ) ; Path urlOutputFileName = new Path ( getLocalQueryResultsPathPrefix ( theClientRequest ) + "DATA" ) ; LOG . info ( "Cached-Results-Available-called-for-Query:" + theClientRequest . getSourceQuery ( ) . getQueryId ( ) + ".-Checking-Path:" + urlOutputFileName ) ; return localFileSystem . exists ( urlOutputFileName ) ; } \n', 0.33925180087536816)

('public void setDerbyStoragePageCacheSize ( String derbyStoragePageCacheSize ) { this . derbyStoragePageCacheSize = Integer . decode ( derbyStoragePageCacheSize ) . intValue ( ) ; } \n', 0.33651954361939757)

('private void streamPluginFileContentToDatabase ( int id , File file ) throws Exception { Connection conn = null ; PreparedStatement ps = null ; ResultSet rs = null ; FileInputStream fis = new FileInputStream ( file ) ; try { conn = this . dataSource . getConnection ( ) ; ps = conn . prepareStatement ( "UPDATE-" + Plugin . TABLE_NAME + "-SET-CONTENT-=-?-WHERE-ID-=-?" ) ; ps . setBinaryStream ( 1 , new BufferedInputStream ( fis ) , ( int ) file . length ( ) ) ; ps . setInt ( 2 , id ) ; int updateResults = ps . executeUpdate ( ) ; if ( updateResults != 1 ) { throw new Exception ( "Failed-to-update-content-for-plugin-[" + id + "]-from-[" + file + "]" ) ; } } finally { JDBCUtil . safeClose ( conn , ps , rs ) ; try { fis . close ( ) ; } catch ( Throwable t ) { } } return ; } \n', 0.3361510829499893)

('public synchronized void addCategoryToTempCache ( final CategoryInterface category ) { categoryCache . remove ( category ) ; categoryCache . put ( category . getName ( ) , category ) ; categoryIdCache . remove ( category ) ; categoryIdCache . put ( category . getId ( ) , category ) ; } \n', 0.3354697551334911)

('public int getMediaCountAll ( String blogId ) { Cursor cursor = getMediaFilesForBlog ( blogId ) ; int count = cursor . getCount ( ) ; cursor . close ( ) ; return count ; } \n', 0.33322275655784594)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 55 #################################
('public static String findReplaceIgnoreCase ( String searchMe , String pattern , String delimiter ) { Pattern pat = Pattern . compile ( pattern , Pattern . CASE_INSENSITIVE ) ; Matcher matcher = pat . matcher ( searchMe ) ; StringBuffer sb = new StringBuffer ( ) ; if ( matcher . find ( ) ) { matcher . appendReplacement ( sb , pattern ) ; if ( delimiter != null ) { if ( matcher . end ( ) != searchMe . length ( ) ) { sb . append ( delimiter ) ; } } matcher . appendTail ( sb ) ; return sb . toString ( ) ; } else { return searchMe ; } } \n', 0.3982900753465509)

('public static < V > SortedMap < String , V > filterPrefix ( SortedMap < String , V > baseMap , String prefix ) { if ( prefix . length ( ) > 0 ) { char nextLetter = ( char ) ( prefix . charAt ( prefix . length ( ) - 1 ) + 1 ) ; String end = prefix . substring ( 0 , prefix . length ( ) - 1 ) + nextLetter ; String range = prefix . substring ( 0 , 2 ) ; SortedMap < String , V > mo = baseMap . subMap ( range , end ) ; return mo ; } return baseMap ; } \n', 0.3878977723796869)

('public SortedMap < String , WordRank > filterPrefix ( SortedMap < String , WordRank > baseMap , String prefix ) { if ( prefix . length ( ) > 0 ) { char nextLetter = ( char ) ( prefix . charAt ( prefix . length ( ) - 1 ) + 1 ) ; String end = prefix . substring ( 0 , prefix . length ( ) - 1 ) + nextLetter ; return baseMap . subMap ( prefix , end ) ; } return baseMap ; } \n', 0.3825712075511757)

('public static String getKeyBasedOnPattern ( String pattern ) { String result = pattern ; Pattern quote = Pattern . compile ( "\'(.+)\'" ) ; Matcher m = quote . matcher ( pattern ) ; while ( m . find ( 0 ) ) { if ( m . groupCount ( ) > 0 ) { result = m . replaceFirst ( "$1" ) ; m = quote . matcher ( result ) ; } } return result . replaceAll ( "\'\'" , "\'" ) ; } \n', 0.38065220716814063)

('public boolean isEntryValid ( ) { if ( validationRegularExpression == null ) { return true ; } Matcher m = Pattern . compile ( validationRegularExpression ) . matcher ( text . get ( ) ) ; return m . find ( ) ; } \n', 0.37620046120245054)

('public MapDNPattern ( String pattern ) throws ELdapException { if ( pattern == null || pattern . equals ( "" ) ) { CMS . debug ( "MapDNPattern:-null-pattern" ) ; } else { mPatternString = pattern ; PushbackReader in = new PushbackReader ( new StringReader ( pattern ) ) ; parse ( in ) ; } } \n', 0.37599545089195774)

('private boolean checkForEscapes ( String sql ) { return CHECK_ESCAPE_PATTERN . matcher ( sql ) . find ( ) ; } \n', 0.3753969821528529)

('public String arrangeLabel ( String label , int wordNumber ) { final Pattern myPattern = Pattern . compile ( DIVIDE_KEY ) ; Matcher match = myPattern . matcher ( label ) ; if ( ! match . find ( ) ) return label ; else { match . reset ( ) ; int counter = - 1 ; StringBuffer str = new StringBuffer ( ) ; while ( match . find ( ) ) { counter ++ ; if ( counter == wordNumber ) { counter = - 1 ; match . appendReplacement ( str , Matcher . quoteReplacement ( INSERT_STRING ) ) ; } } match . appendTail ( str ) ; if ( str . length ( ) == 0 ) return label ; else return label = str . toString ( ) ; } } \n', 0.37519345171303553)

('public boolean entryIsBugFix ( ) { final String KEYWORD_REGEX = "|bfix(e[ds])?|b||bfixing|b||bbugs?|b||bdefects?|b||bpatch|b||bissues?|b" ; Pattern p = Pattern . compile ( KEYWORD_REGEX ) ; Matcher m = p . matcher ( this . message ) ; return m . find ( ) ; } \n', 0.3728582013999209)

('private static boolean isShowTableMatched ( String stmt , String pat1 ) { Pattern pattern = Pattern . compile ( pat1 , Pattern . CASE_INSENSITIVE ) ; Matcher ma = pattern . matcher ( stmt ) ; boolean flag = ma . matches ( ) ; return flag ; } \n', 0.37272827643874107)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 56 #################################
('private void applyColumnGrouping ( int [ ] columnSizes ) { for ( int groupIndex = 0 ; groupIndex < columnGroups . length ; groupIndex ++ ) { int [ ] group = columnGroups [ groupIndex ] ; int maxSize = 0 ; for ( int columnInGroupIndex = 0 ; columnInGroupIndex < group . length ; columnInGroupIndex ++ ) { int col = group [ columnInGroupIndex ] ; maxSize = Math . max ( maxSize , columnSizes [ col ] ) ; } for ( int columnInGroupIndex = 0 ; columnInGroupIndex < group . length ; columnInGroupIndex ++ ) { int col = group [ columnInGroupIndex ] ; columnSizes [ col ] = maxSize ; } } } \n', 0.43350186037995464)

('private ArrayList < Region > CoverRows ( int row_s , int row_l , int maxInput , boolean [ ] [ ] joinMatrix ) { ArrayList < Region > regions = new ArrayList < MBucketIPartitioning . Region > ( ) ; int col_s = getFirstSetColumn ( row_s , joinMatrix ) ; Region r = new Region ( row_s , row_l , col_s , maxInput , joinMatrix ) ; for ( int i = col_s ; i < joinMatrix [ 0 ] . length ; i ++ ) { if ( ! r . incrementY ( joinMatrix ) ) { regions . add ( r ) ; r = new Region ( row_s , row_l , i , maxInput , joinMatrix ) ; } } regions . add ( r ) ; return regions ; } \n', 0.41145352331666774)

('public static ArrayList < Integer > findColumnIndicesWithMostOnes ( int [ ] [ ] matrix ) { int numberOfOnes = 0 ; int maxNumberOfOnes = 0 ; ArrayList < Integer > columnIndex = new ArrayList < > ( ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) { numberOfOnes = 0 ; for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { if ( matrix [ j ] [ i ] == 1 ) { numberOfOnes ++ ; } } if ( numberOfOnes > maxNumberOfOnes ) { maxNumberOfOnes = numberOfOnes ; columnIndex . clear ( ) ; columnIndex . add ( i ) ; } else if ( numberOfOnes == maxNumberOfOnes ) { columnIndex . add ( i ) ; } } return columnIndex ; } \n', 0.4103143092843961)

('public static RealMatrix shuffleRows ( RealMatrix matrix , RandomGenerator randomGenerator ) { int [ ] index = MathArrays . sequence ( matrix . getRowDimension ( ) , 0 , 1 ) ; MathArrays . shuffle ( index , randomGenerator ) ; RealMatrix retval = MatrixUtils . createRealMatrix ( matrix . getRowDimension ( ) , matrix . getColumnDimension ( ) ) ; for ( int row = 0 ; row < index . length ; row ++ ) { retval . setRowVector ( row , matrix . getRowVector ( index [ row ] ) ) ; } return retval ; } \n', 0.40805029915586166)

('private Set < Integer > calculateNumberOfColumnsForPagePart ( Set < Integer > columnValues ) { Integer [ ] columnValuesArr = columnValues . toArray ( new Integer [ columnValues . size ( ) ] ) ; Arrays . sort ( columnValuesArr ) ; Set < Integer > newColumnValues = new HashSet < Integer > ( ) ; if ( columnValuesArr . length == 0 ) { return newColumnValues ; } newColumnValues . add ( columnValuesArr [ 0 ] ) ; for ( int i = 0 ; i < columnValuesArr . length - 1 ; i ++ ) { int columnDistance = Math . abs ( columnValuesArr [ i ] - columnValuesArr [ i + 1 ] ) ; if ( columnDistance > maxNeighbourColumnsOffset ) { newColumnValues . add ( columnValuesArr [ i + 1 ] ) ; } } return newColumnValues ; } \n', 0.40275531407940357)

('public static int [ ] [ ] getColumnOverlapScoresIntArray ( Region region ) { int [ ] [ ] columnOverlapScores = new int [ region . getNumberOfRowsAlongRegionYAxis ( ) ] [ region . getNumberOfColumnsAlongRegionXAxis ( ) ] ; Column [ ] [ ] columns = region . getColumns ( ) ; for ( int row = 0 ; row < columnOverlapScores . length ; row ++ ) { for ( int column = 0 ; column < columnOverlapScores [ row ] . length ; column ++ ) { columnOverlapScores [ row ] [ column ] = columns [ row ] [ column ] . getOverlapScore ( ) ; } } return columnOverlapScores ; } \n', 0.3999727634487226)

('public static ArrayList < Integer > findRowsIndicesWithMostOnes ( int [ ] [ ] matrix ) { int numberOfOnes = 0 ; int maxNumberOfOnes = 0 ; ArrayList < Integer > rowIndex = new ArrayList < > ( ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) { numberOfOnes = 0 ; for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { if ( matrix [ i ] [ j ] == 1 ) { numberOfOnes ++ ; } } if ( numberOfOnes > maxNumberOfOnes ) { maxNumberOfOnes = numberOfOnes ; rowIndex . clear ( ) ; rowIndex . add ( i ) ; } else if ( numberOfOnes == maxNumberOfOnes ) { rowIndex . add ( i ) ; } } return rowIndex ; } \n', 0.39513898494156435)

('@ SuppressWarnings ( "boxing" ) private void applyColumnWidths ( ) { Map < Integer , Double > selfWidths = new LinkedHashMap < Integer , Double > ( ) ; List < Column < ? , T >> columns = getVisibleColumns ( ) ; for ( int index = 0 ; index < columns . size ( ) ; index ++ ) { selfWidths . put ( index , columns . get ( index ) . getWidth ( ) ) ; } Grid . this . escalator . getColumnConfiguration ( ) . setColumnWidths ( selfWidths ) ; Map < Integer , Double > constrainedWidths = new LinkedHashMap < Integer , Double > ( ) ; for ( int index = 0 ; index < columns . size ( ) ; index ++ ) { Column < ? , T > column = columns . get ( index ) ; boolean hasAutoWidth = column . getWidth ( ) < 0 ; if ( ! hasAutoWidth ) { continue ; } double actualWidth = column . getWidthActual ( ) ; if ( actualWidth < getMinWidth ( column ) ) { constrainedWidths . put ( index , column . getMinimumWidth ( ) ) ; } else if ( actualWidth > getMaxWidth ( column ) ) { constrainedWidths . put ( index , column . getMaximumWidth ( ) ) ; } } Grid . this . escalator . getColumnConfiguration ( ) . setColumnWidths ( constrainedWidths ) ; } \n', 0.394341716913012)

('public float getColumnExpandRatio ( int columnIndex ) { Float r = columnExpandRatio . get ( columnIndex ) ; return r == null ? 0 : r . floatValue ( ) ; } \n', 0.3941703232057163)

('void normalizeWidths ( ) { int [ ] max = null ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Row row = ( Row ) list . get ( i ) ; if ( max == null ) { max = new int [ row . values . length ] ; } for ( int j = 0 ; j < max . length ; j ++ ) { max [ j ] = Math . max ( max [ j ] , row . sizes [ j ] + 1 ) ; } } for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Row row = ( Row ) list . get ( i ) ; row . sizes = max ; } } \n', 0.3933726499954243)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 57 #################################
('public static < T > T [ ] filter ( T [ ] array , IUnaryPredicate < T > predicate ) { T [ ] result = array ; int resultIndex = 0 ; for ( int i = 0 ; i < array . length ; ++ i ) { if ( predicate . apply ( array [ i ] ) ) { if ( result != array ) { result [ resultIndex ] = array [ i ] ; } ++ resultIndex ; } else { if ( result == array ) { result = Arrays . copyOf ( array , array . length - 1 ) ; Arrays . fill ( result , i , result . length , null ) ; } } } return resultIndex == result . length ? result : Arrays . copyOf ( result , resultIndex ) ; } \n', 0.39147638113545125)

('@ SuppressWarnings ( "unchecked" ) public Array < A > filter ( final Func < A , Boolean > f ) { List < A > x = List . nil ( ) ; for ( int i = a . length - 1 ; i >= 0 ; i -- ) { if ( f . f ( ( A ) a [ i ] ) ) x = x . cons ( ( A ) a [ i ] ) ; } return x . toArray ( ) ; } \n', 0.38781403003055476)

('@ SuppressWarnings ( "unchecked" ) public Array < A > filter ( final F < A , Boolean > f ) { List < A > x = List . nil ( ) ; for ( int i = a . length - 1 ; i >= 0 ; i -- ) { if ( f . f ( ( A ) a [ i ] ) ) x = x . cons ( ( A ) a [ i ] ) ; } return x . toArray ( ) ; } \n', 0.38781403003055476)

('protected Object filterArray ( ServerSession from , ServerChannel to , Object array ) { if ( array == null ) return null ; int length = Array . getLength ( array ) ; for ( int i = 0 ; i < length ; i ++ ) Array . set ( array , i , filter ( from , to , Array . get ( array , i ) ) ) ; return array ; } \n', 0.38764751848426726)

('protected Object filterArray ( Client from , Channel to , Object array ) { if ( array == null ) return null ; int length = Array . getLength ( array ) ; for ( int i = 0 ; i < length ; i ++ ) Array . set ( array , i , filter ( from , to , Array . get ( array , i ) ) ) ; return array ; } \n', 0.38764751848426726)

('public String [ ] filter ( String ... lang ) { List < String > langs = new LinkedList < String > ( ) ; for ( String l : lang ) { if ( matches ( l ) ) { langs . add ( l ) ; } } return langs . toArray ( new String [ langs . size ( ) ] ) ; } \n', 0.38224559748636505)

('public static String [ ] filter ( String [ ] cmds ) { List < String > list ; int i ; list = new ArrayList < > ( ) ; for ( i = 0 ; i < cmds . length ; i ++ ) list . add ( cmds [ i ] ) ; list = filter ( list ) ; return list . toArray ( new String [ list . size ( ) ] ) ; } \n', 0.38199690877047765)

('public static IWorkingSet [ ] filter ( IWorkingSet [ ] workingSets , String [ ] workingSetIds ) { ArrayList result = new ArrayList ( ) ; for ( int i = 0 ; i < workingSets . length ; i ++ ) { if ( accept ( workingSets [ i ] , workingSetIds ) ) result . add ( workingSets [ i ] ) ; } return ( IWorkingSet [ ] ) result . toArray ( new IWorkingSet [ result . size ( ) ] ) ; } \n', 0.3803944604203888)

('private String [ ] filter ( String [ ] in , ArrayList bag ) { if ( ( in == null ) || ( in . length == 0 ) ) { return null ; } String [ ] pass = new String [ in . length ] ; int to = 0 ; for ( int i = 0 ; i < in . length ; i ++ ) { if ( bag . indexOf ( in [ i ] ) >= 0 ) { pass [ to ] = in [ i ] ; to ++ ; } } String [ ] result = new String [ to ] ; System . arraycopy ( pass , 0 , result , 0 , to ) ; return result ; } \n', 0.3776776016838185)

('public static String [ ] filter ( String [ ] a , Filter f ) { ArrayList < String > filtered = new ArrayList < String > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( f . accept ( a [ i ] ) ) filtered . add ( a [ i ] ) ; } String [ ] stockArr = new String [ filtered . size ( ) ] ; stockArr = filtered . toArray ( stockArr ) ; return stockArr ; } \n', 0.37723939560660597)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 58 #################################
('public static < T > List < T > getRandomSubSelection ( List < T > sourceList , int itemsToSelect , Random random ) { int sourceSize = sourceList . size ( ) ; if ( sourceSize == 0 || itemsToSelect <= 0 || sourceSize < itemsToSelect ) { throw new IllegalArgumentException ( ) ; } int [ ] selections = new int [ itemsToSelect ] ; ArrayList < T > resultArray = new ArrayList < T > ( ) ; for ( int count = 0 ; count < itemsToSelect ; count ++ ) { int selection = random . nextInt ( sourceSize - count ) ; selections [ count ] = selection ; for ( int scanIdx = count - 1 ; scanIdx >= 0 ; scanIdx -- ) { if ( selection >= selections [ scanIdx ] ) { selection ++ ; } } resultArray . add ( sourceList . get ( selection ) ) ; } return resultArray ; } \n', 0.4434597313271613)

('public static List < MemoryViewFlipper > getRandomViewFlipperList ( List < DTOTranslation > translations , Context context ) { List < MemoryViewFlipper > initialList = generateViewFlippers ( translations , context ) ; List < MemoryViewFlipper > randomList = new ArrayList < MemoryViewFlipper > ( ) ; if ( initialList == null ) return null ; int listSize = initialList . size ( ) ; Random random = new Random ( ) ; for ( int i = listSize ; i > 0 ; i -- ) { int index = random . nextInt ( i ) ; randomList . add ( initialList . get ( index ) ) ; initialList . remove ( index ) ; } return randomList ; } \n', 0.4395571018689662)

('protected boolean sampleOtherItem ( SampleTriple triple ) { boolean itemIsPositive = feedback . userMatrix ( ) . get ( triple . u , triple . i ) ; if ( fastSampling ) { if ( itemIsPositive ) { int rindex = random . nextInt ( userNegItems . get ( triple . u ) . length ) ; triple . j = userNegItems . get ( triple . u ) [ rindex ] ; } else { int rindex = random . nextInt ( userPosItems . get ( triple . u ) . length ) ; triple . j = userPosItems . get ( triple . u ) [ rindex ] ; } } else { do triple . j = random . nextInt ( maxItemID + 1 ) ; while ( feedback . userMatrix ( ) . get ( triple . u , triple . j ) != itemIsPositive ) ; } return itemIsPositive ; } \n', 0.41999362930040773)

('public static < T > T nextItem ( List < T > items , Random random ) { int randomIndex = random . nextInt ( items . size ( ) ) ; return items . get ( randomIndex ) ; } \n', 0.4196195414395486)

('private List < Long > retrieveNonRatedItems ( UserGroup theUserGroup , Integer theItemsToRetrieve ) throws TasteException { Set < Long > tmpRatedItemsByAnyUser = new HashSet < Long > ( this . _userGroupDAO . getAllRatedItems ( theUserGroup . get_id ( ) ) ) ; List < Long > tmpResult = new ArrayList < Long > ( ) ; boolean isEnd = false ; Long tmpRandomItemId ; Integer tmpAttempts = 0 ; Random generator = new Random ( 19580427 ) ; int range = this . _trainModel . getNumItems ( ) - 1 + 1 ; while ( ! isEnd ) { tmpRandomItemId = new Long ( generator . nextInt ( range ) + 1 ) ; if ( ! tmpRatedItemsByAnyUser . contains ( tmpRandomItemId ) ) { tmpResult . add ( tmpRandomItemId ) ; } tmpAttempts ++ ; isEnd = ( tmpResult . size ( ) == theItemsToRetrieve ) || ( tmpAttempts > MAX_RANDOM_ATTEMPTS ) ; } return tmpResult ; } \n', 0.4186417928675368)

('public static List < ItemAllocatable > getRandomItemFromContainer ( InventoryHolder inventory , Random rand , Block block , List < AllocatorBlock > alLst , Allocator thePlugin ) { List < ItemAllocatable > items = new ArrayList < ItemAllocatable > ( ) ; if ( inventory == null ) { return items ; } int startAt = 0 ; List < ItemStack > itemsTemp = new ArrayList < ItemStack > ( ) ; if ( inventory instanceof Furnace ) { startAt = 2 ; } for ( int k = startAt ; k < inventory . getInventory ( ) . getSize ( ) ; k ++ ) { if ( inventory . getInventory ( ) . getItem ( k ) != null ) { boolean passingFilter = true ; for ( Iterator < AllocatorBlock > iterator = alLst . iterator ( ) ; passingFilter && iterator . hasNext ( ) ; ) { passingFilter = iterator . next ( ) . isPassingFilter ( inventory . getInventory ( ) . getItem ( k ) ) ; } if ( passingFilter ) { itemsTemp . add ( inventory . getInventory ( ) . getItem ( k ) ) ; } } } while ( ! itemsTemp . isEmpty ( ) ) { int r = ( int ) Math . floor ( Math . random ( ) * itemsTemp . size ( ) ) ; items . add ( new ItemAllocatableFromInventory ( itemsTemp . get ( r ) , inventory ) ) ; itemsTemp . remove ( r ) ; } return items ; } \n', 0.4183443039123915)

('public T nextItem ( ) { ItemPair item_pair = item_pairs . get ( random . nextInt ( item_pairs . size ( ) ) ) ; if ( random . nextDouble ( ) < item_pair . weight ) return item_pair . light ; return item_pair . heavy ; } \n', 0.41690565497608506)

('public E nextItem ( ) { if ( items . size ( ) == 0 ) resetItems ( ) ; E next = lastItemSeen ; while ( next == lastItemSeen ) next = items . get ( rand . nextInt ( items . size ( ) ) ) ; lastItemSeen = next ; items . remove ( lastItemSeen ) ; return next ; } \n', 0.4151187116683032)

('public void addAllItem ( ) { input = new Scanner ( System . in ) ; System . out . println ( "how-many-item-" ) ; numOfItem = input . nextInt ( ) ; System . out . println ( ) ; item = new String [ numOfItem ] ; price = new double [ numOfItem ] ; for ( int i = 0 ; i < numOfItem ; i ++ ) { System . out . println ( "key-in-the-item-name" ) ; String itemName = input . next ( ) ; item [ i ] = itemName ; System . out . println ( ) ; System . out . println ( "key-in-the-price-for-" + itemName ) ; price [ i ] = input . nextDouble ( ) ; } } \n', 0.41501401005391647)

('private void nextCategory ( boolean [ ] selectedCategories ) { boolean random = false ; if ( shufflePlugin != null ) { random = shufflePlugin . getRandom ( ) ; } if ( random ) { do { currentCategory = vocabularies . getCategory ( r . nextInt ( vocabularies . getCategories ( ) . size ( ) ) ) ; } while ( ! selectedCategories [ vocabularies . getCategoryIndex ( currentCategory ) + 1 ] ) ; } else { do { currentCategory = vocabularies . getCategory ( ( vocabularies . getCategoryIndex ( currentCategory ) + 1 ) % vocabularies . getCategories ( ) . size ( ) ) ; } while ( ! selectedCategories [ vocabularies . getCategoryIndex ( currentCategory ) + 1 ] ) ; } } \n', 0.4129497784511546)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 59 #################################
('private String generateCookie ( ) { byte [ ] cookie = new byte [ 32 ] ; new SecureRandom ( ) . nextBytes ( cookie ) ; return Util . toHexString ( cookie ) ; } \n', 0.38749831593612566)

('public static String crypt ( ByteSequence password ) throws NoSuchAlgorithmException { SecureRandom randomGenerator = new SecureRandom ( ) ; StringBuilder salt = new StringBuilder ( ) ; while ( salt . length ( ) < saltLength ) { int index = ( int ) ( randomGenerator . nextFloat ( ) * itoa64 . length ( ) ) ; salt . append ( itoa64 . charAt ( index ) ) ; } return BSDMD5Crypt . crypt ( password , salt . toString ( ) ) ; } \n', 0.3807757941999787)

('private final String generateRobotCookie ( ) { byte [ ] rnd = new byte [ 16 ] ; rand . nextBytes ( rnd ) ; char [ ] rndChars = new char [ 2 * 16 ] ; int ic = 0 ; for ( int i = 0 ; i < 16 ; ++ i ) { final int byt = rnd [ i ] & 0xFF ; rndChars [ ic ] = GENERATEROBOTCOOKIE_HEX [ byt >>> 4 ] ; ++ ic ; rndChars [ ic ] = GENERATEROBOTCOOKIE_HEX [ byt & 0x0F ] ; ++ ic ; } return new String ( rndChars ) ; } \n', 0.37923307516091015)

('private static byte [ ] readPasswordFromHex ( String hexPassword ) { byte [ ] passwordBytes = new byte [ hexPassword . length ( ) / 2 ] ; for ( int i = 0 ; i < passwordBytes . length ; i ++ ) { passwordBytes [ i ] = ( byte ) Integer . parseInt ( hexPassword . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; } return passwordBytes ; } \n', 0.3782992816829938)

('private static void macLengthInput ( ) { String instructions = "Por-favor,-digite-um-tamanho-para-MAC-(entre-64-e-96---em-bits):-" ; boolean validValue = false ; System . out . print ( instructions ) ; while ( ! validValue ) { try { lineRead = reader . readLine ( ) . trim ( ) ; int intValue = new Integer ( lineRead ) ; if ( 64 <= intValue && intValue <= 96 ) { macLength = intValue ; validValue = true ; } else { System . out . print ( "Valor-invalido.-" + instructions ) ; } } catch ( Exception e ) { System . out . print ( "Valor-invalido.-" + instructions ) ; } } } \n', 0.3764215282198158)

('protected String passwordAsHexString ( String password ) { MessageDigest digest = null ; try { digest = MessageDigest . getInstance ( "SHA-256" ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } byte [ ] hash = digest . digest ( password . getBytes ( StandardCharsets . UTF_8 ) ) ; StringBuilder hexString = new StringBuilder ( ) ; for ( int i = 0 ; i < hash . length ; i ++ ) { String hex = Integer . toHexString ( 0xff & hash [ i ] ) ; if ( hex . length ( ) == 1 ) hexString . append ( \'0\' ) ; hexString . append ( hex ) ; } return hexString . toString ( ) ; } \n', 0.3749689803370507)

('protected String getNewCookieSession ( ) { return "Waarp" + Long . toHexString ( random . nextLong ( ) ) ; } \n', 0.37489748935117867)

('public static byte [ ] computeCramMd5Bytes ( String username , String password , byte [ ] b64Nonce ) throws MessagingException { try { byte [ ] nonce = Base64 . decodeBase64 ( b64Nonce ) ; byte [ ] secretBytes = password . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; if ( secretBytes . length > 64 ) { secretBytes = md . digest ( secretBytes ) ; } byte [ ] ipad = new byte [ 64 ] ; byte [ ] opad = new byte [ 64 ] ; System . arraycopy ( secretBytes , 0 , ipad , 0 , secretBytes . length ) ; System . arraycopy ( secretBytes , 0 , opad , 0 , secretBytes . length ) ; for ( int i = 0 ; i < ipad . length ; i ++ ) ipad [ i ] ^= 0x36 ; for ( int i = 0 ; i < opad . length ; i ++ ) opad [ i ] ^= 0x5c ; md . update ( ipad ) ; byte [ ] firstPass = md . digest ( nonce ) ; md . update ( opad ) ; byte [ ] result = md . digest ( firstPass ) ; String plainCRAM = username + "-" + new String ( Hex . encodeHex ( result ) ) ; byte [ ] b64CRAM = Base64 . encodeBase64 ( plainCRAM . getBytes ( ) ) ; return b64CRAM ; } catch ( Exception e ) { throw new MessagingException ( "Something-went-wrong-during-CRAM-MD5-computation" , e ) ; } } \n', 0.3742729075239891)

('RandomCookie ( HandshakeInStream m ) throws IOException { random_bytes = new byte [ 32 ] ; m . read ( random_bytes , 0 , 32 ) ; } \n', 0.3740005987145777)

('public final byte [ ] doLanManBaseEncryption ( String pwd ) throws NoSuchAlgorithmException { byte [ ] s8 = new String ( "KGS!@#$%" ) . getBytes ( ) ; return P16 ( pwd , s8 ) ; } \n', 0.37375636990435257)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 60 #################################
('private static void validationElementIDWithUnique ( List < Integer > ids , ValidationResult results ) { Set < Integer > idSet = new HashSet < Integer > ( ) ; idSet . addAll ( ids ) ; if ( idSet . size ( ) != ids . size ( ) ) { results . add ( ValidationResult . RULE_ID_FAILED_DUPLICATE ) ; } } \n', 0.36538050268632516)

('public static int hashCode ( final Element element ) { return element . id ( ) . hashCode ( ) ; } \n', 0.36052594265448257)

('public static < T > T unique ( Iterable < T > source , T defaultElement ) { T element = defaultElement ; if ( source != null ) { Iterator < T > i = source . iterator ( ) ; if ( i . hasNext ( ) ) { element = i . next ( ) ; if ( i . hasNext ( ) ) { throw new IllegalStateException ( "Element-not-unique!" ) ; } } } return element ; } \n', 0.36046622505783954)

('private List < Element > sortById ( List < Element > selectNodes ) { int n = selectNodes . size ( ) ; do { int newn = 0 ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { int id1 = Integer . parseInt ( selectNodes . get ( i ) . getAttributeValue ( "id" ) ) ; int id2 = Integer . parseInt ( selectNodes . get ( i + 1 ) . getAttributeValue ( "id" ) ) ; if ( id1 > id2 ) { Element t = selectNodes . get ( i ) ; selectNodes . set ( i , selectNodes . get ( i + 1 ) ) ; selectNodes . set ( i + 1 , t ) ; } } n = newn ; } while ( n > 1 ) ; return selectNodes ; } \n', 0.35912672600768347)

('private List < Long > getUniqueDocumentIds ( List < Long > DocumentIds ) { Set < Long > uniqueDocumentRef = new HashSet < Long > ( DocumentIds ) ; DocumentIds . clear ( ) ; DocumentIds . addAll ( uniqueDocumentRef ) ; return DocumentIds ; } \n', 0.35736222766907877)

('public UniqueIdentifierAttribute ( AttributeTag t , Long vl , DicomInputStream i ) throws IOException , DicomException { super ( t , vl . longValue ( ) , i ) ; } \n', 0.35345995220995646)

('static Collection < BiologicalContext > getUniqueContextsIgnoreId ( Collection < BiologicalContext > contexts ) { try { Collection c = contexts . getClass ( ) . newInstance ( ) ; return c ; } catch ( Exception e ) { return null ; } } \n', 0.3526600016303919)

('public void removeUnique ( int i ) { synchronized ( monitor ( ) ) { check_orphaned ( ) ; get_store ( ) . remove_element ( UNIQUE$4 , i ) ; } } \n', 0.3511213448555555)

('public static < T > List < T > unique ( List < T > list ) { ArrayList < T > result = new ArrayList < T > ( ) ; for ( T element : list ) { if ( ! result . contains ( element ) ) { result . add ( element ) ; } } return result ; } \n', 0.35008691193368335)

('public int hashCode ( ) { int hash = attrID . hashCode ( ) ; int num = values . size ( ) ; Object val ; for ( int i = 0 ; i < num ; i ++ ) { val = values . elementAt ( i ) ; if ( val != null ) { if ( val . getClass ( ) . isArray ( ) ) { Object it ; int len = Array . getLength ( val ) ; for ( int j = 0 ; j < len ; j ++ ) { it = Array . get ( val , j ) ; if ( it != null ) { hash += it . hashCode ( ) ; } } } else { hash += val . hashCode ( ) ; } } } return hash ; } \n', 0.3495746003333009)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 61 #################################
('public static double [ ] normalizeSamples ( double [ ] samples_to_normalize ) { double [ ] normalized_samples = new double [ samples_to_normalize . length ] ; for ( int samp = 0 ; samp < normalized_samples . length ; samp ++ ) normalized_samples [ samp ] = samples_to_normalize [ samp ] ; double max_sample_value = 0.0 ; for ( int samp = 0 ; samp < normalized_samples . length ; samp ++ ) if ( Math . abs ( normalized_samples [ samp ] ) > max_sample_value ) max_sample_value = Math . abs ( normalized_samples [ samp ] ) ; if ( max_sample_value != 0.0 ) for ( int samp = 0 ; samp < normalized_samples . length ; samp ++ ) normalized_samples [ samp ] /= max_sample_value ; return normalized_samples ; } \n', 0.416073994389983)

('public static double [ ] [ ] normalizeSamples ( double [ ] [ ] samples_to_normalize ) { double [ ] [ ] normalized_samples = new double [ samples_to_normalize . length ] [ samples_to_normalize [ 0 ] . length ] ; for ( int chan = 0 ; chan < normalized_samples . length ; chan ++ ) for ( int samp = 0 ; samp < normalized_samples [ chan ] . length ; samp ++ ) normalized_samples [ chan ] [ samp ] = samples_to_normalize [ chan ] [ samp ] ; double max_sample_value = 0.0 ; for ( int chan = 0 ; chan < normalized_samples . length ; chan ++ ) for ( int samp = 0 ; samp < normalized_samples [ chan ] . length ; samp ++ ) if ( Math . abs ( normalized_samples [ chan ] [ samp ] ) > max_sample_value ) max_sample_value = Math . abs ( normalized_samples [ chan ] [ samp ] ) ; if ( max_sample_value != 0.0 ) for ( int chan = 0 ; chan < normalized_samples . length ; chan ++ ) for ( int samp = 0 ; samp < normalized_samples [ chan ] . length ; samp ++ ) normalized_samples [ chan ] [ samp ] /= max_sample_value ; return normalized_samples ; } \n', 0.41518705229548325)

('public static Matrix deserializeMatrix ( File f ) throws IOException { BufferedReader input = null ; Matrix m = null ; int r = 0 ; int c = 0 ; input = new BufferedReader ( new FileReader ( f ) ) ; String line = null ; while ( ( line = input . readLine ( ) ) != null ) { for ( String row : line . split ( ";" ) ) { if ( ! row . trim ( ) . isEmpty ( ) ) { c = 0 ; for ( String e : row . split ( "," ) ) { if ( m == null ) { m = MatrixFactory . createMatrix ( line . split ( ";" ) . length , row . split ( "," ) . length ) ; } m . set ( r , c , Double . valueOf ( e ) ) ; c ++ ; } } r ++ ; } } return m ; } \n', 0.4042568052540027)

('public static String doubleMatrixToString ( double [ ] [ ] matrix ) { StringBuilder strBuilder = new StringBuilder ( "" ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) { for ( int j = 0 ; j < matrix [ i ] . length ; j ++ ) { strBuilder . append ( Utils . round ( matrix [ i ] [ j ] , 2 ) + "-" ) ; } strBuilder . append ( "-" ) ; } return strBuilder . toString ( ) ; } \n', 0.40260985161493673)

('public void normalizeMatrix ( RealMatrix matrix ) { int m = matrix . getRowDimension ( ) ; int n = matrix . getColumnDimension ( ) ; for ( int i = 0 ; i < m ; i ++ ) { RealMatrix subMatrix = matrix . getSubMatrix ( i , i , 0 , n - 1 ) ; double sum = norm1 ( subMatrix ) / n ; for ( int j = 0 ; j < n ; j ++ ) { subMatrix . addToEntry ( 0 , j , - 1.0 * sum ) ; } double std = norm1 ( arrayTimes ( subMatrix , subMatrix ) ) / n ; timesEquals ( subMatrix , 1.0 / std ) ; for ( int j = 0 ; j < n ; j ++ ) { matrix . setEntry ( i , j , subMatrix . getEntry ( 0 , j ) ) ; } } } \n', 0.3996197561081591)

('Array2DRowRealMatrix ArrayToRealMatrix ( ArrayList < float [ ] > lst , int size ) { int length = lst . get ( 1 ) . length ; Array2DRowRealMatrix ret = new Array2DRowRealMatrix ( size , length ) ; int i = 0 ; for ( i = 0 ; i < size ; i ++ ) { double [ ] converted = new double [ length ] ; for ( int j = 0 ; j < length ; j ++ ) converted [ j ] = ( ( lst . get ( i ) ) [ j ] ) ; ret . setRow ( i , converted ) ; } return ret ; } \n', 0.39941209096828567)

('public static void normalizeMatrix ( float [ ] [ ] matrix ) { for ( int i = 0 ; i < matrix . length ; i ++ ) { float sum = 0 ; for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { sum += matrix [ i ] [ j ] ; } for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { if ( Math . abs ( matrix [ i ] [ j ] ) > 0.0001 ) matrix [ i ] [ j ] = matrix [ i ] [ j ] / sum ; } } } \n', 0.39799607461787556)

('public static String matrixToNumbers ( int [ ] [ ] matrix ) { int cols = matrix [ 0 ] . length ; int rows = matrix . length ; StringBuilder sb = new StringBuilder ( 3 * cols * rows ) ; sb . append ( "|begin{tikzpicture}-" ) ; sb . append ( "|matrix-[matrix-of-math-nodes,left-delimiter=(,right-delimiter=),-ampersand-replacement=|&]-(m)-" ) ; sb . append ( "{-" ) ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { sb . append ( matrix [ i ] [ j ] + "-|&-" ) ; } sb . append ( "||-" ) ; } sb . append ( "};-" ) ; return sb . toString ( ) ; } \n', 0.3979793117054432)

('public static Matrix toMatrix ( String string , int rows , int columns ) throws IOException { Matrix m = new Matrix ( rows , columns ) ; BufferedReader reader = new BufferedReader ( new StringReader ( string ) ) ; String rowString = reader . readLine ( ) ; int row = 0 ; while ( rowString != null ) { String [ ] values = rowString . trim ( ) . split ( "|s+" ) ; for ( int column = 0 ; column < values . length ; column ++ ) { m . set ( row , column , Double . parseDouble ( values [ column ] ) ) ; } row ++ ; rowString = reader . readLine ( ) ; } return m ; } \n', 0.39599942855398607)

('@ Override public String toMatrixMarket ( NumberFormat formatter ) { StringBuilder out = new StringBuilder ( ) ; out . append ( "%%MatrixMarket-matrix-array-real-general-" ) ; out . append ( rows ) . append ( \'-\' ) . append ( columns ) . append ( \'|n\' ) ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) { out . append ( formatter . format ( get ( i , j ) ) ) . append ( \'|n\' ) ; } } return out . toString ( ) ; } \n', 0.39471782266611516)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 62 #################################
('public static String htmlEscapeAllowEntities ( String text ) { StringBuilder escaped = new StringBuilder ( ) ; boolean firstSegment = true ; for ( String segment : text . split ( "&" , - 1 ) ) { if ( firstSegment ) { firstSegment = false ; escaped . append ( htmlEscape ( segment ) ) ; continue ; } int entityEnd = segment . indexOf ( \';\' ) ; if ( entityEnd > 0 && segment . substring ( 0 , entityEnd ) . matches ( HTML_ENTITY_REGEX ) ) { escaped . append ( "&" ) . append ( segment . substring ( 0 , entityEnd + 1 ) ) ; escaped . append ( htmlEscape ( segment . substring ( entityEnd + 1 ) ) ) ; } else { escaped . append ( "&amp;" ) . append ( htmlEscape ( segment ) ) ; } } return escaped . toString ( ) ; } \n', 0.42727888843847994)

("public static void escapeEntity ( String xmlEntity , StringBuffer sb ) { sb . append ( '&' ) ; sb . append ( xmlEntity ) ; sb . append ( ';' ) ; } \n", 0.4167108794376929)

('public static RawData escapeHtml ( Object o ) { return escapeHTML ( o ) ; } \n', 0.41458440169359856)

('public static String escapeHtmlForJavaScript ( String html ) { html = html . replaceAll ( """ , "||"" ) ; html = html . replaceAll ( "-" , "||t" ) ; html = html . replaceAll ( "-" , "||n" ) ; html = html . replaceAll ( "-" , "||r" ) ; html = html . replaceAll ( HtmlElement . endl , "||n" ) ; return html ; } \n', 0.4144788761970079)

("public static void escapeEntity ( String xmlEntity , StringBuilder sb ) { sb . append ( '&' ) ; sb . append ( xmlEntity ) ; sb . append ( ';' ) ; } \n", 0.40980327903770425)

('public static String htmlEscapeAllowEntities ( String text ) { StringBuilder escaped = new StringBuilder ( ) ; boolean firstSegment = true ; for ( String segment : text . split ( "&" , - 1 ) ) { if ( firstSegment ) { firstSegment = false ; escaped . append ( htmlEscape ( segment ) ) ; continue ; } int entityEnd = segment . indexOf ( \';\' ) ; if ( entityEnd > 0 && segment . substring ( 0 , entityEnd ) . matches ( HTML_ENTITY_REGEX ) ) { escaped . append ( "&" ) . append ( segment . substring ( 0 , entityEnd + 1 ) ) ; escaped . append ( htmlEscape ( segment . substring ( entityEnd + 1 ) ) ) ; } else { escaped . append ( "&amp;" ) . append ( htmlEscape ( segment ) ) ; } } return escaped . toString ( ) ; } \n', 0.40953367441935956)

('public static String escapeMarkupToEntity ( String input ) { if ( input == null ) return null ; int len = input . length ( ) ; StringBuffer sb = new StringBuffer ( ) ; int slash = 0 ; int currLen ; boolean odd ; for ( int idx = 0 ; idx < len ; idx ++ ) { char c = input . charAt ( idx ) ; if ( c == \'|\' ) { slash ++ ; sb . append ( c ) ; continue ; } odd = processDoubleSlash ( sb , slash ) ; if ( StringUtils . contains ( FilterRegxConstants . FILTER_KEYWORD + ">" , c ) && odd ) { currLen = sb . length ( ) ; sb . deleteCharAt ( currLen - 1 ) ; sb . append ( EscapeUtil . toEntity ( c ) ) ; } else sb . append ( c ) ; slash = 0 ; } if ( slash > 0 ) { odd = processDoubleSlash ( sb , slash ) ; if ( odd ) { currLen = sb . length ( ) ; sb . deleteCharAt ( currLen - 1 ) ; sb . append ( ENTITY_SLASH ) ; } } return sb . toString ( ) ; } \n', 0.40949937168924955)

('protected static String escapeToXMLAttrib ( String s ) { return s . replaceAll ( "-" , "" ) . replaceAll ( "-|s+" , "" ) ; } \n', 0.40936464643598847)

('public static String escapeProblemHtmlCharacters ( String string , String secondaryReplacementString ) { String [ ] charactersToReplace = { "<p>" , "</p>" , "<br>" , "<li>" , "</li>" , "<ul>" , "</ul>" , "<br/>" , "<h1>" , "</h1>" , "<h2>" , "</h2>" , "<h3>" , "</h3>" , "<h4>" , "</h4>" , "-" } ; String [ ] replacementCharacters = { "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" } ; string = nullToBlank ( string ) ; secondaryReplacementString = nullToBlank ( secondaryReplacementString ) ; string = blankToString ( string , secondaryReplacementString ) ; for ( int i = 0 ; i < charactersToReplace . length ; i ++ ) { string = replace ( string , charactersToReplace [ i ] , replacementCharacters [ i ] ) ; } return string ; } \n', 0.4075402221432307)

('protected String escapeHtmlEntities ( CharSequence orig ) { StringBuffer buff = new StringBuffer ( orig ) ; EntityTable defaultEntityTable = EntityTable . getDefaultEntityTable ( ) ; Matcher matcher = Pattern . compile ( "|&|w+|;" ) . matcher ( orig ) ; int delta = 0 ; while ( matcher . find ( ) ) { String name = matcher . group ( ) . substring ( 0 , matcher . group ( ) . length ( ) - 1 ) ; int code = defaultEntityTable . entityCode ( name ) ; if ( 0 != code ) { String replacement = "&#" + code + ";" ; buff . replace ( matcher . start ( ) - delta , matcher . end ( ) - delta , replacement ) ; delta = delta + matcher . group ( ) . length ( ) - replacement . length ( ) ; } } return buff . toString ( ) ; } \n', 0.40569205517143747)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 63 #################################
('public static String convertJSONToXML ( String rawJSON , String rootName , String encoding ) { XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( rawJSON ) ; serializer . setRootName ( rootName ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json , encoding ) ; return xml ; } \n', 0.4520262156989096)

('public static String convertAmeticJSONToXML ( String rawJSON , String encoding ) { String jsonData = fixDateFormats ( rawJSON ) ; XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( jsonData ) ; serializer . setRootName ( "AmeticEvent" ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json , encoding ) ; return xml ; } \n', 0.44469413235706723)

('public static String jsonToXml ( String xmlString , String rootElement ) throws Exception { try { JSONObject jso = new JSONObject ( xmlString ) ; rootElement = Val . chkStr ( rootElement ) ; if ( "" . equals ( rootElement ) ) { rootElement = "gptJsonXml" ; } String xml = XML . toString ( jso , "gptJsonXml" ) ; StreamSource source = new StreamSource ( new StringReader ( xml ) ) ; StringWriter writer = new StringWriter ( ) ; StreamResult result = new StreamResult ( writer ) ; Transformer transformer = TransformerFactory . newInstance ( ) . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . ENCODING , "UTF-8" ) ; transformer . setOutputProperty ( OutputKeys . INDENT , "yes" ) ; transformer . transform ( source , result ) ; return Val . chkStr ( writer . toString ( ) ) ; } catch ( Exception e ) { throw e ; } } \n', 0.44160544192714646)

('public static JSONObject xmlToJSON ( String xml ) { return ( ( JSONObject ) new XMLSerializer ( ) . read ( xml ) ) ; } \n', 0.4410089235442416)

('private JSON xmlToJson ( String xml ) throws JSONException { XMLSerializer xmlSerializer = new XMLSerializer ( ) ; xmlSerializer . setRemoveNamespacePrefixFromElements ( true ) ; xmlSerializer . setSkipNamespaces ( true ) ; return xmlSerializer . read ( xml ) ; } \n', 0.4357251399372226)

('private static String serializeDocumentInt ( Document doc ) throws TransformerException , IOException { ByteArrayOutputStream s = new ByteArrayOutputStream ( ) ; TransformerFactory factory = TransformerFactory . newInstance ( ) ; Transformer transformer = factory . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . METHOD , "xml" ) ; transformer . setOutputProperty ( OutputKeys . INDENT , "yes" ) ; DOMSource source = new DOMSource ( doc ) ; StreamResult outputTarget = new StreamResult ( s ) ; transformer . transform ( source , outputTarget ) ; return s . toString ( "UTF8" ) ; } \n', 0.4355217484763406)

('@ Deprecated private String ConvertToXML ( String jsonData ) { XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( jsonData ) ; serializer . setRootName ( "xmlOutput" ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json ) ; return xml ; } \n', 0.43323196962330557)

('@ Deprecated public String ConvertToXML ( String jsonData ) { XMLSerializer serializer = new XMLSerializer ( ) ; JSON json = JSONSerializer . toJSON ( jsonData ) ; serializer . setRootName ( "xmlOutput" ) ; serializer . setTypeHintsEnabled ( false ) ; String xml = serializer . write ( json ) ; return xml ; } \n', 0.43323196962330557)

('public boolean marshalSingleValue ( XPathFragment xPathFragment , MarshalRecord marshalRecord , Object object , Object value , CoreAbstractSession session , NamespaceResolver namespaceResolver , MarshalContext marshalContext ) { if ( value instanceof Node ) { marshalRecord . node ( ( org . w3c . dom . Node ) value , namespaceResolver ) ; } return true ; } \n', 0.43207362095438656)

('public String convertExtendedDataSchemaTypeToString ( EDataType eDataType , Object instanceValue ) { return instanceValue == null ? null : instanceValue . toString ( ) ; } \n', 0.42786353912445263)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 64 #################################
('static String urlEncode ( String filename ) { try { return URLEncoder . encode ( filename , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( "UTF-8-charset-not-available-("this-should-never-happen")" , e ) ; } } \n', 0.45336814697519745)

('private static String urlEncode ( String source ) { try { return URLEncoder . encode ( source , Charsets . UTF_8 . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( "Unsupported-charset-(UTF-8)." , e ) ; } } \n', 0.4475508042801667)

('public static String urlEncode ( String str ) { try { return URLEncoder . encode ( str , Charsets . UTF_8 . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { return str ; } } \n', 0.4472848651582435)

('public static String urlEncode ( String value ) { try { return URLEncoder . encode ( value , Charsets . UTF_8 . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { return value ; } } \n', 0.44532310042932566)

('public static String urlEncode ( String s ) { try { return URLEncoder . encode ( s , StandardCharsets . UTF_8 . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( "get-a-jdk-that-actually-supports-utf-8" , e ) ; } } \n', 0.4431191350546038)

('public static String urlEncode ( final String str ) { try { return URLEncoder . encode ( str , Charsets . UTF_8 . name ( ) ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } \n', 0.4424064114407877)

('public static String urlEncode ( String value ) { if ( value == null ) { return "" ; } try { return URLEncoder . encode ( value , CharEncoding . UTF_8 ) ; } catch ( UnsupportedEncodingException ex ) { throw new RuntimeException ( ex ) ; } } \n', 0.44189882521155727)

('public static String urlEncode ( String s , String format ) { String encodedString = s ; if ( s != null ) { try { encodedString = URLEncoder . encode ( s , format ) ; } catch ( UnsupportedEncodingException e ) { encodedString = s ; } } return encodedString ; } \n', 0.4418923042367976)

('public static String urlEncode ( String url , String charset ) { try { return URLEncoder . encode ( url , charset ) ; } catch ( UnsupportedEncodingException uee ) { try { return URLEncoder . encode ( url , "us-ascii" ) ; } catch ( UnsupportedEncodingException uee2 ) { log . error ( "URL-could-not-be-encoded!-This-should-NOT-happen!!!" ) ; return url ; } } } \n', 0.4416388855880166)

('public static String urlEncode ( String str ) throws UnsupportedEncodingException { if ( str == null ) { return null ; } else { return URLEncoder . encode ( str , CHARSET ) ; } } \n', 0.4416388855880166)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 65 #################################
('public Vec4 [ ] clip ( Vec4 pa , Vec4 pb ) { if ( pa == null || pb == null ) { throw new IllegalArgumentException ( "Point-Is-Null" ) ; } if ( pa . equals ( pb ) ) return null ; Line line = Line . fromSegment ( pa , pb ) ; double ldotv = this . n . dot3 ( line . getDirection ( ) ) ; if ( ldotv == 0 ) { double ldots = this . n . dot4 ( line . getOrigin ( ) ) ; if ( ldots == 0 ) return new Vec4 [ ] { pa , pb } ; else return null ; } double t = - this . n . dot4 ( line . getOrigin ( ) ) / ldotv ; if ( t < 0 || t > 1 ) return null ; Vec4 p = line . getPointAt ( t ) ; if ( ldotv > 0 ) return new Vec4 [ ] { p , pb } ; else return new Vec4 [ ] { pa , p } ; } \n', 0.35866611522374847)

('public boolean hitObject ( Object object , DrawInfo2D info ) { final double SLOP = 1.0 ; Rectangle2D . Double rect = new Rectangle2D . Double ( ) ; Shape shape = new Ellipse2D . Double ( info . draw . x - radius * info . draw . width , info . draw . y - radius * info . draw . height , 2 * radius * info . draw . width , 2 * radius * info . draw . height ) ; return ( shape . intersects ( info . clip . x , info . clip . y , info . clip . width , info . clip . height ) ) ; } \n', 0.3583966838592545)

('Point ( final List < Double > coordinates ) { this . coordinates . addAll ( coordinates ) ; } \n', 0.35613504631197057)

('public Point [ ] findLeftAndRightAngles ( Point p ) { Point leftest ; Point rightest ; if ( src . getDirection ( p ) < src . getDirection ( p . getRight ( ) ) ) { leftest = p ; rightest = p . getRight ( ) ; } else { leftest = p . getRight ( ) ; rightest = p ; } if ( anglesCrossoverDirectionLoop ( p ) ) { Point q = leftest ; leftest = rightest ; rightest = q ; } Point [ ] result = { leftest , rightest } ; return result ; } \n', 0.35590520221723293)

('public int virtualToRealPosition ( char contributor , int v ) { if ( fAllDiffs == null ) return v ; int virtualPos = 0 ; int viewPos = 0 ; Point region = new Point ( 0 , 0 ) ; Iterator e = fAllDiffs . iterator ( ) ; while ( e . hasNext ( ) ) { Diff diff = ( Diff ) e . next ( ) ; Position pos = diff . getPosition ( contributor ) ; int viewHeight = getLineRange ( getDocument ( contributor ) , pos , region ) . y ; int virtualHeight = diff . getMaxDiffHeight ( ) ; if ( v < ( virtualPos + virtualHeight ) ) { v -= virtualPos ; if ( viewHeight <= 0 ) { v = 0 ; } else { v = ( int ) ( v * ( ( double ) viewHeight / virtualHeight ) ) ; } return viewPos + v ; } virtualPos += virtualHeight ; viewPos += viewHeight ; } return viewPos ; } \n', 0.3557488606852106)

('public static List < Fireball > spawnFireballAtFrom ( Location target , Location source , int jitter , int count , int power ) { Random r = new Random ( ) ; List < Fireball > fireballs = new ArrayList < Fireball > ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Location l = source . clone ( ) . add ( r . nextInt ( jitter * 2 ) - jitter , r . nextInt ( jitter * 2 ) - jitter , r . nextInt ( jitter * 2 ) - jitter ) ; Vector v = target . toVector ( ) . subtract ( l . toVector ( ) ) . normalize ( ) ; Fireball fireball = l . getWorld ( ) . spawn ( l , Fireball . class ) ; fireball . setDirection ( v ) ; fireball . setYield ( power ) ; fireballs . add ( fireball ) ; } return fireballs ; } \n', 0.35571842272321186)

('public boolean hitObject ( Object object , DrawInfo2D info ) { if ( lastPos == null ) return false ; for ( int i = 0 ; i < numLinks ; i ++ ) if ( lastPos [ i ] != null ) { Ellipse2D . Double ellipse = new Ellipse2D . Double ( info . draw . x + info . draw . width * ( lastPos [ i ] . x - lastPos [ 0 ] . x ) , info . draw . y + info . draw . height * ( lastPos [ i ] . y - lastPos [ 0 ] . y ) , info . draw . width , info . draw . height ) ; if ( ellipse . intersects ( info . clip . x , info . clip . y , info . clip . width , info . clip . height ) ) { return true ; } } return false ; } \n', 0.3552069196305743)

('public static int onWhichSide ( double x1 , double y1 , double tangent , double x3 , double y3 ) { double A , B , C ; if ( Math . abs ( tangent - Math . PI / 2 ) < Geometry . EPSILON || Math . abs ( tangent - ( Math . PI + Math . PI / 2 ) ) < Geometry . EPSILON ) { A = x1 ; B = 0.0 ; C = 0.0 ; } else { A = Math . tan ( tangent ) ; B = - 1.0 ; C = y1 - A * x1 ; } return ( A * x3 + B * y3 + C ) > 0.0 ? 1 : - 1 ; } \n', 0.35504373522132077)

('public static void locateRelativeTo ( Component base , Window window ) { Point p = new Point ( 0 , 0 ) ; SwingUtilities . convertPointToScreen ( p , base ) ; window . setLocation ( p ) ; } \n', 0.35403278503867375)

('private Direction determineDirection ( MouseEvent currentPos , MouseEvent priorPos ) { if ( currentPos == null ) { throw new IllegalArgumentException ( "Null-currentPos-passed." ) ; } if ( priorPos == null ) { throw new IllegalArgumentException ( "Null-priorPos-passed." ) ; } int deltaX = priorPos . getX ( ) - currentPos . getX ( ) ; int deltaY = priorPos . getY ( ) - currentPos . getY ( ) ; if ( Math . abs ( deltaX ) > Math . abs ( deltaY ) ) { if ( deltaX >= 0 ) { directionOfMovement = Direction . LEFT ; } else { directionOfMovement = Direction . RIGHT ; } } else { if ( deltaY >= 0 ) { directionOfMovement = Direction . UP ; } else { directionOfMovement = Direction . DOWN ; } } return directionOfMovement ; } \n', 0.3540065054538519)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 66 #################################
('public void setAutoRefreshFiles ( String remotePath , String [ ] autoRefreshFiles ) { Set newFiles = new HashSet ( Arrays . asList ( autoRefreshFiles ) ) ; if ( autoRefreshFiles . length == DEFAULT_AUTO_REFRESH_FILES . length ) { boolean isDefault = true ; for ( int i = 0 ; i < DEFAULT_AUTO_REFRESH_FILES . length ; i ++ ) { String filePath = DEFAULT_AUTO_REFRESH_FILES [ i ] ; if ( ! newFiles . contains ( new Path ( null , remotePath ) . append ( filePath ) . toString ( ) ) ) { isDefault = false ; break ; } } if ( isDefault ) { this . autoRefreshFiles . remove ( remotePath ) ; return ; } } this . autoRefreshFiles . put ( remotePath , newFiles ) ; } \n', 0.3620554489655235)

('public void setDataFileDirectories ( List < String > dirs ) { config . put ( "data_file_directories" , dirs ) ; } \n', 0.3577268783907666)

('@ Override protected void onAttachGeneratedDirectories ( ) { project . addCompileSourceRoot ( outputDirectory . getAbsolutePath ( ) ) ; if ( ( resourcesOutputDirectory != null ) && ( resourcesOutputDirectory . exists ( ) ) ) { Resource resource = new Resource ( ) ; resource . setDirectory ( resourcesOutputDirectory . getAbsolutePath ( ) ) ; resource . addInclude ( "**/*" ) ; project . addResource ( resource ) ; } } \n', 0.3552646089970502)

('public static boolean setCacheDir ( final File newCache , final boolean moveFiles , final IProgressIndicator progress ) { final File oldCache = s_cacheDir ; s_cacheDir = newCache ; if ( s_cacheDir == null || s_cacheDir . equals ( oldCache ) ) { return false ; } s_cacheDir . mkdir ( ) ; LCTX . i ( "Actual-app-cache-dir:-" + s_cacheDir . getAbsolutePath ( ) ) ; if ( ! moveFiles ) { return true ; } final String [ ] files = oldCache . list ( ) ; if ( LengthUtils . isEmpty ( files ) ) { return true ; } final int count = FileUtils . move ( oldCache , newCache , files , progress ) ; LCTX . i ( "" + count + "-files-moved" ) ; return true ; } \n', 0.3544734932147824)

('@ Override protected void onAttachGeneratedDirectories ( ) { File genSrcDir = new File ( outputDirectory , "gen-src" ) ; if ( genSrcDir . exists ( ) ) { super . outputDirectory = genSrcDir ; } super . onAttachGeneratedDirectories ( ) ; } \n', 0.35222245728989504)

('@ Override protected void onAttachGeneratedDirectories ( ) { File clientDir = new File ( outputDirectory , "client" ) ; if ( clientDir . exists ( ) ) { super . outputDirectory = clientDir ; } super . onAttachGeneratedDirectories ( ) ; } \n', 0.3510071885879605)

('public static void refreshAll ( ) { refreshFor ( File . listRoots ( ) ) ; Repository . getDefault ( ) . getDefaultFileSystem ( ) . refresh ( true ) ; } \n', 0.3503823943155461)

('public void checkInstallDirectories ( ) { try { new File ( PATH_SHARED ) . mkdirs ( ) ; new File ( PATH_TEMPLATES_SHARED ) . mkdirs ( ) ; } catch ( final SecurityException e ) { BadaboomCollector . INSTANCE . add ( e ) ; } } \n', 0.35015642843859285)

('public void checkInstallDirectories ( ) { try { ( new File ( PATH_SHARED ) ) . mkdirs ( ) ; ( new File ( PATH_TEMPLATES_SHARED ) ) . mkdirs ( ) ; } catch ( SecurityException e ) { e . printStackTrace ( ) ; } } \n', 0.35015642843859285)

('public void setAlwaysCreateDirectories ( boolean enable ) { checkParameterLock ( ) ; alwaysCrateDirs = enable ; } \n', 0.3493817852244065)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 67 #################################
('public long convertHours ( long nanoseconds ) { return toHours ( toMinutes ( toSeconds ( nanoseconds ) ) ) ; } \n', 0.4158692637538268)

('@ SuppressWarnings ( "deprecation" ) public static Date toUTC ( final Date withBrowserTz ) { withBrowserTz . setTime ( withBrowserTz . getTime ( ) + ( withBrowserTz . getTimezoneOffset ( ) * 60 * 1000 ) ) ; return withBrowserTz ; } \n', 0.41576728763042115)

('@ Override public Instant convertFromMillis ( long systemTimeMillis ) { return Instant . ofEpochMilli ( systemTimeMillis ) ; } \n', 0.41457507157569884)

('@ Override public long convertToMillis ( DateTime value ) { return value . getMillis ( ) ; } \n', 0.41297449279210985)

('@ Override public long convertToMillis ( java . util . Date value ) { return value . getTime ( ) ; } \n', 0.4086115616774466)

('@ Override public long convertToMillis ( Date value ) { return value . getTime ( ) ; } \n', 0.4086115616774466)

('private static long convertAlldayUtcToLocal ( Time recycle , long utcTime , String tz ) { if ( recycle == null ) { recycle = new Time ( ) ; } recycle . timezone = Time . TIMEZONE_UTC ; recycle . set ( utcTime ) ; recycle . timezone = tz ; return recycle . normalize ( true ) ; } \n', 0.4081797321872943)

('public static long convertAlldayUtcToLocal ( Time recycle , long utcTime , String tz ) { if ( recycle == null ) { recycle = new Time ( ) ; } recycle . timezone = Time . TIMEZONE_UTC ; recycle . set ( utcTime ) ; recycle . timezone = tz ; return recycle . normalize ( true ) ; } \n', 0.4081797321872943)

('public static Date convertToUTC ( final Date date ) { GregorianCalendar calendar = new GregorianCalendar ( date . getYear ( ) + YEAR1900 , date . getMonth ( ) , date . getDate ( ) , date . getHours ( ) , date . getMinutes ( ) , date . getSeconds ( ) ) ; calendar . setTimeZone ( TimeZone . getTimeZone ( UTC_TIME_ZONE ) ) ; return calendar . getTime ( ) ; } \n', 0.4061921362969464)

('public static long convertAlldayLocalToUTC ( Time recycle , long localTime , String tz ) { if ( recycle == null ) { recycle = new Time ( ) ; } recycle . timezone = tz ; recycle . set ( localTime ) ; recycle . timezone = Time . TIMEZONE_UTC ; return recycle . normalize ( true ) ; } \n', 0.4012596620758244)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 68 #################################
('public long getCompletedTasks ( ) { return completedTasks . get ( ) ; } \n', 0.3720351170844981)

('public ArrayList getSynchOperations ( ) { reduceOperations ( ) ; lockAll ( ) ; return getCommitLog ( ) ; } \n', 0.36151829352549736)

('private synchronized ScheduledFuture < ? > getLastJobStartingBefore ( final long maxStartTime ) { long currentDelay = Long . MIN_VALUE ; ScheduledFuture < ? > job = null ; final long maxAllowedDelay = maxStartTime - System . currentTimeMillis ( ) ; for ( final ScheduledFuture < ? > future : futures_ . values ( ) ) { final long delay = future . getDelay ( TimeUnit . MILLISECONDS ) ; if ( ! future . isDone ( ) && delay > currentDelay && ( delay < maxAllowedDelay || delay <= 0 ) ) { currentDelay = delay ; job = future ; } } LOG . debug ( "Last-job-starting-before-" + maxStartTime + ":-" + job + "." ) ; return job ; } \n', 0.3600566994403641)

('@ Managed public long getCompletedTasksLevel4 ( ) { return completedTasksPerLevel . get ( 4 ) ; } \n', 0.36000377997477206)

('@ Managed public long getCompletedTasksLevel2 ( ) { return completedTasksPerLevel . get ( 2 ) ; } \n', 0.36000377997477206)

('@ Managed public long getCompletedTasksLevel3 ( ) { return completedTasksPerLevel . get ( 3 ) ; } \n', 0.36000377997477206)

('@ Managed public long getCompletedTasksLevel1 ( ) { return completedTasksPerLevel . get ( 1 ) ; } \n', 0.36000377997477206)

('@ Managed public long getCompletedTasksLevel0 ( ) { return completedTasksPerLevel . get ( 0 ) ; } \n', 0.36000377997477206)

('public long getCompletedTasks ( ) { return completed . get ( ) ; } \n', 0.3576729127079924)

('public W3CEndpointReference getEpr ( ) { return endpoint . getEndpointReference ( W3CEndpointReference . class ) ; } \n', 0.35503246604447936)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 69 #################################
('private static void printFooter ( double averageOfAverage_AT , double averageOfAverage_DG ) { DecimalFormat df2 = new DecimalFormat ( "##.####" ) ; System . out . println ( "-******************************************-" ) ; System . out . println ( "Average-AT-accuracy-(" + numRuns + "-runs):-" + df2 . format ( averageOfAverage_AT ) + "%" ) ; System . out . println ( "Average-DG-accuracy-(" + numRuns + "-runs):-" + df2 . format ( averageOfAverage_DG ) + "%" ) ; System . out . println ( "-******************************************" ) ; System . out . println ( "-For-a-summary-of-AT,-DG-and-RMSE-results,-refer-to-"Results---averages.csv"." ) ; System . out . println ( "-******************************************" ) ; System . out . println ( "******************************************" ) ; } \n', 0.4167215450442722)

('public void printSchemaInfo ( ) { printSchemaInfo ( System . out ) ; } \n', 0.4025513100256163)

('private void printAttributes ( SimpleNode node ) { String saveIndentation = indentation ; indentation += indent ; Set < Map . Entry < ICodeKey , Object >> attributes = node . entrySet ( ) ; Iterator < Map . Entry < ICodeKey , Object >> it = attributes . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry < ICodeKey , Object > attribute = it . next ( ) ; printAttribute ( attribute . getKey ( ) . toString ( ) , attribute . getValue ( ) ) ; } indentation = saveIndentation ; } \n', 0.4023503806976846)

('public static void printAllFeatures ( Solver solver ) { Attribute . printAll ( solver ) ; } \n', 0.40214736315643074)

('public void printItemAttributes ( ) { System . out . println ( name + "-" + "$" + ( new DecimalFormat ( "0.00" ) ) . format ( price ) + "-" + "qty:-" + quantity + "-" + "wt:-" + weight + "-" + "ship:-" + ( isPremium ? "Premium" : "Standard" ) + "-" + "Item-Total:-$" + ( new DecimalFormat ( "0.00" ) ) . format ( calculatePrice ( ) ) + "-" ) ; } \n', 0.40173945394799815)

('public void printSummary ( ) { System . out . println ( "----------Ingress-information----------" ) ; TraceInfo tinfo ; for ( Enumeration enumVar = ingressTable . elements ( ) ; enumVar . hasMoreElements ( ) ; ) System . out . println ( ( ( TraceInfo ) enumVar . nextElement ( ) ) . toString ( ) ) ; System . out . println ( "----------Egress-information-----------" ) ; for ( Enumeration enumVar = egressTable . elements ( ) ; enumVar . hasMoreElements ( ) ; ) System . out . println ( ( TraceInfo ) enumVar . nextElement ( ) ) ; System . out . println ( "-----------====-Summarry-====----------" ) ; System . out . println ( "Destination-IP:-" + IP_s . IPtoString ( targetIP ) + "-" + "Start-time:-" + startTime + "-End-time:-" + endTime + "-" + "total-Ingress-Pkts:-" + totalIngressPkts + "-" + "total-Egress-Pkts:-" + totalEgressPkts + "-" + "-Pkts-difference:-" + ( totalEgressPkts - totalIngressPkts ) + "-" + "total-Ingress-Size:-" + totalIngressSize + "-" + "total-Egress-Size:-" + totalEgressSize + "-" + "-Size-difference:-" + ( totalEgressSize - totalIngressSize ) + "-" + "total-Ingress-Flows:-" + totalIngressFlows + "-" + "total-Egress-Flows:-" + totalEgressFlows + "-" + "-Flows-difference:-" + ( totalEgressFlows - totalIngressFlows ) + "----------------------------------------" ) ; } \n', 0.4002797995006151)

('public static void printFeatures ( Solver solver ) { Attribute . printSuccint ( solver ) ; } \n', 0.3990304821604844)

('void printIfInfo ( IFAddressInfo ifAInfo ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( printIfInfo ( ifAInfo , new StringBuilder ( ) ) . toString ( ) ) ; } } \n', 0.39814983713771934)

('private void printAttributes ( ICodeNodeImpl node ) { String saveIndentation = indentation ; indentation += indent ; Set < Map . Entry < ICodeKey , Object >> attributes = node . entrySet ( ) ; Iterator < Map . Entry < ICodeKey , Object >> it = attributes . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry < ICodeKey , Object > attribute = it . next ( ) ; printAttribute ( attribute . getKey ( ) . toString ( ) , attribute . getValue ( ) ) ; } indentation = saveIndentation ; } \n', 0.3960870417526208)

('public static String printGraph ( List < Entities > list ) { StringBuilder ss = new StringBuilder ( ) ; ss . append ( "digraph-parsed-{-" ) ; for ( Entities output : list ) { for ( Entity entity : output ) { ss . append ( entity . toXml ( ) ) ; } break ; } ss . append ( "}-" ) ; return ss . toString ( ) ; } \n', 0.39490472306117963)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 70 #################################
('public static ConverterHelper getBestHelper ( Object source , Variant target , Resource resource ) { ConverterHelper result = null ; float bestScore = - 1.0F ; float currentScore ; for ( ConverterHelper ch : Engine . getInstance ( ) . getRegisteredConverters ( ) ) { if ( ch != null ) { try { currentScore = ch . score ( source , target , resource ) ; if ( currentScore > bestScore ) { bestScore = currentScore ; result = ch ; } } catch ( Exception e ) { Context . getCurrentLogger ( ) . log ( Level . SEVERE , "Unable-get-the-score-of-the-" + ch + "-converter-helper." , e ) ; } } } return result ; } \n', 0.39353513468115286)

('public static < T > ConverterHelper getBestHelper ( Representation source , Class < T > target , Resource resource ) { ConverterHelper result = null ; float bestScore = - 1.0F ; float currentScore ; for ( ConverterHelper ch : Engine . getInstance ( ) . getRegisteredConverters ( ) ) { if ( ch != null ) { currentScore = ch . score ( source , target , resource ) ; if ( currentScore > bestScore ) { bestScore = currentScore ; result = ch ; } } } return result ; } \n', 0.39353513468115286)

('public static ConverterHelper getBestHelper ( Object source , Variant target , UniformResource resource ) { ConverterHelper result = null ; float bestScore = - 1.0F ; float currentScore ; for ( ConverterHelper ch : Engine . getInstance ( ) . getRegisteredConverters ( ) ) { try { currentScore = ch . score ( source , target , resource ) ; if ( currentScore > bestScore ) { bestScore = currentScore ; result = ch ; } } catch ( Exception e ) { Context . getCurrentLogger ( ) . log ( Level . SEVERE , "Unable-get-the-score-of-the-" + ch + "-converter-helper." , e ) ; } } return result ; } \n', 0.3900520122303451)

('public boolean resolveConstraints ( ) { if ( ! err ) { exec . evaluateAllExpressions ( topoList ) ; } return ( err ) ; } \n', 0.3838234408416636)

('public Set < OWLClass > getSample ( ) { Set < OWLClass > sample = new HashSet < OWLClass > ( ) ; List < OWLClass > list = new ArrayList < OWLClass > ( ont . getClassesInSignature ( ) ) ; System . out . println ( "-Number-of-classes-in-ontology-signature:-" + list . size ( ) ) ; Collections . shuffle ( list ) ; for ( int i = 0 ; i < sampleSize ; i ++ ) { if ( list . get ( i ) != null ) sample . add ( list . get ( i ) ) ; } System . out . println ( "-Number-of-sample-elements:-" + sample . size ( ) ) ; return sample ; } \n', 0.383179186652171)

('public List < Constraint > getConstraints ( Long objectOMA ) { return objectOMA == null ? null : constraints . get ( objectOMA ) ; } \n', 0.38021840038365967)

('public PredicatewAnnotation getPlanTerm ( ) { if ( planterm == null ) { Predicate pts = new Predicate ( "planterm" ) ; pts . addTerm ( getTriggerEvent ( ) . UnifyingTerm ( ) ) ; Iterator < Guard > itc = getContext ( ) . iterator ( ) ; Predicate ct = new Predicate ( "context" ) ; while ( itc . hasNext ( ) ) { Guard g = itc . next ( ) ; ct . addTerm ( g . toTerm ( ) ) ; } pts . addTerm ( ct ) ; Predicate dt = new Predicate ( "prefix" ) ; Iterator < Deed > itd = getPrefix ( ) . iterator ( ) ; while ( itd . hasNext ( ) ) { dt . addTerm ( itd . next ( ) . UnifyingTerm ( ) ) ; } pts . addTerm ( dt ) ; Predicate dt2 = new Predicate ( "body" ) ; Iterator < Deed > itd2 = getBody ( ) . iterator ( ) ; while ( itd2 . hasNext ( ) ) { dt2 . addTerm ( itd2 . next ( ) . UnifyingTerm ( ) ) ; } pts . addTerm ( dt2 ) ; planterm = new PredicatewAnnotation ( pts ) ; return ( planterm ) ; } else { return planterm ; } } \n', 0.37879283114635764)

('@ SafeVarargs public static List < Pair < SizeUnit , Double >> getMathOperationSafeOperands ( Pair < SizeUnit , Double > ... operands ) { List < Pair < SizeUnit , Double >> operationReadyOperands = new ArrayList < > ( ) ; List < Pair < SizeUnit , Double >> convertedOperands = new ArrayList < > ( ) ; for ( Pair < SizeUnit , Double > operand : operands ) { convertedOperands . add ( autoConvert ( operand . getSecond ( ) . longValue ( ) , operand . getFirst ( ) ) ) ; } SizeUnit finalUnit = leastUnitInList ( convertedOperands ) ; for ( Pair < SizeUnit , Double > operand : convertedOperands ) { if ( operand . getFirst ( ) != finalUnit ) { operationReadyOperands . add ( new Pair < SizeConverter . SizeUnit , Double > ( finalUnit , convert ( operand . getSecond ( ) . longValue ( ) , operand . getFirst ( ) , finalUnit ) . doubleValue ( ) ) ) ; } else { operationReadyOperands . add ( operand ) ; } } return operationReadyOperands ; } \n', 0.3776597622656927)

('protected static Vector < String [ ] > getPredicatesFromSignatures ( Collection < Signature > sigs ) { Vector < String [ ] > ret = new Vector < String [ ] > ( ) ; for ( Signature sig : sigs ) { int numArgTypes = sig . argTypes . length ; if ( ! sig . isBoolean ( ) ) numArgTypes ++ ; String [ ] a = new String [ 1 + numArgTypes ] ; a [ 0 ] = sig . functionName ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( i - 1 < sig . argTypes . length ) a [ i ] = sig . argTypes [ i - 1 ] ; else a [ i ] = sig . returnType ; } ret . add ( a ) ; } return ret ; } \n', 0.37689300272436116)

('public ptolemy . graph . InequalityTerm getTypeTerm ( String name ) throws IllegalActionException { Iterator scopes = _scopeList . iterator ( ) ; while ( scopes . hasNext ( ) ) { ParserScope scope = ( ParserScope ) scopes . next ( ) ; InequalityTerm result = scope . getTypeTerm ( name ) ; if ( result != null ) { return result ; } } return null ; } \n', 0.3754814113221753)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 71 #################################
('public static String convertHtmlToXhtml ( String html ) { PrintStream errStream = System . err ; System . setErr ( new PrintStream ( new OutputStream ( ) { @ Override public void write ( int b ) throws IOException { } } ) ) ; Tidy tidy = new Tidy ( ) ; tidy . setXHTML ( true ) ; tidy . setCharEncoding ( Configuration . UTF8 ) ; ByteArrayInputStream inputStream = new ByteArrayInputStream ( html . getBytes ( StandardCharsets . UTF_8 ) ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; tidy . parseDOM ( inputStream , outputStream ) ; System . setErr ( errStream ) ; try { return outputStream . toString ( StandardCharsets . UTF_8 . toString ( ) ) ; } catch ( UnsupportedEncodingException e ) { return html ; } } \n', 0.3929163083544746)

('public static String convertToDisplayHtml ( String input ) { List < Range > ranges = parseIntoRanges ( input ) ; StringBuilder output = new StringBuilder ( input . length ( ) ) ; for ( Range range : ranges ) { String rangeString = input . substring ( range . from , range . to ) ; if ( range . rangeKind == RangeKind . TEXT ) { boolean applyFinalBr = range . to != input . length ( ) ; output . append ( nl2br ( rangeString , applyFinalBr ) ) ; } else output . append ( rangeString ) ; } return output . toString ( ) ; } \n', 0.3816248687620104)

('public static String toHTML ( char character ) { switch ( character ) { case SYMBOL_NEW_LINE : return HTML_TAG_BR ; case SYMBOL_SPACE : return HTML_SPACE ; default : return String . valueOf ( character ) ; } } \n', 0.37928552536701965)

("public static String escapeHtml ( final String unescapedText ) { final String escapedText = StringEscapeUtils . escapeHtml4 ( unescapedText ) ; final StringBuilder tmpText = new StringBuilder ( ) ; for ( int i = 0 ; i < escapedText . length ( ) ; ++ i ) { switch ( escapedText . charAt ( i ) ) { case '|t' : tmpText . append ( XML_TAG_TAB ) ; break ; case '|r' : tmpText . append ( XML_TAG_BR ) ; if ( ( escapedText . length ( ) > i + 1 ) && escapedText . charAt ( i + 1 ) == '|n' ) { i ++ ; } break ; case '|n' : tmpText . append ( XML_TAG_BR ) ; if ( ( escapedText . length ( ) > i + 1 ) && escapedText . charAt ( i + 1 ) == '|r' ) { i ++ ; } break ; default : tmpText . append ( escapedText . charAt ( i ) ) ; break ; } } return tmpText . toString ( ) ; } \n", 0.37699471579172905)

("static public StringBuilder toHtml ( StringBuilder text ) { for ( int i = 0 ; i < text . length ( ) ; i ++ ) { char c = text . charAt ( i ) ; String html = null ; switch ( c ) { case '/' : case '<' : case '>' : html = toHtml ( c ) ; break ; case '|n' : html = HTML_LINEBREAK ; break ; case Util . DT : html = HTML_DT ; break ; case Util . UT : html = HTML_UT ; break ; case Util . LT : html = HTML_LT ; break ; case Util . RT : html = HTML_RT ; break ; default : if ( c > 0xFF ) { html = toHtml ( c ) ; } } if ( html != null ) { text . replace ( i , i + 1 , html ) ; i += html . length ( ) - 1 ; } } return text ; } \n", 0.37552811302148964)

('public static String toHtml ( String string ) { if ( DO_NOTHING ) return string ; string = org . apache . commons . lang3 . StringEscapeUtils . ESCAPE_HTML4 . with ( NumericEntityEscaper . between ( 0x7f , Integer . MAX_VALUE ) ) . translate ( string ) ; if ( string != null ) { string = string . replaceAll ( "&amp;" , "&" ) ; } return string ; } \n', 0.3744158600377159)

('public static String nlToBr ( String s , boolean escapeXml ) { if ( s == null ) { return "" ; } try { StringBuilder builder = new StringBuilder ( ) ; BufferedReader reader = new BufferedReader ( new StringReader ( s ) ) ; boolean firstLine = true ; for ( String line = reader . readLine ( ) ; line != null ; line = reader . readLine ( ) ) { if ( ! firstLine ) { builder . append ( "<br/>" ) ; } builder . append ( StringEscapeUtils . escapeXml ( line ) ) ; firstLine = false ; } return builder . toString ( ) ; } catch ( IOException e ) { throw new ShouldNeverHappenException ( e ) ; } } \n', 0.37435278197852107)

('public static String escapeToHtmlText ( final String text , final CharsetEncodingCapability capability ) { final StringBuffer buffer = new StringBuffer ( ) ; for ( final char c : text . toCharArray ( ) ) { final String escaped = escapeHtmlIfNeeded ( c , capability ) ; buffer . append ( escaped ) ; } return buffer . toString ( ) ; } \n', 0.37198373026241516)

('public static String escapeTextAroundXMLTags ( String s ) { StringBuilder result = new StringBuilder ( ) ; Reader r = new StringReader ( s ) ; try { do { String text = readUntilTag ( r ) ; result . append ( escapeXML ( text ) ) ; XMLTag tag = readAndParseTag ( r ) ; if ( tag == null ) { break ; } result . append ( tag . toString ( ) ) ; } while ( true ) ; } catch ( Exception e ) { System . err . println ( "Error-reading-string" ) ; e . printStackTrace ( ) ; } return result . toString ( ) ; } \n', 0.37134093227989845)

('public static String escapeHtmlFixCopyright ( String value ) { if ( value . startsWith ( "&#169;" ) ) { value = "copyright-(c)" + value . substring ( 6 ) ; } return FormattedText . escapeHtml ( value , true ) ; } \n', 0.3711091947379619)

FRank:   | P@1:   | P@5:   | P@10: 

Mean sims: 0.4008